#压缩存储 
对于稀疏矩阵，如果还用传统的二维数组存储，会浪费大量空间来存储零元素。压缩存储的思想就是**只存储非零元素**

1. #不同的压缩存储方式 ：
	-  **按行优先 (Row-major order)**，即将矩阵的非零元素逐行地、从左到右地存放到一个一维数组中。
		根据图示，存储顺序为：
		$a_{1,1}, a_{1,2}, a_{2,1}, a_{2,2}, a_{2,3}, a_{3,2}, a_{3,3}, a_{3,4}, \dots$
    *   **按列优先 (Column-major order)**：将非零元素逐列存入一维数组。这时需要计算目标元素前面各列的非零元素数量。
    *   **分区域存储**：例如，将三条对角线分开存储。用3个一维数组，或者将3个区域拼接在一个大的一维数组里。例如，先存所有次对角线元素，再存主对角线，最后存超对角线。此时，计算 $m_{30,30}$ 的位置就需要先跳过所有次对角线元素，然后在主对角线区域里找到第30个元素。
    * #三元组表  这是一种 #顺序存储 结构，专门用来压缩存储 #稀疏矩阵 。它将每个非零元素表示为一个三元组 `(行, 列, 值)`，然后将所有这些三元组存储在一个线性表（通常是数组）中。此外，还需要额外存储矩阵的总行数、总列数和非零元素总数。这完全符合压缩存储稀疏矩阵的思想。[[三元组表]] 
	 - #十字链表  这是一种 #链式存储 结构，也是为 #稀疏矩阵 设计的。对于每个非零元素，它创建一个结点，该结点不仅包含 `(行, 列, 值)` 信息，还包含两个指针：一个指向其所在行的下一个非零元素（`right` 指针），另一个指向其所在列的下一个非零元素（`down` 指针）。这种结构使得对特定行或列的操作（如查找、插入、删除）变得非常高效。它同样是压缩存储稀疏矩阵的有效方法  [[十字链表]] 
	 - #邻接矩阵 这是**图**的一种存储结构，通常用一个二维数组 `G[n][n]` 来表示一个有 `n` 个顶点的图。`G[i][j]` 的值表示顶点 `i` 和顶点 `j` 之间的关系（例如，对于无权图，1 表示有边，0 表示无边）。如果一个图是稀疏的（边的数量远小于顶点数量的平方），其邻接矩阵就是一个稀疏矩阵。但邻接矩阵本身**并不是一种压缩存储技术**，它的空间复杂度始终是 $O(n^2)$，其中 $n$ 是顶点数。这与压缩存储的目标背道而驰。
	 - #二叉链表  这是用来存储**树或森林**的结构。最经典的应用是“左孩子右兄弟”表示法，每个结点有两个指针，一个指向它的第一个孩子，另一个指向它的下一个兄弟。这种结构与矩阵的二维网格结构完全无关，不适用于存储矩阵 