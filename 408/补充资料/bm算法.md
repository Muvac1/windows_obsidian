#Boyer-Moore（BM）算法 核心思想    
#BM算法 是一种高效的字符串匹配算法。它的核心特点是从模式串的末尾开始向前比较，并且在发生不匹配时，利用已经获得的信息来尽可能大地向后移动模式串，从而跳过大量不必要的比较。

为了实现“尽可能大的移动”，BM算法使用了两个启发式策略：

*   **坏字符策略 (Bad Character Rule)**
*   **好后缀策略 (Good Suffix Rule)**

在每次移动时，算法会分别计算这两个策略建议的移动位数，然后取其中 **较大者** 作为最终的移动距离。即：`shift = max(坏字符移动距离, 好后缀移动距离)`。


1. #BM算法的时间复杂度 
	最好情况时间复杂度为 $O(n/m)$。这种情况通常发生在每次不匹配后，模式串都可以向后移动 `m` 位（即模式串的整个长度）。这样，总的比较次数大约是 $n/m$ 次，每次比较最多 `m` 个字符，但由于我们只关心比较的轮数，所以复杂度为 $O(n/m)$。
	 BM算法的最好情况 #时间复杂度 为 $O(n/m)$。这种情况通常发生在每次不匹配后，模式串都可以向后移动 `m` 位（即模式串的整个长度）。这样，总的比较次数大约是 $n/m$ 次，每次比较最多 `m` 个字符，但由于我们只关心比较的轮数，所以复杂度为 $O(n/m)$。
	- **问题**：BM算法的最坏 #时间复杂度 是多少？    
	- **答案**：朴素的BM算法最坏情况是 $O(nm)$。例如，文本串 T = "aaaaaaaaa"，模式串 P = "baaa"。每次不匹配后都只能移动一位。不过，通过对好后缀策略进行优化（引入额外的表），可以将其最坏时间复杂度优化到 $O(n+m)$。

**如何实现每次移动 `m` 位？**
一个典型的最好情况是：模式串中的字符在文本串的对应窗口中完全不存在。
例如：
文本串 T = "AAAAAAAAAAAAAAAA"
模式串 P = "BCDE"

当 P 第一次与 T 的 "AAAA" 对齐时，从右向左比较，P 的最后一个字符 'E' 与 T 的 'A' 不匹配。此时，文本串中的这个 'A' 就是“坏字符”。


2. #BM算法的两种策略 对比：
    *   **问题**：请分别举例说明坏字符策略优于好后缀策略，以及好后缀策略优于坏字符策略的场景。
    *   **坏字符更优**：如上文反例，当坏字符不在模式串中时，坏字符策略能提供最大位移。
    *   **好后缀更优**：文本串 T = `...abcabc...`，模式串 P = `xxabc`。当 `xxabc` 与 `abcab` 匹配时，在 `x` 和 `a` 处不匹配，好后缀为 `abc`。好后缀策略会移动3位，而坏字符 `a` 在模式串中存在，坏字符策略移动距离可能很小。
3. 与[[KMP算法]]的比较    
	*   **KMP**：从左到右比较，时间复杂度稳定在 $O(n+m)$，没有“最坏情况陷阱”。
	*   **BM**：从右到左比较，平均情况（尤其是在字符集较大时）下通常比KMP更快，因为它跳过的字符更多。但朴素实现有 $O(nm)$ 的最坏情况。
4. 算法实现细节  
	1. 如何预处理计算坏字符表和好后缀表？
	    *   **答案**：这是考察算法实现能力的好问题。坏字符表相对简单，通常是一个数组，记录每个字符在模式串中最后出现的位置。好后缀表的计算则更复杂，需要计算 `suffix` 数组和 `prefix` 数组，这部分逻辑类似KMP的 `next` 数组计算。