
| 寻址方式 | 中文名 | 有效地址计算公式 | 说明和用途 |
| :--- | :--- | :--- | :--- |
| **Immediate** | 立即寻址 | 操作数 = A | 指令中直接包含操作数本身，而不是地址。速度最快。常用于给变量赋常数值。 |
| **Direct** | 直接寻址 | $EA = A$ | 指令中直接给出了操作数的有效地址。简单，但寻址空间受地址字段长度限制。 |
| **Indirect** | 间接寻址 | $EA = (A)$ | 指令中的地址是存放有效地址的内存单元的地址。需要两次访存才能取到操作数，速度慢，但提供了更大的寻址空间和灵活性（如指针）。 |
| **Register** | 寄存器寻址 | $EA = R$ | 操作数在寄存器中，指令中指定寄存器编号。速度很快，因为无需访存。 |
| **Register Indirect** | 寄存器间接寻址 | $EA = (R)$ | 寄存器中存放的是操作数的有效地址。比直接寻址快（少一次访存），比寄存器寻址灵活。 |
| **Displacement** | **偏移寻址 (总类)** | $EA = A + (R)$ | **一个形式地址 A 和一个寄存器 R 的内容相加。以下三种是其特例。** |
| ↳ **Relative** | 相对寻址 | $EA = A + (PC)$ | A 是相对于当前指令的偏移量。主要用于条件分支和循环，使得代码位置无关。 |
| ↳ **Base Register** | 基址寻址 | $EA = A + (BR)$ | A 是相对于基地址的偏移量。便于程序浮动（重定位）和多道程序设计。 |
| ↳ **Indexed** | 变址寻址 | $EA = A + (IX)$ | A 是基准地址，变址寄存器内容是索引。特别适合处理数组和字符串等连续存储的数据结构。 |
