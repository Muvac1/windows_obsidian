1. 无符号整数 (Unsigned Integers)
	*   **表示**: `unsigned int` (通常为32位) 用所有位来表示数值。其表示范围为 $[0, 2^{32}-1]$。例如，一个32位的`unsigned int`最大值为 `0xFFFFFFFF`，即4,294,967,295。
	*   **运算特性 - “回绕” (Wrap-around)**: 无符号整数的运算遵循模运算规则（模 $2^{32}$）。当运算结果超出其表示范围时，它会自动“回绕”。
	    *   **上溢**: 最大值 `(2^{32}-1)` 再加 `1` 会变成 `0`。
	    *   **下溢**: 最小值 `0` 再减 `1` 会变成最大值 `(2^{32}-1)`。
	    *   **应用场景**: 这个特性是题目(1)中`n=0`时，`n-1`变成一个巨大正数，从而导致死循环的根本原因。
2. 有符号整数 (Signed Integers) 与二进制补码 (Two's Complement)
	*   **表示**: `int` (通常为32位) 使用最高位作为符号位（0为正，1为负），其余位表示数值。为了简化硬件加减法运算，现代计算机普遍采用**二进制补码**来表示有符号整数。其范围是 $[-2^{31}, 2^{31}-1]$。
	*   **二进制补码要点**:
	    *   正数的补码就是其自身的二进制表示。
	    *   负数的补码是其绝对值的二进制表示**按位取反，再加一**。
	    *   一个关键特例：`1111...1111` (所有位都为1) 这个位模式，在补码中表示 `-1`。
	*   **运算特性 - 溢出 (Overflow)**: 当有符号整数的运算结果超出了其表示范围，就会发生溢出。
	    *   **行为**: C语言标准规定，有符号整数溢出是**未定义行为 (Undefined Behavior)**。但在绝大多数常见的平台上，其表现和无符号数类似，也会“回绕”。例如，最大正数 `(2^{31}-1)` 再加 `1` 会变成最小负数 `(-2^{31})`。
	    *   **应用场景**: 题目(4)中，计算结果 $2^{32}-1$ (二进制为32个1)，在`int`类型中被解释为`-1`，这就是有符号数溢出和补码表示共同作用的结果。
3. C语言中的隐式类型转换
	*   **规则**: 当一个表达式中同时包含有符号数和无符号数时，C语言会**将有符号数隐式地转换为无符号数**，然后再进行比较或运算。
	*   **陷阱**: `int`类型的`-1`会被转换成`unsigned int`类型的最大值 `0xFFFFFFFF`。这就是为什么在C语言中，表达式 `-1 > 0U` 的结果为`true`。这个规则也是理解题目(1)循环条件`i <= n - 1`的关键之一。


[[浮点数的数据表示]]  
