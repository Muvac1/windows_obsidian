#Boyer-Moore（BM）算法 核心思想    
#BM算法 是一种高效的 #字符串匹配算法 。它的核心特点是从模式串的末尾开始向前比较，并且在发生不匹配时，利用已经获得的信息来尽可能大地向后移动模式串，从而跳过大量不必要的比较。  
#BM算法 是目前被认为 #最高效的字符串搜索算法之一 ，它通常比 KMP 算法更快。其核心在于利用两个启发式规则来跳过尽可能多的字符

为了实现“尽可能大的移动”，BM算法使用了两个 #启发式策略 ：

*   **坏字符策略 (Bad Character Rule)**
*   **好后缀策略 (Good Suffix Rule)**

1.  #坏字符规则 (Bad Character Heuristic)：
    *   依据主串中那个导致失配的字符（坏字符）在模式串中出现的位置来决定移动距离。
    *   如果没有出现，则直接跨过该字符。
	    * 公式：$shift_{bc}=j-last(T[i])$，其中 $j$ 是不匹配的位置，$last(c)$ 是字符 $c$ 在模式串中最右出现的位置 
	    * 假设主串为$T$，模式串为$P$，模式串长度为$m$。
			当匹配进行到模式串的下标$j$（即$P[j]$）与主串字符$T[i]$不匹配时，$T[i]$就是坏字符。
			
			我们需要计算移动步数$shift$：
			$shift=j-bc[T[i]]$
			
			其中$bc[T[i]]$是坏字符$T[i]$在模式串中**最右侧**出现的位置（如果模式串中不存在该字符，通常记为$-1$）。
	    * [[构建坏字符表的伪代码]] 

2.  #好后缀规则 (Good Suffix Heuristic)： 
    *   依据已经匹配成功的后缀（好后缀）在模式串中再次出现的位置来移动。
    *   数组 $gs$（Good Suffix shift）通常是预处理计算好的。
    *   **规则细节**：如果后缀 $u$ 匹配成功，算法会查找模式串中是否还有另一个 $u$ 出现。如果没有，会查找 $u$ 的最长后缀是否也是模式串的前缀。本题考查的 $gs[0]=1$ 属于极端情况，即整个 $m-1$ 长度的后缀向左错一位就能在模式串头部找到（即模式串本身具备周期为1的性质）。
	    * 公式：$shift_{gs}$ 由预处理数组 `gs[]` 决定  

3. **移动策略：**
    每次移动的步长为 $max(shift_{bc},shift_{gs})$。
	在每次移动时，算法会分别计算这两个策略建议的移动位数，然后取其中 **较大者** 作为最终的移动距离。即：`shift = max(坏字符移动距离, 好后缀移动距离)`。

4. #BM算法的时间复杂度 
	最好情况时间复杂度为 $O(n/m)$。这种情况通常发生在每次不匹配后，模式串都可以向后移动 `m` 位（即模式串的整个长度）。这样，总的比较次数大约是 $n/m$ 次，每次比较最多 `m` 个字符，但由于我们只关心比较的轮数，所以复杂度为 $O(n/m)$。
	 BM算法的最好情况 #时间复杂度 为 $O(n/m)$。这种情况通常发生在每次不匹配后，模式串都可以向后移动 `m` 位（即模式串的整个长度）。这样，总的比较次数大约是 $n/m$ 次，每次比较最多 `m` 个字符，但由于我们只关心比较的轮数，所以复杂度为 $O(n/m)$。
	- **问题**：BM算法的最坏 #时间复杂度 是多少？    
	- **答案**：朴素的BM算法最坏情况是 $O(nm)$。例如，文本串 T = "aaaaaaaaa"，模式串 P = "baaa"。每次不匹配后都只能移动一位。不过，通过对好后缀策略进行优化（引入额外的表），可以将其最坏时间复杂度优化到 $O(n+m)$。
5. **空间复杂度：** $O(m+|\Sigma|)$，需要存储 #跳转表 [[跳表]] 

**如何实现每次移动 `m` 位？**
一个典型的最好情况是：模式串中的字符在文本串的对应窗口中完全不存在。
例如：
文本串 T = "AAAAAAAAAAAAAAAA"
模式串 P = "BCDE"

当 P 第一次与 T 的 "AAAA" 对齐时，从右向左比较，P 的最后一个字符 'E' 与 T 的 'A' 不匹配。此时，文本串中的这个 'A' 就是“坏字符”。


2. #BM算法的两种策略 对比：
    *   **问题**：请分别举例说明坏字符策略优于好后缀策略，以及好后缀策略优于坏字符策略的场景。
    *   **坏字符更优**：如上文反例，当坏字符不在模式串中时，坏字符策略能提供最大位移。
    *   **好后缀更优**：文本串 T = `...abcabc...`，模式串 P = `xxabc`。当 `xxabc` 与 `abcab` 匹配时，在 `x` 和 `a` 处不匹配，好后缀为 `abc`。好后缀策略会移动3位，而坏字符 `a` 在模式串中存在，坏字符策略移动距离可能很小。
3. 与[[KMP算法]]的比较    
	*   **KMP**：从左到右比较，时间复杂度稳定在 $O(n+m)$，没有“最坏情况陷阱”。
	*   **BM**：从右到左比较，平均情况（尤其是在字符集较大时）下通常比KMP更快，因为它跳过的字符更多。但朴素实现有 $O(nm)$ 的最坏情况。
4. 算法实现细节  
	1. 如何预处理计算坏字符表和好后缀表？
	    *   **答案**：这是考察算法实现能力的好问题。坏字符表相对简单，通常是一个数组，记录每个字符在模式串中最后出现的位置。好后缀表的计算则更复杂，需要计算 `suffix` 数组和 `prefix` 数组，这部分逻辑类似KMP的 `next` 数组计算。