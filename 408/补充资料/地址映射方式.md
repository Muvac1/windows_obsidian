1. #直接映射 (Direct Mapping) 
	1. 最简单、最直接的映射方式。
	*   **规则**: 主存中的每一个块只能映射到 Cache 中一个**唯一的、固定的行**。
	*   **计算公式**:
	    $Cache行号 = (主存块号) \pmod{Cache总行数}$
	*   **地址结构**:
	    | 标记 (Tag) | 索引 (Index) | 块内偏移 (Offset) |
	    *   这里的“索引”字段直接给出了 Cache 行号。
	*   **工作流程**:
	    1.  CPU给出地址。
	    2.  硬件根据地址中的 **索引** 位，直接定位到 Cache 的某一行。
	    3.  然后，比较地址中的 **标记** 位和 Cache 该行中存储的标记。
	    4.  如果标记匹配且有效位为1，则 **命中 (Hit)**。使用 **块内偏移** 在数据块中找到具体数据。
	    5.  如果标记不匹配或有效位为0，则 **缺失 (Miss)**。
	
	*   **优点**:
	    *   硬件实现简单，电路成本低。
	    *   查找速度快，因为只需要检查一个位置。
	*   **缺点**:
	    *   **冲突率高**。如果程序频繁交替访问两个映射到同一 Cache 行的不同主存块，就会导致不断的替换和缺失，即使 Cache 的其他行都是空的。这种情况称为 **抖动 (Thrashing)**。
2. #全相联映射 (Fully Associative Mapping) 
	最灵活的映射方式。
	*   **规则**: 主存中的任意一个块可以映射到 Cache 中的**任意一行**。
	*   **地址结构**:
	    | 标记 (Tag) | 块内偏移 (Offset) |
	    *   没有索引位！因为没有预设的位置。
	*   **工作流程**:
	    1.  CPU给出地址。
	    2.  硬件需要将地址中的 **标记** 位与 Cache 中 **所有行** 的标记 **同时** 进行比较。
	    3.  如果任意一行的标记匹配且有效位为1，则 **命中 (Hit)**。
	    4.  如果所有行都不匹配，则 **缺失 (Miss)**。这时需要一个**替换算法**（如LRU）来决定丢弃哪一行的数据，以腾出空间。
	*   **优点**:
	    *   **冲突率最低**，Cache 空间利用率最高。只要 Cache 没满，就不会发生冲突缺失。
	*   **缺点**:
	    *   **硬件极其复杂且昂贵**。需要大量的比较器来并行比较所有行的标记，这通常用昂贵的**内容寻址存储器 (CAM)** 来实现。
	    *   随着 Cache 容量增大，比较电路的规模和功耗会急剧上升，导致查找速度变慢。因此，纯粹的全相联 Cache 通常容量很小。
3. #相联映射 (Set-Associative Mapping) 
	这是直接映射和全相联映射的一种折中方案，也是现代 CPU 中最常用的一种方式。
	*   **规则**: 先将 Cache 分成若干个**组 (Set)**。主存中的一个块首先被**直接映射**到一个特定的组，但它可以在这个组内的**任意一行**存放。
	*   **概念**: 如果一个组内有 $k$ 个行，就称为 **k-路组相联 (k-way set-associative)**。
	*   **计算公式**:
	    $Cache组号 = (主存块号) \pmod{Cache总组数}$
	*   **地址结构**:
	    | 标记 (Tag) | 组索引 (Set Index) | 块内偏移 (Offset) |
	*   **工作流程**:
	    1.  CPU给出地址。
	    2.  硬件根据地址中的 **组索引** 位，直接定位到 Cache 的某一个组。
	    3.  然后，将地址中的 **标记** 位与该组内 **所有 $k$ 行** 的标记 **同时** 进行比较。
	    4.  如果组内有任何一行的标记匹配，则 **命中 (Hit)**。
	    5.  如果组内所有行都不匹配，则 **缺失 (Miss)**。使用替换算法（如LRU）在该组内选择一行进行替换
	*   **优点**:
	    *   在冲突率和硬件成本之间取得了很好的平衡。相比直接映射，冲突率显著降低；相比全相联，硬件成本和复杂度大大减少。
	*   **缺点**:
	    *   比直接映射要复杂，比全相联映射的冲突率要高。
* 组相联的两个极端 
	*   **1-路组相联** (每个组只有1行): 这就等同于**直接映射**。
	*   **N-路组相联** (如果Cache总共有N行，只分1个组): 这就等同于**全相联映射**。
*  总结与比较

| 特性       | 直接映射 (Direct Mapping) | 全相联映射 (Fully Associative) | 组相联映射 (Set-Associative) |
| :------- | :-------------------- | :------------------------ | :---------------------- |
| **映射规则** | 多对一固定映射               | 多对多任意映射                   | 分组，组间直接映射，组内全相联         |
| **地址字段** | Tag, Index, Offset    | Tag, Offset               | Tag, Set Index, Offset  |
| **冲突概率** | 高                     | 最低                        | 中等 (随k值增大而降低)           |
| **硬件成本** | 低                     | 非常高                       | 中等 (随k值增大而增高)           |
| **查找速度** | 快 (查1个)               | 慢 (查所有)                   | 较快 (查k个)                |
| **实际应用** | 早期的或一些低成本的Cache       | 主要用于TLB等小型专用缓存            | **现代CPU Cache的主流选择**    |
