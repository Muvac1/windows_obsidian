![[Pasted image 20251216060324.png]]

根据截图中提到的考点（排序算法的复杂度、排序过程识别、元素归位特性、希尔排序步长等），我为你设计了以下 5 道针对性的练习题，并附带了详细的解析。

这些题目涵盖了图片中强调的“**真题尚未考过但极可能考**”的题型。

---

### 第一部分：复杂度与特性考察

**题目 1：排序算法综合对比（填空题）**
请完成下表，填写各排序算法的时间复杂度、空间复杂度及稳定性（“是”或“否”）。

| 算法名称 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 稳定性 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 直接插入排序 | \_\_\_\_\_\_ | \_\_\_\_\_\_ | $O(n^2)$ | $O(1)$ | \_\_\_\_\_\_ |
| 快速排序 | $O(n\log n)$ | \_\_\_\_\_\_ | $O(n\log n)$ | \_\_\_\_\_\_ | \_\_\_\_\_\_ |
| 堆排序 | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ | \_\_\_\_\_\_ | \_\_\_\_\_\_ |
| 归并排序 | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ | \_\_\_\_\_\_ | \_\_\_\_\_\_ |

**【答案与解析】**
*   **直接插入排序**：最好 $O(n)$（本来就有序），最坏 $O(n^2)$，稳定性：**是**。
*   **快速排序**：最坏 $O(n^2)$（退化为冒泡），空间 $O(\log n)$（递归栈深度），稳定性：**否**。
*   **堆排序**：空间 $O(1)$，稳定性：**否**（堆顶交换到末尾时可能破坏顺序）。
*   **归并排序**：空间 $O(n)$（需要辅助数组），稳定性：**是**。
*   *考点对应：图片中提到的“最好的排序算法的最好、最差、平均时间复杂度，空间复杂度”。*

---

### 第二部分：排序过程的“中间状态”识别（重点）

**题目 2：识别排序算法**
给定一组初始关键字序列：`{49, 38, 65, 97, 76, 13, 27, 49*}`。
在进行了**两趟**排序后，结果序列变为：`{38, 49, 65, 97, 76, 13, 27, 49*}`。
请问这最可能是哪种排序算法的前两趟结果？
A. 冒泡排序
B. 选择排序
C. 直接插入排序
D. 快速排序

**【答案】 C**
**【解析】**
*   **分析**：观察两趟后的序列，前三个元素 `{38, 49, 65}` 是有序的，而后面的元素 `{97, 76, 13...}` 保持原样未动。
*   **A 冒泡排序**：两趟后，最大的两个元素应该“浮”到了最后面，即最后两个位置应该是确定的最大值。这里的最后两个还是原样的，排除。
*   **B 选择排序**：两趟后，最小的两个元素应该被交换到了最前面。原序列最小的是13和27，结果序列开头却是38，排除。
*   **C 直接插入排序**：
    *   初始：`[49], 38, ...`
    *   第一趟：将38插入有序区，得 `[38, 49], 65, ...`
    *   第二趟：将65插入有序区，得 `[38, 49, 65], 97, ...`
    *   符合题目描述。
*   *考点对应：图片中提到的“比如这个序列是哪个排序的第二趟排序的结果”。*

---

### 第三部分：元素“归位”特性考察

**题目 3：元素位置确定性（多选）**
在以下排序算法中，**每一趟**排序结束后，至少能保证有一个元素被放置在其最终有序位置（即“归位”）的算法是：
A. 直接插入排序
B. 冒泡排序
C. 简单选择排序
D. 快速排序 (Partition过程)
E. 归并排序

**【答案】 B, C, D**
**【解析】**
*   **A 直接插入排序**：它只是保证前面的子序列有序，但这些元素在最终序列中可能还要往后移（比如前面排好了1, 3, 5，后来来了个0，它们都要动），所以**不保证**归位。
*   **B 冒泡排序**：每一趟都会把当前未排序部分的最大（或最小）值“冒”到最后，**保证**归位。
*   **C 简单选择排序**：每一趟选出最小值的交换到前面，**保证**归位。
*   **D 快速排序**：每一趟Partition确定枢轴（Pivot）的位置，枢轴左边都比它小，右边都比它大，枢轴本身**保证**归位。
*   **E 归并排序**：是分治合并的过程，中间状态无法保证任何元素在最终位置，**不保证**。
*   *考点对应：图片中提到的“归位不归位和其他特点”。*

---

### 第四部分：希尔排序与步长

**题目 4：希尔排序的过程**
已知序列 `{50, 26, 38, 80, 70, 90, 8, 30, 40, 20}`，采用希尔排序。
设第一趟排序的增量（步长）$d_1 = 5$。请写出第一趟排序后的结果序列。

**【答案】**
`{50, 8, 30, 40, 20, 90, 26, 38, 80, 70}`

**【解析】**
步长为 5，意味着我们将数组分成 5 组，每组元素下标相差 5。
*   **第1组**：索引 0 和 5 -> `{50, 90}`。排序后：`{50, 90}` (无需交换)
*   **第2组**：索引 1 和 6 -> `{26, 8}`。排序后：`{8, 26}` (交换)
*   **第3组**：索引 2 和 7 -> `{38, 30}`。排序后：`{30, 38}` (交换)
*   **第4组**：索引 3 和 8 -> `{80, 40}`。排序后：`{40, 80}` (交换)
*   **第5组**：索引 4 和 9 -> `{70, 20}`。排序后：`{20, 70}` (交换)
*   将各组元素放回原位置，得到：`50, 8, 30, 40, 20, 90, 26, 38, 80, 70`。
*   *考点对应：图片中提到的“希尔排序要结合步长序列考察”。*

---

### 第五部分：快速排序划分过程

**题目 5：快速排序的 Partition**
对序列 `{46, 79, 56, 38, 40, 84}` 进行快速排序。以第一个元素 `46` 为基准（Pivot），请写出**一次**划分（Partition）后的结果序列。

**【答案】**
`{40, 38, 46, 56, 79, 84}` （注：根据具体教材指针交换逻辑，左右可能略有不同，但46必须在中间且左小右大）

**【解析】**
采用经典的双指针法（Low指向首，High指向尾）：
1.  **Pivot = 46**。Low=0, High=5。
2.  High从右向左找比46小的：`84`>46, `40`<46。High停在索引4 (`40`)。
    *   将 `40` 移到 Low 位置。序列变：`{40, 79, 56, 38, [40], 84}` (此时High位置空出/重复)。
3.  Low从左向右找比46大的：`40`<46, `79`>46。Low停在索引1 (`79`)。
    *   将 `79` 移到 High 位置。序列变：`{40, [79], 56, 38, 79, 84}`。
4.  High继续向左：`38`<46。High停在索引3 (`38`)。
    *   将 `38` 移到 Low 位置。序列变：`{40, 38, 56, [38], 79, 84}`。
5.  Low继续向右：`56`>46。Low停在索引2 (`56`)。
    *   将 `56` 移到 High 位置。序列变：`{40, 38, [56], 56, 79, 84}`。
6.  Low 和 High 相遇在索引 2。
7.  将 Pivot (`46`) 放入 Low 位置。
8.  最终结果：`{40, 38, 46, 56, 79, 84}`。
*   *考点对应：图片中提到的“排序的过程”。*

---

**复习建议：**
针对截图中提到的“尚未考过但可能会考”的部分，建议重点手动模拟**希尔排序**（步长变化）、**堆排序**（建堆过程）和**快速排序**（Partition过程），不要只背代码，要能画出每一步数组的样子。