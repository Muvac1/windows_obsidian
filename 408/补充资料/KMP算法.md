好的，我们来详细、一步一步地拆解 KMP 算法。 #如何手动计算next数组   [[KMP算法改进nextval数组]] 

KMP 算法由 Donald Knuth、Vaughan Pratt 和 James Morris 在 1977 年联合发表，因此取三人姓氏首字母命名。它是一种高效的字符串匹配算法，用于在一个主文本串（Text）中查找一个模式串（Pattern）的出现位置。

相比于朴素的暴力匹配算法，KMP 的核心优势在于**避免了主串指针的回溯**，从而大大提高了效率。

---

### 1. 为什么需要 KMP？—— 暴力匹配的弊端

要理解 KMP 的巧妙之处，我们首先要看暴力匹配（Brute Force）有什么问题。

假设我们要在主串 `T = "ABABACABAB"` 中查找模式串 `P = "ABAC"`。

**暴力匹配过程：**
1.  `T` 的 `i=0` 和 `P` 的 `j=0` 开始比较。
    `A B A B A C A B A B`
    `A B A C`
    `i=0, j=0`: `A` == `A`，匹配
    `i=1, j=1`: `B` == `B`，匹配
    `i=2, j=2`: `A` == `A`，匹配
    `i=3, j=3`: `B` != `C`，**失配！**

2.  发生失配后，暴力匹配的做法是：
    *   将主串的指针 `i` 回溯到**本次匹配开始位置的下一个位置**，即 `i=1`。
    *   将模式串的指针 `j` 重置为 `0`。
    *   重新开始新一轮比较。

    `A B A B A C A B A B`
      `A B A C`
    `i=1, j=0`: `B` != `A`，失配。

3.  `i` 移动到 `2`，`j` 重置为 `0`，继续...

**问题所在**：在第一轮匹配中，我们已经知道了主串中 `T[0...2]` 是 `"ABA"`。当 `T[3]` 和 `P[3]` 失配时，我们其实**已经获得了足够的信息**，没有必要再傻傻地让 `i` 回到 `1`，然后用 `P[0]` (`'A'`) 去和 `T[1]` (`'B'`) 比较。我们知道它们肯定不匹配。KMP 算法就是利用了这些已经获得的信息。

---

### 2. KMP 的核心思想

KMP 算法的核心思想是：**当发生失配时，主串指针 `i` 永不回溯，而是利用一个预先计算好的 `next` 数组，来决定模式串指针 `j` 应该回退到哪个位置。**

换句话说，当 `T[i]` 和 `P[j]` 失配时，我们不想移动 `i`，只想把模式串 `P` 向右滑动到一个合适的位置，使得 `P` 的某个前缀能够和 `T` 中 `i` 指针之前已经匹配过的一段后缀对齐，然后从新的 `j` 位置继续和 `T[i]` 比较。

这个“合适的位置”就储存在 `next` 数组中。

---

### 3. 理解 `next` 数组 (或称“部分匹配表” PMT)

`next` 数组是 KMP 算法的精髓。`next[j]` 存储的是**模式串 `P` 的子串 `P[0...j]` 中，最长的相等的前缀和后缀的长度**。

- **前缀 (Prefix)**：指不包含最后一个字符的所有子串。例如，`"abaca"` 的前缀有 `"a"`, `"ab"`, `"aba"`, `"abac"`。
- **后缀 (Suffix)**：指不包含第一个字符的所有子串。例如，`"abaca"` 的后缀有 `"a"`, `"ca"`, `"aca"`, `"baca"`。

**`next[j]` 的定义**：`P[0...j]` 这个子串，其所有前缀和后缀中，最长的共有元素的长度。

**让我们用一个例子来构建 `next` 数组，模式串 P = "abacaba"**

| j | P[0...j] 子串 | 前缀 | 后缀 | 最长公共前后缀 | 长度 `next[j]` |
|---|---|---|---|---|---|
| 0 | `"a"` | (空) | (空) | (空) | 0 |
| 1 | `"ab"` | `a` | `b` | (空) | 0 |
| 2 | `"aba"` | `a`, `ab` | `a`, `ba` | `a` | 1 |
| 3 | `"abac"` | `a`,`ab`,`aba` | `c`,`ac`,`bac` | (空) | 0 |
| 4 | `"abaca"` | `a`,...,`abac` | `a`,...,`baca` | `a` | 1 |
| 5 | `"abacab"` | `a`,...,`abaca` | `b`,...,`acab` | `ab` | 2 |
| 6 | `"abacaba"`| `a`,...,`abacab`| `a`,...,`bacaba`| `aba` | 3 |

所以，对于 `P = "abacaba"`，我们得到的 `next` 数组是 `[0, 0, 1, 0, 1, 2, 3]`。

**`next` 数组的意义是什么？**

当 `T[i]` 与 `P[j]` 失配时，说明在 `T` 中，`T[i-j ... i-1]` 这部分子串与 `P[0 ... j-1]` 是匹配的。

`next[j-1]` 的值 `k` 告诉我们，`P[0 ... j-1]` 的前 `k` 个字符 (`P[0...k-1]`) 和后 `k` 个字符 (`P[j-k ... j-1]`) 是相同的。

由于 `T[i-j ... i-1] == P[0 ... j-1]`，那么也必然有 `T[i-k ... i-1] == P[j-k ... j-1]`。
结合 `P[0...k-1] == P[j-k ... j-1]`，我们可以推导出 `T[i-k ... i-1] == P[0...k-1]`。



这意味着，我们不需要移动主串的 `i` 指针，只需要将模式串的 `j` 指针移动到 `k`（也就是 `next[j-1]`）的位置，然后继续拿 `P[k]` 和 `T[i]` 进行比较即可。我们巧妙地复用了已经匹配过的信息。

---

### 4. 如何计算 `next` 数组

计算 `next` 数组的过程，本身就是一个“模式串自己匹配自己”的过程。我们使用两个指针 `j` 和 `i`。

- `j` 代表当前最长公共前后缀的长度，也指向下一个要比较的前缀字符位置。
- `i` 遍历整个模式串，用于构建 `next` 数组。

**算法步骤 (以 `P = "abacaba"` 为例):**
1.  初始化 `next` 数组全为 0，`j = 0`, `i = 1`。
2.  循环，当 `i` < `P.length()`:
    *   **如果 `P[i] == P[j]`**:
        *   这表示我们找到了更长一级的公共前后缀。
        *   `j` 增加 1。
        *   `next[i] = j`。
        *   `i` 增加 1。
    *   **如果 `P[i] != P[j]`**:
        *   这意味着当前 `j` 指向的前缀无法继续扩展。
        *   我们需要缩短这个前缀，寻找一个更短的、同样是 `P[0...j-1]` 的后缀的前缀。这个信息恰好就是 `next[j-1]`。
        *   所以，令 `j = next[j-1]`。
        *   这个过程一直持续，直到 `j` 变成 0 (表示没有更短的公共前缀了) 或者 `P[i] == P[j]`。
        *   如果 `j` 变成 0 仍然不匹配，说明 `P[0...i]` 没有任何公共前后缀，`next[i]` 保持为 0，`i` 增加 1。

**`P = "abacaba"` 的计算过程：**

| i | j | P[i] | P[j] | 操作 | next 数组 |
|---|---|---|---|---|---|
| 1 | 0 | 'b' | 'a' | P[1]!=P[0], j=0。`next[1]=0` | `[0,0,0,0,0,0,0]` |
| 2 | 0 | 'a' | 'a' | P[2]==P[0]。j++, `next[2]=1` | `[0,0,1,0,0,0,0]` |
| 3 | 1 | 'c' | 'b' | P[3]!=P[1]。j = next[1-1]=next[0]=0 | |
| | 0 | 'c' | 'a' | P[3]!=P[0], j=0。`next[3]=0` | `[0,0,1,0,0,0,0]` |
| 4 | 0 | 'a' | 'a' | P[4]==P[0]。j++, `next[4]=1` | `[0,0,1,0,1,0,0]` |
| 5 | 1 | 'b' | 'b' | P[5]==P[1]。j++, `next[5]=2` | `[0,0,1,0,1,2,0]` |
| 6 | 2 | 'a' | 'a' | P[6]==P[2]。j++, `next[6]=3` | `[0,0,1,0,1,2,3]` |

最终得到 `next = [0, 0, 1, 0, 1, 2, 3]`。

---

### 5. KMP 搜索过程

有了 `next` 数组后，搜索过程就变得非常清晰。

**算法步骤 (T: 主串, P: 模式串):**
1.  初始化主串指针 `i = 0`，模式串指针 `j = 0`。
2.  计算 `P` 的 `next` 数组。
3.  循环，当 `i` < `T.length()`:
    *   **如果 `T[i] == P[j]`**:
        *   匹配成功，两个指针都向前移动。
        *   `i++`, `j++`。
    *   **如果 `T[i] != P[j]` 并且 `j > 0`**:
        *   发生失配，但不是在模式串的开头。
        *   `i` 指针**不动**。
        *   根据 `next` 数组，将 `j` 移动到 `next[j-1]`。这实现了模式串的“智能”右移。
    *   **如果 `T[i] != P[j]` 并且 `j == 0`**:
        *   在模式串的第一个字符就失配了。
        *   `i` 指针向前移动一位，`j` 保持为 0，准备从主串的下一位开始新一轮匹配。
        *   `i++`。
    *   **检查是否匹配完成**:
        *   如果 `j == P.length()`，说明 `P` 已经完全匹配。
        *   找到了一个匹配，其起始位置是 `i - j`。
        *   **重要**：为了查找所有出现的匹配，我们不能停下。可以继续让 `j = next[j-1]`，然后继续循环，寻找下一个可能的匹配。

---

### 6. 伪代码实现

```python
def compute_next(pattern):
    """计算 next 数组"""
    next_arr = [0] * len(pattern)
    j = 0  # j: 当前最长公共前后缀的长度
    i = 1  # i: 遍历模式串的指针
    while i < len(pattern):
        if pattern[i] == pattern[j]:
            j += 1
            next_arr[i] = j
            i += 1
        else:
            if j > 0:
                j = next_arr[j - 1] # 回溯 j
            else:
                next_arr[i] = 0
                i += 1
    return next_arr

def kmp_search(text, pattern):
    """KMP 搜索算法"""
    n = len(text)
    m = len(pattern)
    if m == 0:
        return 0
    
    next_arr = compute_next(pattern)
    i = 0  # 主串指针
    j = 0  # 模式串指针
    
    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
        
        if j == m:
            # 找到一个匹配
            print(f"在索引 {i - j} 处找到一个匹配")
            # 继续寻找下一个匹配
            j = next_arr[j - 1]
        elif i < n and text[i] != pattern[j]:
            # 失配
            if j > 0:
                j = next_arr[j - 1] # i 不动，j 回溯
            else:
                i += 1 # j 已经是 0，无法回溯，只能移动 i

# 示例
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
kmp_search(text, pattern)
# 输出: 在索引 10 处找到一个匹配
```
*注意：`next` 数组的实现有多种细微差别（例如，是否整体右移一位并用-1填充首位），但核心思想——利用公共前后缀信息来避免回溯——是完全一致的。上面提供的版本是最常见和直观的实现之一。*

---

#KMP算法复杂度分析 

*   **时间复杂度**: **O(n + m)**
    *   计算 `next` 数组的时间复杂度是 O(m)，因为指针 `i` 只遍历模式串一次。
    *   搜索过程的时间复杂度是 O(n)，因为主串指针 `i` 从不回溯，最多前进 `n` 次。虽然 `j` 会回溯，但 `j` 的回溯次数之和不会超过 `i` 的前进次数，所以整体是线性的。
*   **空间复杂度**: **O(m)**
    *   主要开销是存储 `next` 数组。

KMP 算法以 O(m) 的额外空间为代价，将字符串匹配的时间复杂度从暴力匹配的 O(n*m) 优化到了 O(n+m)，这是一个巨大的提升，尤其是在处理长文本和长模式串时。