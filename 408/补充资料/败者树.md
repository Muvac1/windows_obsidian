1. #败者树 
*   **结构：** 也是一棵完全二叉树，但通常增加一个$tree[0]$来存放最终的胜者。
*   **原理：** 叶子节点两两比较，**败者（较大值）留在父节点**，胜者继续向上比较。
*   **关键点：** 父节点$tree[i]$保存的是其左右子树中“比赛”输掉的那个值（的索引）。
*   **调整：** 新元素从底部向上，只与父节点内容比较。
- **调整过程：** 当叶子节点值改变时，新的值作为一个“挑战者”自底向上升。在每一层，它直接与**父节点**中存储的“败者”进行比较。
	*   如果新值“赢”了（比父节点存的败者更优），新值继续向上，父节点保留原来的败者。
	*   如果新值“输”了（不如父节点存的败者），新值留在父节点变成新的败者，原父节点里的值作为胜者继续向上。
*   **优势（题目中的“避免迂回”）：** 调整时，我们只需要访问**父节点**的内容即可。父节点本身就在回溯的路径上。我们**不需要去访问兄弟节点**。这减少了内存地址的计算和访存跳转，因此在常数系数上，败者树比胜者树更快。