### 一、排序算法总体概览

在深入每个算法之前，先建立一个宏观的认识。

**1. 算法分类：**
*   **按执行地点分：**
    *   **内部排序 (Internal Sorting):** 数据量较小，可以一次性全部加载到内存中进行排序。这是考研的绝对重点。
    *   **外部排序 (External Sorting):** 数据量极大，无法全部加载到内存，需要借助外存（如硬盘）进行。主要涉及**多路归并排序**。
*   **按比较基础分：**
    *   **比较类排序 (Comparison Sorts):** 通过比较元素之间的大小关系来排序。其时间复杂度的理论下限是 **O(n log n)**。
    *   **非比较类排序 (Non-comparison Sorts):** 不通过比较，而是利用元素的自身特性（如数值大小、范围）来排序。可以突破 O(n log n) 的下限，达到线性时间 **O(n)**，但有适用范围限制。

**2. 关键性能指标（考点）：**
*   **时间复杂度 (Time Complexity):** 分为最好、最坏、平均三种情况。衡量算法的执行效率。
*   **空间复杂度 (Space Complexity):** 衡量算法执行过程中需要的额外存储空间。
*   **稳定性 (Stability):** 如果待排序序列中存在两个相等的元素，排序后它们的相对位置保持不变，则称该算法是**稳定**的；否则是**不稳定**的。

### 二、排序算法核心汇总表

这张表是备考的精髓，一定要记牢！

| 算法类别 | 算法名称 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **插入排序** | 直接插入排序 | O(n²) | O(n) | O(n²) | O(1) | **稳定** |
| | 希尔排序 | O(n^1.3) ~ O(n²) | O(n) | O(n²) | O(1) | **不稳定** |
| **交换排序** | 冒泡排序 | O(n²) | O(n) | O(n²) | O(1) | **稳定** |
| | 快速排序 | **O(n log n)** | O(n log n) | O(n²) | O(log n) ~ O(n) | **不稳定** |
| **选择排序** | 简单选择排序 | O(n²) | O(n²) | O(n²) | O(1) | **不稳定** |
| | 堆排序 | **O(n log n)** | O(n log n) | O(n log n) | O(1) | **不稳定** |
| **归并排序** | 二路归并排序 | **O(n log n)** | O(n log n) | O(n log n) | O(n) | **稳定** |
| **基数排序** | 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(n+r) | **稳定** |

*   **注:** O(d(n+r)) 中，d 是关键字的位数，r 是基数（如十进制是10），通常视为线性时间 **O(n)**。
*   **记忆技巧**：不稳定的算法可以记为“**快希选堆**”（快排、希尔、选择、堆）。

---

### 三、各类排序算法详解

#### 1. 插入排序 (Insertion Sort)

**核心思想**：将待排序序列看作一个有序区和一个无序区。每次从无序区取出一个元素，插入到有序区的合适位置，直到无序区为空。

*   **直接插入排序 (Direct Insertion Sort)**
    *   **步骤**：从第二个元素开始，将其视为待插入元素。将它与前面的有序序列从后向前比较，如果前面的元素更大，则将其后移，直到找到插入位置。
    *   **性能**：
        *   **最好情况**：序列基本有序，只需 O(n) 次比较。
        *   **最坏情况**：序列逆序，需要 O(n²) 次比较和移动。
    *   **考研要点**：**非常适合对基本有序的序列进行排序**，效率很高。稳定。
![](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)
*   **希尔排序 (Shell Sort)**
    *   **思想**：也叫“递减增量排序”，是插入排序的改进版。它将序列按某个增量 `gap` 分成若干个子序列，对每个子序列进行直接插入排序。然后不断缩小增量 `gap`，重复此过程，直到 `gap=1`（此时就是一次完整的直接插入排序）。
    *   **关键**：通过先处理较远距离的元素，使得序列快速变得“基本有序”，从而让最后一次 `gap=1` 的插入排序效率极高。
    *   **性能**：时间复杂度与增量序列的选择有关，平均为 O(n^1.3)。不稳定（因为相同元素可能被分到不同子序列，交换后相对位置改变）。
![](https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif)
#### 2. 交换排序 (Exchange Sort)

**核心思想**：通过两两比较和交换来达到排序的目的。

*   **冒泡排序 (Bubble Sort)**
    *   **步骤**：重复地遍历待排序序列，每次比较相邻的两个元素，如果顺序错误就交换它们。一趟遍历下来，最大（或最小）的元素会“冒”到序列的末尾。
    *   **性能**：平均和最坏都是 O(n²)。最好情况（序列已有序）可通过加一个标志位优化到 O(n)。稳定。
    *   **考研要点**：思想简单，但效率低。考选择题的概率较大，用来和其他算法对比。
![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)
*   **快速排序 (Quick Sort)**[[快速排序]] 
    *   **思想**：**分治法**的典型应用。
    *   **步骤**：
        1.  **分区 (Partition)**：在序列中选择一个元素作为**基准 (Pivot)**。
        2.  将所有小于基准的元素移动到基准左边，大于基准的移动到右边。此时基准已在最终位置。
        3.  **递归**：对基准左右两个子序列，重复上述过程。
    *   **性能**：
        *   **平均/最好情况**：O(n log n)。当每次划分都比较均匀时。
        *   **最坏情况**：O(n²)。当序列已经有序或逆序，每次划分都极不均匀（一个子序列为空，另一个为 n-1）。
        *   **空间复杂度**：递归需要栈空间，深度与递归树高度有关。最好 O(log n)，最坏 O(n)。
    *   **考研要点**：**是内部排序中平均性能最好的算法**。不稳定。**分区操作是考察的绝对核心**，最坏情况的成因和如何优化（如随机选择基准、三数取中法）是高频考点。你提问的图片内容就是关于快排递归次数的分析。
![](https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif)
#### 3. 选择排序 (Selection Sort)

**核心思想**：同样分为有序区和无序区。每趟从无序区中选出最小（或最大）的元素，放到有序区的末尾。

*   **简单选择排序 (Simple Selection Sort)**
    *   **步骤**：第一趟，从 n 个元素中找出最小的，与第一个元素交换。第二趟，从剩下的 n-1 个元素中找出最小的，与第二个元素交换。以此类推。
    *   **性能**：时间复杂度恒为 O(n²)，与初始序列无关。**元素移动次数非常少**（最多 n-1 次交换）。不稳定（例如 `[5, 8, 5, 2]`，第一趟会用第一个 `5` 和 `2` 交换，两个 `5` 的相对位置就变了）。
    *   **考研要点**：移动次数少是其特点。
![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)
*   **堆排序 (Heap Sort)**
    *   **思想**：利用**堆**这种数据结构进行排序。堆是一个完全二叉树，且满足：父节点的值总是大于（或小于）其子节点的值（大顶堆或小顶堆）。
    *   **步骤**：
        1.  **建堆**：将无序序列构建成一个大顶堆（或小顶堆）。
        2.  **排序**：将堆顶元素（最大值）与堆底最后一个元素交换。然后将剩余的 n-1 个元素重新调整成堆，重复此过程。
    *   **性能**：时间复杂度稳定在 O(n log n)。空间复杂度为 O(1)（原地排序）。不稳定。
    *   **考研要点**：**建堆的过程**和**调整堆的过程**是核心考点，常考大题。适合解决**Top K**问题（求最大或最小的 K 个数）。
![](https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif)
![](https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif)
#### 4. 归并排序 (Merge Sort)

*   **思想**：也是**分治法**的应用。
*   **步骤**：
    1.  **分解 (Divide)**：将序列递归地对半拆分，直到每个子序列只剩一个元素（天然有序）。
    2.  **合并 (Merge)**：将相邻的两个有序子序列合并成一个更大的有序序列，直到所有子序列合并成一个。
*   **性能**：时间复杂度稳定在 O(n log n)。但需要 O(n) 的额外空间来辅助合并操作。**稳定**。
*   **考研要点**：**稳定的 O(n log n) 算法**。其合并操作是**外部排序的基础**。合并两个有序序列的算法必须熟练掌握。
![](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)
#### 5. 基数排序 (Radix Sort) 

*   **思想**：非比较排序。将所有待排序的整数，统一成相同的位数（不足的在前面补0）。然后从最低位（个位）开始，依次对每一位进行排序，直到最高位。
*   **关键**：对每一位进行排序时，必须使用**稳定**的排序算法（通常用“桶”或“队列”来实现，称为**分配和收集**）。
*   **性能**：时间复杂度为 O(d(n+r))，空间为 O(n+r)。稳定。
*   **考研要点**：适用于整数排序，特别是位数不多但数值范围很大的情况。理解其“分配-收集”的过程和依赖于稳定排序的原理。
![](https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif)
---

### 四、如何选择排序算法（高阶应用）

1.  **若 n 较小 (n ≤ 50)**：可采用直接插入排序或简单选择排序，代码简单。
2.  **若序列基本有序**：直接插入排序或冒泡排序是最佳选择，效率可达 O(n)。
3.  **若 n 较大，追求平均速度**：快速排序是首选。
4.  **若需要稳定的 O(n log n) 排序**：归并排序是唯一选择。
5.  **若追求最坏情况下的性能，且要求空间复杂度低**：堆排序，它避免了快速排序的 O(n²) 最坏情况，且是原地排序。
6.  **若待排序元素是整数且范围不大**：可使用基数排序等线性时间排序。