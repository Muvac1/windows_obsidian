![[Pasted image 20251216205243.png]]
![[Pasted image 20251216205250.png]]

### 知识点一：用户级线程 (ULT) 和内核级线程 (KLT) 的特点

**【习题 1：选择题】**
关于用户级线程（User-Level Threads, ULT）和内核级线程（Kernel-Level Threads, KLT），下列说法**正确**的是：

A. 在用户级线程模型中，如果一个线程执行系统调用被阻塞，该进程内的其他线程仍可继续执行。
B. 用户级线程的调度由操作系统内核完成，因此上下文切换开销较大。
C. 内核级线程可以利用多核处理器的优势，实现真正的并行执行。
D. 用户级线程的创建、撤销和切换都需要内核的干预。

**【答案与解析】**
*   **答案：C**
*   **解析：**
    *   **A 错误**：ULT 的缺点之一就是“一旦阻塞，全家阻塞”。因为内核看不到 ULT，只把它们当做一个进程。如果一个 ULT 阻塞（如 I/O），内核会阻塞整个进程。
    *   **B 错误**：ULT 的调度由用户空间的线程库完成，无需内核干预，也不需要切换到内核态，因此开销**小**。
    *   **C 正确**：KLT 由内核管理，内核可以将同一进程的不同线程调度到不同的 CPU 核心上，实现并行。
    *   **D 错误**：ULT 的管理完全在用户空间进行，不需要内核干预。

---

### 知识点二：fork, wait, COW, vfork 及输出顺序

**【习题 2：代码分析题】**
阅读下面的代码片段，回答问题：

```c
int main() {
    int pid = fork();
    if (pid == 0) {
        printf("A");
    } else {
        printf("B");
        wait(NULL);
        printf("C");
    }
    return 0;
}
```
**问题：**
1. 上述代码可能的输出结果有哪些？
2. 如果删去 `wait(NULL);` 这一行，可能的输出结果有哪些？
3. `vfork` 与带有 COW (Copy-On-Write) 机制的 `fork` 主要区别是什么？

**【答案与解析】**

**1. 有 `wait` 的情况：**
*   **答案：** 只能是 **"BAC"** 或 **"ABC"** (注：标准答案通常倾向于认为 wait 会挂起父进程，所以 A 会在 C 之前，但 B 和 A 的顺序取决于调度)。
    *   *修正解释*：`wait()` 保证了父进程必须等子进程结束后才能继续执行 `wait` 后面的代码。所以子进程的输出 "A" 一定在父进程的 "C" 之前。
    *   但是，父进程 `fork` 后，是先执行 `printf("B")` 还是子进程先执行 `printf("A")` 是不确定的。
    *   **可能结果：** `BAC` (父先运行B -> 调wait阻塞 -> 子运行A -> 子退出 -> 父wait返回 -> 父运行C) 或者 `ABC` (子先运行A -> 子退出 -> 父运行B -> 父调wait立即返回 -> 父运行C)。

**2. 删去 `wait` 的情况：**
*   **答案：** 失去了同步约束，A、B、C 的相对顺序变得更加不确定，但 B 和 C 的顺序是固定的（C 在 B 后）。
*   **可能结果：** `BCA`（父跑完子才跑）、`ABC`（子跑完父才跑）、`BAC`（父打B，切换子打A，切回父打C）。

**3. vfork 与 COW fork 的区别：**
*   **地址空间：** COW 的 `fork` 会复制父进程的页表，子进程**逻辑上**拥有独立的地址空间（写时才复制物理页）；而 `vfork` 子进程**共享**父进程的地址空间，子进程对数据的修改会影响父进程。
*   **阻塞机制：** `fork` 后父子进程并发执行；`vfork` 强制**父进程阻塞**，直到子进程调用 `exec` 或 `exit` 后，父进程才恢复运行。

---

### 知识点三：具体的 PV 操作 (信号量)

**【习题 3：编程/伪代码题】**
**题目：水果盘问题**
桌子上有一个盘子，每次只能放一个水果。
*   **爸爸**专门向盘子中放**苹果**。
*   **妈妈**专门向盘子中放**橘子**。
*   **儿子**专门等待吃盘子里的**橘子**。
*   **女儿**专门等待吃盘子里的**苹果**。
请用 PV 操作（信号量）实现四人的同步与互斥。

**【答案与解析】**

**分析：**
1.  **互斥关系**：盘子是共享资源，大小为1。
2.  **同步关系**：
    *   盘子空了 -> 爸爸/妈妈才能放。
    *   有苹果 -> 女儿才能吃。
    *   有橘子 -> 儿子才能吃。

**信号量定义：**
*   `mutex = 1`：互斥访问盘子（其实在本题容量为1且有特定同步信号量时，mutex可省略，但写上更严谨）。
*   `empty = 1`：盘子是否为空（初始为1）。
*   `apple = 0`：盘子是否有苹果（初始为0）。
*   `orange = 0`：盘子是否有橘子（初始为0）。

**代码实现：**

```c
semaphore empty = 1;
semaphore apple = 0;
semaphore orange = 0;
// mutex 在此场景下可省略，因为 empty=1 已经限制了互斥，但为了规范可加上

// 爸爸进程
void Father() {
    while(1) {
        prepare_apple();
        P(empty);   // 检查盘子是否空
        // P(mutex);
        put_apple();
        // V(mutex);
        V(apple);   // 告诉女儿有苹果了
    }
}

// 妈妈进程
void Mother() {
    while(1) {
        prepare_orange();
        P(empty);   // 检查盘子是否空
        put_orange();
        V(orange);  // 告诉儿子有橘子了
    }
}

// 女儿进程
void Daughter() {
    while(1) {
        P(apple);   // 检查是否有苹果
        // P(mutex);
        take_apple();
        // V(mutex);
        V(empty);   // 吃完了，盘子变空，通知爸妈可以放了
        eat_apple();
    }
}

// 儿子进程
void Son() {
    while(1) {
        P(orange);  // 检查是否有橘子
        take_orange();
        V(empty);   // 吃完了，盘子变空
        eat_orange();
    }
}
```

---

### 知识点四：进程调度算法及计算

**【习题 4：计算题】**
设有 3 个进程 A、B、C，它们的到达时间和服务时间（执行时间）如下表所示：

| 进程 | 到达时间 | 服务时间 |
| :--- | :---: | :---: |
| A | 0 | 8 |
| B | 1 | 4 |
| C | 2 | 1 |

请分别计算在 **FCFS (先来先服务)** 和 **SJF (短作业优先，非抢占式)** 调度算法下的：
1. 各进程的完成时间。
2. 平均周转时间。
   *(注：周转时间 = 完成时间 - 到达时间)*

**【答案与解析】**

#### 1. FCFS (先来先服务)
按照到达顺序执行：A -> B -> C

*   **进程 A:**
    *   到达：0，运行：8
    *   完成时间：0 + 8 = 8
    *   周转时间：8 - 0 = **8**
*   **进程 B:**
    *   到达：1，等待 A 完成 (此时时刻8)
    *   完成时间：8 + 4 = 12
    *   周转时间：12 - 1 = **11**
*   **进程 C:**
    *   到达：2，等待 B 完成 (此时时刻12)
    *   完成时间：12 + 1 = 13
    *   周转时间：13 - 2 = **11**

*   **平均周转时间** = (8 + 11 + 11) / 3 = **10**

#### 2. SJF (短作业优先 - 非抢占)
*注意：是非抢占，意味着一旦占用 CPU 就要运行完。*

*   **时刻 0：** 只有 A 到达。A 开始运行 (需要8个时间单位)。
*   **时刻 8：** A 运行结束。此时 B (到达时间1) 和 C (到达时间2) 都已经在等待队列中。
    *   比较服务时间：B 需要 4，C 需要 1。
    *   SJF 策略：选择 **C** 先运行。
*   **进程 C 运行：**
    *   开始：8，运行：1
    *   完成时间：8 + 1 = 9
    *   周转时间：9 - 2 = **7**
*   **进程 B 运行：**
    *   开始：9，运行：4
    *   完成时间：9 + 4 = 13
    *   周转时间：13 - 1 = **12**
*   **进程 A:**
    *   完成时间：8
    *   周转时间：8 - 0 = **8**

*   **平均周转时间** = (8 + 12 + 7) / 3 = 27 / 3 = **9**

**总结对比：** SJF 的平均周转时间 (9) 优于 FCFS (10)。


### 知识点五：死锁预防、避免、检测与解除

**重点：** 区分“预防”和“避免”的概念（银行家算法），以及死锁产生的四个必要条件。

#### 习题

**1. [单选题] 下列关于死锁的说法中，错误的是（ ）**
A. 死锁预防是通过破坏死锁产生的四个必要条件之一来实现的
B. 银行家算法（Banker's Algorithm）是一种死锁检测算法
C. 死锁解除的方法包括剥夺资源和撤销进程
D. 资源分配图（Resource Allocation Graph）可以用来进行死锁检测

**2. [简答题] 请简述“死锁预防”与“死锁避免”的主要区别。**

**3. [分析题] 若系统采用资源有序分配策略（即规定所有进程申请资源必须按照序号递增的顺序进行），请问这属于死锁处理中的哪一种策略？它破坏了死锁的哪一个必要条件？**

---

#### 答案与解析

**1. 答案：B**
*   **解析：** 银行家算法是典型的**死锁避免**（Deadlock Avoidance）算法，而不是检测算法。它在资源分配前预判系统是否会进入不安全状态。
    *   *死锁预防*：静态策略，通过设置限制条件破坏四个必要条件。
    *   *死锁检测*：允许死锁发生，但定期检查（如使用资源分配图化简）。

**2. 答案：**
*   **死锁预防（Prevention）：** 是一种较严格的策略。在进程运行前，通过设置严格的限制条件（如一次性申请所有资源、资源有序分配等），**破坏**死锁产生的四个必要条件（互斥、请求与保持、不剥夺、循环等待）中的至少一个，从根本上杜绝死锁发生的可能性。
*   **死锁避免（Avoidance）：** 不预先破坏必要条件，而是在资源动态分配的过程中，利用算法（如银行家算法）预测分配后系统是否安全。如果分配会导致系统进入不安全状态（可能发生死锁），则不予分配。它允许进程动态申请资源，但需要更复杂的计算。

**3. 答案：**
*   属于**死锁预防**。
*   它破坏了**循环等待（Circular Wait）**条件。因为资源只能按序号递增申请，不可能出现 A 等待 B，B 等待 A 的环路情况。

---

### 知识点六：管道（Pipe）的特点及有名/无名管道的区别

**重点：** 匿名管道的“亲缘关系”限制与有名管道的“文件系统”特性。

#### 习题

**1. [单选题] 关于无名管道（Anonymous Pipe）和有名管道（Named Pipe/FIFO），下列说法正确的是（ ）**
A. 无名管道可以用于任意两个进程间的通信
B. 有名管道在文件系统中不可见，不占用磁盘索引节点
C. 无名管道是一种半双工的通信方式
D. 有名管道的数据只能像无名管道一样存储在内存中，进程结束后数据永久保留

**2. [填空题] Linux 中使用 `|` 符号连接两个命令（如 `ls | grep txt`），使用的是______管道；而使用 `mkfifo` 命令创建的是______管道。**

**3. [简答题] 请列出无名管道和有名管道在“通信范围”和“生命周期”上的主要区别。**

---

#### 答案与解析

**1. 答案：C**
*   **解析：**
    *   A 错：无名管道只能用于具有**亲缘关系**（父子、兄弟）的进程间通信。
    *   B 错：有名管道在文件系统中**存在文件名**（即占用 inode），虽然数据主要在内存缓冲，但它以文件形式存在于目录树中。
    *   C 对：管道本质上通常是半双工的（数据单向流动）。
    *   D 错：有名管道内的数据在内存中，但进程结束后管道文件本身（名字）还在，数据随进程读写消失；且有名管道不是永久存储数据的介质。

**2. 答案：** 无名（或 匿名）；有名（或 命名/FIFO）

**3. 答案：**
*   **通信范围：**
    *   *无名管道*：只能在具有亲缘关系的进程（如父子进程）之间使用。
    *   *有名管道*：可以在任何两个进程之间使用，只要它们能访问该路径下的管道文件（无关亲缘）。
*   **生命周期：**
    *   *无名管道*：随进程的创建而建立，随进程的结束而销毁。
    *   *有名管道*：作为特殊文件存在于文件系统中，除非显式删除（使用 `rm` 或 `unlink`），否则一直存在（但管道内的数据是临时的）。

---

### 知识点七：实时调度算法

**重点：** EDF（最早截止时间优先）和 RMS（速率单调调度）的基本原理。

#### 习题

**1. [单选题] 在实时系统中，EDF（Earliest Deadline First）算法根据什么来确定进程的优先级？（ ）**
A. 进程执行时间的长短
B. 进程到达的先后顺序
C. 进程截止时间的缓急
D. 进程周期的长短

**2. [简答题] 简述实时调度算法中“硬实时”和“软实时”的区别。**

**3. [判断题] RMS（Rate Monotonic Scheduling，速率单调调度）是一种动态优先级算法，周期越短的进程优先级越高。（ ）**

---

#### 答案与解析

**1. 答案：C**
*   **解析：** EDF 算法的核心就是：截止时间（Deadline）越早的这个任务，优先级越高。

**2. 答案：**
*   **硬实时（Hard Real-time）：** 系统必须严格在规定的时间内完成任务。如果错过截止时间，会造成严重的后果（如系统崩溃、灾难性故障）。例如：导弹制导系统、汽车安全气囊控制。
*   **软实时（Soft Real-time）：** 系统应尽量在规定时间内完成任务，但偶尔错过截止时间是可以被接受的，只会导致服务质量下降，不会造成严重后果。例如：视频流播放、网页加载。

**3. 答案：错误（False）**
*   **解析：** RMS 是一种**静态**优先级算法。虽然它确实规定“周期越短优先级越高”，但一旦分配好优先级，在运行过程中是不会改变的，所以它是静态的。EDF 才是动态优先级算法。

---

### 知识点八：协程的概念、特点及与线程的区别

**重点：** 用户态调度、开销小、协作式（非抢占）。

#### 习题

**1. [单选题] 关于协程（Coroutine），下列说法错误的是（ ）**
A. 协程的切换由操作系统内核（Kernel）负责调度
B. 协程又被称为“用户级线程”，拥有极低的切换开销
C. 一个线程内部可以包含多个协程
D. 协程通常采用协作式（Cooperative）调度而非抢占式调度

**2. [对比题] 请从“调度者”、“切换开销”和“并发性”三个方面，对比线程（Thread）和协程（Coroutine）。**

---

#### 答案与解析

**1. 答案：A**
*   **解析：**
    *   A 错：协程的本质是**用户态**的轻量级线程，其调度完全由**用户程序（或运行库/程序员）**控制，操作系统内核完全感知不到协程的存在。
    *   B、C、D 均为协程的正确特征。

**2. 答案：**

| 特性 | 线程 (Thread) | 协程 (Coroutine) |
| :--- | :--- | :--- |
| **调度者** | **操作系统内核** (Kernel) | **用户程序** (User Space) |
| **切换开销** | **较高** (涉及用户态/内核态切换、寄存器和上下文保存较多) | **极低** (仅在用户态保存少量寄存器状态，类似函数调用) |
| **调度方式** | 通常是**抢占式** (Preemptive)，由OS决定何时暂停 | 通常是**协作式** (Cooperative)，由协程自己主动让出 CPU (`yield`) |
| **并发性** | 多线程可利用多核 CPU 实现真正的并行 | 单线程内的多协程本质是并发（分时），无法利用多核（除非协程绑定多线程） |

希望这些习题能帮助你高效复习这四个知识模块！如果有哪部分需要更深入的解释，请告诉我。