![[Pasted image 20251215190730.png]]

### 知识点一：三种开散列（多槽位、独立链、公共溢出区）的特点

这里提到的“开散列”在不同的教材中定义略有不同，但结合括号内的内容，指的是处理哈希冲突的几种特定机制。

#### 1. 多槽位 (Multi-slot / Buckets)
**题目：** 在哈希表中，采用“多槽位”方法的主要目的是什么？当槽位填满时通常如何处理？
**解答：**
*   **目的：** 多槽位（也称桶哈希）将哈希表的每一个地址（Bucket）设计为可以存储多个记录（Slot）。这减少了冲突时的探测次数，因为只有当一个桶内的所有槽位都满了，才算真正发生溢出。
*   **处理：** 当一个桶内的槽位全部填满后，通常需要结合**溢出链**或**公共溢出区**来存储多余的元素。

#### 2. 独立链 (Separate Chaining / 拉链法)
**题目：** 对比“独立链”法与“开放定址法”（如线性探测），独立链法的主要优势是什么？
**解答：**
*   **删除操作简单：** 在独立链中删除元素只需调整链表指针，无需像开放定址法那样使用“懒惰删除”或移动元素。
*   **对装填因子（Load Factor, $\alpha$）不敏感：** 独立链法允许 $\alpha > 1$，即元素数量可以超过哈希表长度，且性能下降较为平缓；而开放定址法当 $\alpha$ 接近 1 时性能会急剧下降。

#### 3. 公共溢出区 (Common Overflow Area)
**题目：** 什么是公共溢出区法？它在什么情况下效率最高，什么情况下效率最低？
**解答：**
*   **定义：** 将哈希表分为基本表和溢出表。凡是发生冲突的元素，一律填入溢出表中。
*   **效率最高：** 当冲突非常少时，查找基本表即可命中，效率很高。
*   **效率最低：** 当冲突非常多，或者装填因子过高时，大量元素堆积在溢出区。如果溢出区是线性查找，时间复杂度会退化为 $O(N)$。

---

### 知识点二：重散列 (Rehashing) 与双散列 (Double Hashing) 的区别

这是一个非常容易混淆的考点，一定要分清“扩容”和“探测”的区别。

**题目：** 请简述“重散列（Rehashing）”与“双散列（Double Hashing）”在定义和目的上的核心区别。

**解答：**
1.  **双散列 (Double Hashing)：**
    *   **类别：** 是一种**解决冲突的策略**（属于开放定址法的一种）。
    *   **机制：** 当发生冲突时，使用第二个哈希函数计算步长。公式为 $H_i(k) = (H_1(k) + i \times H_2(k)) \% m$。
    *   **目的：** 避免“二次聚集”现象，使探测序列更随机，分布更均匀。
2.  **重散列 (Rehashing)：**
    *   **类别：** 是一种**维护哈希表性能的策略**（通常指扩容）。
    *   **机制：** 当哈希表的装填因子 $\alpha$ 超过某个阈值（如 0.75）时，建立一个大小约为原来两倍的新表（通常是新的素数），将旧表中的所有元素重新计算哈希值并插入新表。
    *   **目的：** 降低装填因子，恢复哈希表的操作效率（$O(1)$）。
3.  **核心区别：** 双散列是在**同一张表**里找下一个空位；重散列是建立**一张新表**并迁移数据。

---

### 知识点三：懒惰删除 (Lazy Deletion)

这是开放定址法中必考的细节，对应图中提到的“习题解析 9-16”。

**题目：** 在开放定址法（Open Addressing）的哈希表中，为什么删除元素时不能直接将该位置空？什么是懒惰删除？

**解答：**
*   **原因（断链问题）：** 在开放定址法中，查找元素依赖于探测序列。如果直接物理删除一个元素并将该位置设为“空（Empty）”，那么查找其探测序列后方的元素时，遇到这个“空”位就会误以为查找失败（停止搜索），导致该元素之后的冲突元素“丢失”。
*   **懒惰删除（Lazy Deletion）：** 不真正删除数据，而是放置一个特殊的**“已删除（Deleted）”标记**（墓碑机制）。
    *   **查找时：** 遇到“已删除”标记继续向后探测，不停止。
    *   **插入时：** 遇到“已删除”标记可以覆盖该位置，将其视为可用空间。

**进阶思考：** 如果懒惰删除的标记过多会有什么后果？
*   **回答：** 会导致查找效率下降（因为查找必须跨过这些标记，就像它们是占位符一样）。因此，当“已删除”标记过多时，通常需要触发**重散列（Rehashing）**来清理墓碑，重组数据。

---

### 知识点四：跳转表 (Skip List) 的查找问题

对应图中“PPT 里的结论”。

**题目 1：** 跳表（Skip List）的理想层数与元素个数 $N$ 的关系是什么？它的平均查找时间复杂度是多少？

**解答：**
*   **层数：** 理想层数约为 $\log_{p} N$（通常 $p=2$，即 $\log_2 N$）。
*   **时间复杂度：** 查找、插入、删除的平均时间复杂度均为 **$O(\log N)$**。这使得它可以作为平衡二叉树（AVL、红黑树）的替代方案。

**题目 2 (场景模拟)：** 在跳表中查找一个特定的值，查找路径是怎样的？
**解答：**
*   查找从**最高层**的头节点开始。
*   **向右移动：** 如果右边的节点值小于或等于目标值，则向右移动。
*   **向下移动：** 如果右边的节点值大于目标值，或者右边没有节点（到达末尾），则向下移动一层。
*   重复上述过程，直到在最底层找到目标值，或确认目标值不存在。

**总结结论 (PPT 常见考点)：**
1.  空间换时间：跳表通过维护额外的索引层（空间复杂度 $O(N)$）来加速查找。
2.  概率性结构：层高的生成是随机的（抛硬币决定），不保证绝对平衡，但概率上保证平衡。

---

### 建议复习策略
1.  **针对“重散列”：** 确认一下你们的教材定义。大多数现代教材指“扩容”，但极少数老教材可能将其指代为“再次哈希解决冲突”。以上述回答中的“扩容”为准，因为这是与“双散列”区分最明显的点。
2.  **针对“懒惰删除”：** 能够画图模拟“插入 -> 冲突 -> 探测 -> 插入 -> 删除中间项 -> 查找末尾项”的流程。
3.  **针对“跳表”：** 记住它和二分查找的关系（多层链表实现的二分查找思想）。