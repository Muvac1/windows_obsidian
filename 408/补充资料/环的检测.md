检测图中的环（Cycle Detection）是图论算法中的核心问题。根据图的类型（**有向图** vs **无向图**），检测的方法完全不同。你的笔记主要针对的是**有向图（DAG判定）**，但全面掌握需要了解以下分类。

总结来说，检测环主要有 **三大类** 方法：

1.  **DFS（深度优先搜索） - 三色标记法** （最常用，支持有向/无向）
2.  **拓扑排序 - Kahn算法（BFS思路）** （仅限有向图）
3.  **并查集（Union-Find）** （主要用于无向图）

---

### 一、 有向图（Directed Graph）的判环
这是你笔记中关注的重点，主要用于判断一个图是否为 **DAG（有向无环图）**。

#### 方法 1：DFS + 三色标记法（递归栈检测）
这是最经典、最直观的方法。

*   **核心思想**：
    在 DFS 深度优先遍历时，我们将每个节点的状态分为三种颜色：
    1.  **白色（0, Unvisited）**：尚未被访问。
    2.  **灰色（1, Visiting / Recursion Stack）**：正在访问中，即该节点已被访问，但其所有邻接节点（子节点）尚未遍历完，当前节点还在递归调用栈中。
    3.  **黑色（2, Visited）**：已访问完成，该节点及其子孙节点都已遍历结束，且退出了递归栈。

*   **判环逻辑**：
    *   当我们从节点 `u` 遍历到邻居 `v` 时：
        *   如果 `v` 是 **白色**：继续递归访问 `v`。
        *   如果 `v` 是 **灰色**：**发现环！** 说明 `v` 是 `u` 的祖先，且 `v` 到 `u` 有路径，现在 `u` 又指向 `v`，构成了闭环（这叫 **后向边 / Back Edge**）。
        *   如果 `v` 是 **黑色**：说明 `v` 所在的路径已经探索过且无环，跳过（交叉边或前向边，不会构成环）。

*   **代码逻辑（伪代码）：**
    ```python
    def has_cycle(u):
        state[u] = GRAY  # 标记为正在访问
        for v in adj[u]:
            if state[v] == GRAY:
                return True  # 找到环
            if state[v] == WHITE:
                if has_cycle(v):
                    return True
        state[u] = BLACK # 标记为访问结束
        return False
    ```
*   **复杂度**：时间 $O(V+E)$，空间 $O(V)$。

#### 方法 2：拓扑排序（Kahn 算法 / BFS）
这是利用“入度”来判断的方法。

*   **核心思想**：
    DAG 的一个重要性质是：**一定存在至少一个入度为 0 的点**。
    如果一个图有环，环上的所有节点入度都至少为 1，永远无法消除。

*   **步骤**：
    1.  计算所有节点的**入度（Indegree）**。
    2.  将所有 **入度为 0** 的节点放入队列（Queue）。
    3.  当队列不空时：
        *   弹出节点 `u`。
        *   计数器 `count++`（记录拓扑排序取出的点数）。
        *   遍历 `u` 的所有邻居 `v`，将 `v` 的入度减 1。
        *   如果 `v` 的入度变为 0，将 `v` 入队。
    4.  **判定**：如果最终 `count < 总节点数 |V|`，说明图中有剩余的节点无法入队（它们的入度始终不为0），即**存在环**。

*   **特点**：这个方法不仅能判环，还能直接给出拓扑排序序列。
*   **复杂度**：时间 $O(V+E)$，空间 $O(V)$。

---

### 二、 无向图（Undirected Graph）的判环
无向图没有“方向”，所以 $A-B$ 和 $B-A$ 是同一条边。无向图判环的逻辑稍有不同。

#### 方法 1：并查集（Union-Find / DSU） —— **最推荐用于无向图**
这是解决无向图连通性和判环最优雅的方法。

*   **核心思想**：
    一开始所有点都是独立的集合。遍历图中的每一条边 $(u, v)$：
    1.  查找 `u` 和 `v` 的根节点（`find(u)`, `find(v)`）。
    2.  如果 **根节点相同**：说明 `u` 和 `v` 之前已经通过其他路径连通了，现在又多了一条边直接连接它们，因此**存在环**。
    3.  如果 **根节点不同**：合并这两个集合（`union(u, v)`）。

*   **复杂度**：时间 $O(E \cdot \alpha(V))$，其中 $\alpha$ 是反阿克曼函数，极其接近常数，效率极高。

#### 方法 2：DFS（无向图版）
无向图的 DFS 判环比有向图简单，不需要三色标记，只需要两色（访问过/未访问）。

*   **核心逻辑**：
    在 DFS 过程中，我们需要传入一个 `parent` 参数记录上一个节点。
    *   遍历 `u` 的邻居 `v`。
    *   如果 `v` **已被访问** 且 `v != parent`：说明找到了一条通往“老祖宗”的路，**存在环**。
    *   （注：如果 `v == parent`，那是刚刚走过来的路，不是环）。

#### 方法 3：BFS（无向图版）
逻辑同 DFS，利用 `visited` 数组和父节点记录。如果 BFS 过程中遇到一个已经访问过的节点，且该节点不是当前节点的父节点，则存在环。

---

### 三、 总结与对比

| 场景      | 方法              | 关键点 / 判定公式             | 适用性                        |
| :------ | :-------------- | :--------------------- | :------------------------- |
| **有向图** | **DFS (三色法)**   | 遇到**灰色**节点 (Back Edge) | **判定 DAG 的标准解法**，可用于找具体环路径 |
| **有向图** | **拓扑排序 (Kahn)** | 最终输出节点数 < 总节点数         | 适合需要求拓扑序的场景                |
| **无向图** | **并查集 (DSU)**   | `find(u) == find(v)`   | **无向图最快解法**，适合动态加边检测       |
| **无向图** | **DFS**         | 遇到已访问节点且非父节点           | 适合遍历图时顺便检测                 |

### 针对你的考试/面试建议：
1.  **题目提到“依赖关系”、“课程表”、“编译顺序”**：
    *   这是典型的有向图。
    *   首选 **拓扑排序（Kahn）**，因为通常不仅要判环，还要输出顺序。
    *   如果只需判断是否可行（True/False），**DFS 三色法** 写起来也很简洁。

2.  **题目提到“冗余连接”、“网络连通性”**：
    *   这是无向图。
    *   首选 **并查集**。

**只要记住你笔记里的那句核心：**
> 在 DFS 过程中，如果遇到一条边指向“正在访问中”（灰色/在递归栈中）的节点，说明存在**后向边**，即存在环。