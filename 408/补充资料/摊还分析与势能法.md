伸展树的单次操作在最坏情况下可能是$O(n)$（例如，当树退化成一条链时），但我们通常使用 #摊还分析 来证明其长期性能是高效的。 #势能法 是摊还分析的一种常用技术。  [[为什么需要势能？]]  

其核心思想是为数据结构定义一个**势能函数** $\Phi$，它将数据结构的某个状态映射为一个非负数。一次操作的**摊还代价** (Amortized Cost) 定义为：

$摊还代价 = 实际代价 + \Delta\Phi$

其中，$\Delta\Phi$ 是操作前后的势能变化量 ($\Phi_{after} - \Phi_{before}$)。

对于 #伸展树 ，我们定义势能函数如下：
1.  对于树中的任意节点 $x$，定义其**大小** $s(x)$ 为以 $x$ 为根的子树中的节点数量（包括 $x$ 本身）。
2.  定义节点 $x$ 的**秩** (rank) 为 $r(x) = \log_2(s(x))$。
3.  整棵树 $T$ 的**总势能** $\Phi(T)$ 是所有节点秩的总和：
    $\Phi(T) = \sum_{x \in T} r(x) = \sum_{x \in T} \log_2(s(x))$


4. #势能函数公式 
	1. 这是考研或算法竞赛中可能涉及的数学定义：
	*   **子树大小：**$s(x)$表示节点$x$的子孙节点数量（包括$x$自身）。
	*   **秩（Rank）：**$r(x)=\lfloor\log_2 s(x)\rfloor$（通常简化为$\log_2 s(x)$）。
	*   **势能（Potential）：**$\Phi(T)=\sum_{x \in T} r(x)$。


- 物理意义直觉  
	- 你可以把势能$\Phi$想象成树的“混乱度”或“不平衡度”的**储蓄罐**：
		*   **势能高（单链）：** 树很高，操作很慢，但在操作过程中我们会通过旋转让树变矮，释放势能来支付昂贵的操作代价。
		*   **势能低（平衡）：** 树很矮，操作很快，此时我们很难从势能中借力，但因为树矮，本身操作代价就低。