1. #直接插入排序 
	1.  **核心思想**：将整个序列分为两个部分：已排序区和未排序区。初始时，已排序区只包含第一个元素。然后，依次从未排序区中取出第一个元素，将其插入到已排序区的合适位置，使已排序区仍然保持有序。
*   **步骤**：
    1.  从第二个元素（下标为1）开始，将其视为当前待插入的元素。
    2.  将该元素与它前面的已排序序列中的元素从后向前逐一比较。
    3.  如果前面的元素比它大，则将前面的元素后移一位。
    4.  重复步骤3，直到找到一个小于或等于它的元素，或已比较到序列的头部。
    5.  将待插入元素放入该位置。
    6.  重复以上步骤，直到处理完所有元素。
*   **性能分析**：
    *   **时间复杂度**：
        *   最佳情况（序列已基本有序）：$O(n)$。每趟只需要1次比较。
        *   最坏情况（序列逆序）：$O(n^2)$。第$i$趟需要$i-1$次比较和移动。
        *   平均情况：$O(n^2)$。
    *   **空间复杂度**：$O(1)$。
    *   **稳定性**：**稳定**。因为只有当待插入元素严格小于比较元素时才移动，相等时不移动，保证了相等元素的相对顺序不变。

* #折半插入排序 (Binary Insertion Sort)

*   **核心思想**：它是在直接插入排序基础上的一个优化。整体框架和直接插入排序一样，也是逐个将元素插入到已排序的子序列中。**唯一的改进在于查找插入位置的环节**。
*   **步骤**：
    1.  从第二个元素开始，将其视为当前待插入的元素。
    2.  使用**折半查找**在它前面的已排序子序列中确定其应该插入的位置。
    3.  将从该插入位置到当前元素原位置之间的所有元素统一向后移动一位。
    4.  将待插入元素放入该位置。
    5.  重复以上步骤，直到处理完所有元素。
*   **性能分析**：
    *   **时间复杂度**：
        *   折半插入排序减少了**比较次数**。总的比较次数为 $\sum_{i=1}^{n-1} \lceil \log_2(i+1) \rceil$，其时间复杂度为$O(n\log n)$。
        *   但是，它并没有减少**元素的移动次数**。在最坏情况下，元素的移动次数仍然是$O(n^2)$。
        *   由于算法的整体时间复杂度由更高阶的项决定，所以折半插入排序的平均和最坏时间复杂度仍然是$O(n^2)$。
    *   **空间复杂度**：$O(1)$。
    *   **稳定性**：**稳定**。折半查找可以被实现为稳定的（当找到相等元素时，继续在后半部分查找），从而保证整个排序算法的稳定性。