
#AVL树vs红黑树
 
| 特性       | AVL 树               | 红黑树 (RB Tree)         |
| :------- | :------------------ | :-------------------- |
| **平衡标准** | 严格平衡，高度差 $\le 1$    | 非严格平衡（路径长度差不超过 2 倍）   |
| **查找效率** | 更高（树更矮），$O(\log n)$ | 略低，但也是 $O(\log n)$    |
| **插入开销** | 需更多旋转，最多 2 次旋转      | 最多 2 次旋转，$O(1)$       |
| **删除开销** | 最差需 $O(\log n)$ 次旋转 | 最多 3 次旋转，$O(1)$       |
| **适用场景** | 查找多、插入删除少           | 插入删除频繁（如 C++ STL Map） |
考点一：旋转次数的上限
	这是 AVL 树与红黑树对比时的核心考点。
*   **插入操作（Insert）：**
    一旦发现失衡，只需要进行一次调整（单旋或双旋）即可使整棵树恢复平衡。
    *   旋转次数：常数级，最多 **2** 次（即一次双旋）。
    *   时间复杂度：$O(\log n)$。
*   **删除操作（Delete）：**
    删除节点导致失衡，进行旋转调整后，可能会导致父节点所在子树的高度变矮，从而引起更高层祖先节点的失衡。这种失衡可能一直向上传播到根节点。
    *   旋转次数：**可能需要多次调整**，最坏情况下需要 $O(\log n)$ 次旋转。
    *   **注意：** 如果题目问的是“哪种操作可能导致全树进行多次（指不同层级）的再平衡”，答案是 **仅删除**。但本题问的是“两次旋转”，且答案包含插入，因此特指“双旋”这个动作。


**插入操作：**     [[红黑树]]  
    *   AVL树：旋转$O(1)$次。
    *   红黑树：旋转$O(1)$次（但可能伴随$O(\log n)$次颜色调整）。
*   **删除操作：**
    *   AVL树：旋转$O(\log n)$次。
    *   红黑树：旋转$O(1)$次（至多3次旋转，但需$O(\log n)$次颜色调整）。
*   **平衡性与性能：**
    *   AVL树更“严格”平衡（高度差不超过1），查找效率略高于红黑树，适合**查找多、插入删除少**的场景。
    *   红黑树平衡条件较弱，插入删除时的恢复开销略低（尤其是删除时的旋转次数少），适合**插入删除频繁**的场景（如C++ STL中的`std::map`和`std::set`）。
