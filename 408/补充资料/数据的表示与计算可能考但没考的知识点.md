![[Pasted image 20251216213144.png]]
### 知识点一：进制转换问题
**核心考点：** 整数与小数的十进制转二进制、八进制、十六进制。

#### 【习题 1】
将十进制数 **27.625** 转换为二进制数、八进制数和十六进制数。

#### 【解答与解析】
**1. 转二进制：**
*   **整数部分 (27)：** 除2取余法。
    *   $27 \div 2 = 13 \dots 1$
    *   $13 \div 2 = 6 \dots 1$
    *   $6 \div 2 = 3 \dots 0$
    *   $3 \div 2 = 1 \dots 1$
    *   $1 \div 2 = 0 \dots 1$
    *   倒序排列：**11011**
*   **小数部分 (0.625)：** 乘2取整法。
    *   $0.625 \times 2 = 1.25$ (取整 1)
    *   $0.25 \times 2 = 0.5$ (取整 0)
    *   $0.5 \times 2 = 1.0$ (取整 1，结束)
    *   顺序排列：**.101**
*   **结果：** $(27.625)_{10} = (11011.101)_2$

**2. 转八进制：**
*   以小数点为中心，每3位二进制一组（不足补0）。
*   整数：`011 011` $\rightarrow$ $33$
*   小数：`101` $\rightarrow$ $5$
*   **结果：** $(33.5)_8$

**3. 转十六进制：**
*   以小数点为中心，每4位二进制一组。
*   整数：`0001 1011` $\rightarrow$ $1B$
*   小数：`1010` (补零) $\rightarrow$ $A$ (即10)
*   **结果：** $(1B.A)_{16}$

---

### 知识点二：类型转换的问题
**核心考点：** 有符号数与无符号数的位模式解释、精度丢失（int/float/double）。

#### 【习题 2】
假设C语言中 `short` 为16位，`int` 为32位。执行以下代码：
```c
short s = -10;
unsigned short u = (unsigned short)s;
```
请问 `u` 的十进制值是多少？并解释原因。

#### 【解答与解析】
**答案：** 65526
**解析：**
1.  **原码/补码表示：** 计算机中负数以补码存储。
    *   $10$ 的二进制（16位）：`0000 0000 0000 1010`
    *   $-10$ 的补码（取反加1）：`1111 1111 1111 0110`
2.  **强制转换：** 当把有符号的 `short` 转换为 `unsigned short` 时，内存中的**二进制位模式保持不变**，只是解释方式变了。
3.  **无符号解释：** 计算机现在将 `1111 1111 1111 0110` 看作一个正数。
    *   计算方法：$2^{16} - 10 = 65536 - 10 = 65526$。
    *   或者直接计算：$F \times 4096 + F \times 256 + F \times 16 + 6 = 65526$。

#### 【习题 3】
将 `int` 型变量（32位）强制转换为 `float` 型（IEEE 754 单精度），是否一定会发生数值改变（精度丢失）？请举例说明。

#### 【解答与解析】
**答案：** 可能会发生精度丢失。
**解析：**
*   `int` 是32位，其中31位用于表示数值（1位符号）。
*   `float` 虽然也是32位，但只有 **23位** 尾数（加上隐藏位共24位精度）。
*   当 `int` 的数值非常大，且有效二进制位数超过24位时，转换为 `float` 会导致低位被截断（舍入），从而丢失精度。
*   **例子：** $16777217$ ($2^{24} + 1$)。二进制为 `1000...0001` (中间23个0)。转为float时，由于尾数位不够，最后的 `1` 会被舍去，变成 $16777216$。

---

### 知识点三：运算与溢出（定点数/浮点数）
**核心考点：** 补码加减法、溢出判断（图片提示该点可能结合溢出考查）。

#### 【习题 4】
在 **8位定点整数**（补码表示）运算中，计算 $x + y$ 并判断是否溢出。
其中 $x = 100$ (十进制), $y = 30$ (十进制)。

#### 【解答与解析】
**1. 转换为8位补码：**
*   $x = 100$: `0110 0100` (正数补码同原码)
*   $y = 30$: `0001 1110`

**2. 二进制相加：**
```text
  0110 0100  (100)
+ 0001 1110  (30)
-----------
  1000 0010
```
**3. 结果解析：**
*   结果机器码：`1000 0010`
*   作为有符号数解释：首位是1，表示负数。取反加1得 `-(1111110) = -126`。
*   **溢出判断：**
    *   **方法一（双符号位法/逻辑判断）：** 两个正数相加，结果变成了负数（符号位由0变1），说明发生了**正溢出**。
    *   **结论：** 发生溢出。8位有符号数的范围是 $[-128, 127]$，而 $130 > 127$，故溢出。

---

### 知识点四：IEEE 754 标准的四个特殊的“数”
**核心考点：** 零、无穷大、NaN、非规格化数的位模式特征。
(注：四个特殊数通常指：$\pm 0$, $\pm \infty$, NaN, 非规格化数/Denormalized)

#### 【习题 5】
在 IEEE 754 单精度浮点数（32位）格式中，请根据阶码（Exponent, 8位）和尾数（Mantissa, 23位）的特征，填写下表对应的含义：

| 阶码 (E) | 尾数 (M) | 表示的数值/含义 |
| :--- | :--- | :--- |
| 全 0 | 全 0 | **(1)** |
| 全 0 | 不全为 0 | **(2)** |
| 全 1 | 全 0 | **(3)** |
| 全 1 | 不全为 0 | **(4)** |

#### 【解答与解析】
*   **IEEE 754 单精度结构：** 1位符号(S) + 8位阶码(E) + 23位尾数(M)。

**答案：**
1.  **$\pm 0$ (零)**：
    *   当 $E=0, M=0$ 时，表示机器零。根据符号位不同分为 $+0$ 和 $-0$。
2.  **非规格化数 (Denormalized Number)**：
    *   当 $E=0, M \neq 0$ 时。这类数非常接近0，用于填补0和最小规格化数之间的空隙，虽然精度较低，但保证了“逐渐下溢”。真实值为 $(-1)^S \times 0.M \times 2^{-126}$。
3.  **$\pm \infty$ (无穷大)**：
    *   当 $E=255$ (全1), $M=0$ 时。根据符号位表示 $+\infty$ 或 $-\infty$。常用于除以0或溢出处理。
4.  **NaN (Not a Number, 非数)**：
    *   当 $E=255$ (全1), $M \neq 0$ 时。表示非法运算结果，如 $0/0$, $\infty - \infty$ 等。

---

### 总结建议
*   **重点关注前两点**：进制转换和类型转换（特别是补码和无符号数的转换）是必考题，计算要细心。
*   **第三点**：虽然图片提到“推测不是重要考点”，但**溢出判断**（正正得负、负负得正）是高频小题，务必掌握。
*   **第四点**：记忆特殊的位模式（全0和全1的阶码）即可，不需要深究NaN的具体运算规则。