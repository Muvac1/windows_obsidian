1. #Dijkstra算法
一种经典的单源最短路径算法，用于计算图中一个节点到所有其他节点的最短路径。它的前提是图中所有边的权重（费用）都必须是**非负数**，这在网络路由中通常是满足的, 其核心思想是**贪心算法**。

2. #Dijkstra算法的复杂度 
	 朴素实现的 Dijkstra 算法时间复杂度为 $O(V^2)$。使用优先队列（最小堆）优化后，复杂度可以降为 $O(E \log V)$

- **基本步骤：**
1.  **初始化**：
    *   创建一个集合 $S$，用来存放已经找到最短路径的顶点。初始时，$S$ 中只有源点 `a`。
    *   创建一个距离数组 $dist$，`dist[v]` 表示从源点 `a` 到顶点 `v` 的当前最短距离。初始化 `dist[a] = 0`，对于其他所有顶点 `v`，$dist[v] = \infty$。然后，对于 `a` 的直接邻居 `v`，更新 $dist[v]$ 为边 `(a, v)` 的权重。

2.  **循环迭代**：重复以下步骤，直到所有顶点都加入到集合 $S$ 中。
    *   **选择顶点**：从尚未加入 $S$ 的顶点中，选择一个 `dist` 值最小的顶点 `u`。这个 `dist[u]` 就是从源点 `a` 到 `u` 的最短路径长度。
    *   **加入集合**：将顶点 `u` 加入集合 $S$。
    *   **松弛操作 (Relaxation)**：对于 `u` 的每一个邻居 `v`，检查通过 `u` 到达 `v` 是否会更近。如果 $dist[u] + w(u, v) < dist[v]$（其中 $w(u, v)$ 是边 `u->v` 的权重），则更新 $dist[v]$ 的值为 $dist[u] + w(u, v)$。
