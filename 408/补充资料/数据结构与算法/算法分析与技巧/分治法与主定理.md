1. #分治法与主定理
	许多复杂的递归算法属于分治法，其递推关系式通常形如：
	$T(n) = aT(n/b) + f(n)$
	- $a$: 递归调用的次数（子问题的数量）。
	- $n/b$: 每个子问题的规模。
	- $f(n)$: 分解问题和合并子问题结果所需的时间。
	[[大O符号的定义]] 
	#主定理 提供了一个“公式化”的方法来解决这类递推关系式：
	比较$n^{\log_b a}$与$f(n)$的大小：
	1.  如果$f(n) = O(n^{\log_b a - \epsilon})$ for some $\epsilon > 0$，那么$T(n) = \Theta(n^{\log_b a})$。
	2.  如果$f(n) = \Theta(n^{\log_b a})$，那么$T(n) = \Theta(n^{\log_b a} \log n)$。
	3.  如果$f(n) = \Omega(n^{\log_b a + \epsilon})$ for some $\epsilon > 0$，并且对于某个常数$c < 1$和足够大的$n$有$af(n/b) \le cf(n)$，那么$T(n) = \Theta(f(n))$。

主定理将递归树的“叶子节点工作量”$n^{\log_b a}$与“根节点工作量”$f(n)$进行比较，谁大取谁，一样大就乘$\log n$。

**简单记忆法（三类情况）：**

1.  **叶子重（头轻脚重）**：若$n^{\log_b a} > f(n)$（多项式级的大），复杂度由叶子决定。
    $$T(n)=\Theta(n^{\log_b a})$$
2.  **均衡（上下同重）**：若$n^{\log_b a} \approx f(n)$，复杂度是任意一层的工作量乘以层数（$\log n$）。
    $$T(n)=\Theta(n^{\log_b a}\cdot\log n)$$
    *(注：本题属于此情况，二分查找也是此情况)*
3.  **根重（头重脚轻）**：若$f(n) > n^{\log_b a}$（多项式级的大），复杂度由根节点决定。
    $$T(n)=\Theta(f(n))$$

	**举例:**
	- **归并排序 (Merge Sort)**: $T(n) = 2T(n/2) + O(n)$
	  - 这里$a=2, b=2, f(n)=O(n)$。
	  - $n^{\log_b a} = n^{\log_2 2} = n^1 = n$。
	  - $f(n)$与$n^{\log_b a}$同阶，适用情况2。
  - 所以归并排序的时间复杂度是$T(n) = \Theta(n \log n)$。
没关系，主定理确实初看起来有点抽象。我们把它拆解成更易于理解的白话文，再来一步步看归并排序的例子，你就会明白了。

### 主定理的通俗理解

你可以把主定理想象成一场“拔河比赛”，比赛的双方是：

*   **选手A：递归的威力**
    *   它由 $n^{\log_b a}$ 这个量来代表。
    *   这个值代表了 **子问题数量增长的速度**。`a` 越大（每次递归分出的子问题越多），`b` 越小（每次问题规模缩小的越多），这个值就增长得越快，代表递归产生的“纯粹的”计算量增长非常迅猛。
*   **选手B：合并/分解的代价**
    *   它由 $f(n)$ 这个量来代表。
    *   这个值代表了 **每一次递归调用中，除了调用自身之外，额外要做的工作**。比如归并排序里的“合并”操作。

这场拔河比赛的结果决定了整个算法的最终时间复杂度。

---

### 三种比赛结果（主定理的三个情况）

1.  **情况1：选手A（递归的威力）完胜**
    *   **数学描述**: $f(n) = O(n^{\log_b a - \epsilon})$
    *   **白话解释**: $f(n)$ 的增长速度 **远小于** $n^{\log_b a}$。这意味着，分解和合并子问题的工作量（选手B）和递归产生的海量子问题（选手A）相比，简直不值一提。算法的整体复杂度完全由“递归的威力”主导。
    *   **最终结果**: $T(n) = \Theta(n^{\log_b a})$。复杂度就是选手A的复杂度。

2.  **情况2：双方势均力敌**
    *   **数学描述**: $f(n) = \Theta(n^{\log_b a})$
    *   **白话解释**: $f(n)$ 的增长速度 **和** $n^{\log_b a}$ **差不多**。这意味着，每一层递归中“合并/分解”的代价，和这一层子问题的总规模基本相当。谁也压不倒谁。
    *   **最终结果**: $T(n) = \Theta(n^{\log_b a} \log n)$。既然每一层的工作量都差不多，那么总工作量就是“每一层的工作量”乘以“总共有多少层”。递归树的高度大约是 $\log n$ 层，所以最终结果要多乘上一个 $\log n$。

3.  **情况3：选手B（合并/分解的代价）完胜**
    *   **数学描述**: $f(n) = \Omega(n^{\log_b a + \epsilon})$
    *   **白话解释**: $f(n)$ 的增长速度 **远大于** $n^{\log_b a}$。这意味着，分解和合并子问题的工作量（选手B）太大了，以至于递归下去解决子问题的那些工作（选手A）跟它比起来，都可以忽略不计。算法的整体复杂度完全由“合并/分解的代价”主导。
    *   **最终结果**: $T(n) = \Theta(f(n))$。复杂度就是选手B的复杂度。（附加的那个 `af(n/b) ≤ cf(n)` 条件是为了确保 $f(n)$ 的增长是“稳定”的，不会忽快忽慢，这里可以先不用深究）。

---

### 重新分析归并排序：$T(n) = 2T(n/2) + O(n)$

现在我们用上面的“拔河比赛”模型来分析归并排序。

**第一步：确定参赛选手**

*   **$T(n) = 2T(n/2) + O(n)$**
    *   **`a = 2`**: 因为我们将数组分成 **2** 个子问题（左半部分和右半部分）。
    *   **`b = 2`**: 因为每个子问题的规模是原始问题的一半（`n/2`）。
    *   **`f(n) = O(n)`**: 这是“合并”两个已排序的子数组所需的时间。要把两个长度为 `n/2` 的数组合并成一个长度为 `n` 的有序数组，需要对 `n` 个元素进行比较和放置，这是一个线性操作，所以时间是 `O(n)`。

**第二步：计算双方的“实力”**

*   **选手A（递归的威力）**:
    *   $n^{\log_b a} = n^{\log_2 2}$
    *   因为 $\log_2 2 = 1$，所以 $n^{\log_2 2} = n^1 = n$。
    *   选手A的实力是 **`n`**。

*   **选手B（合并的代价）**:
    *   $f(n) = O(n)$。更准确地说，合并n个元素必然要访问每个元素，所以是 $\Theta(n)$。
    *   选手B的实力是 **`n`**。

**第三步：判断比赛结果**

*   我们比较选手A的实力 `n` 和选手B的实力 `Θ(n)`。
*   它们俩的增长速度是一样的！`n` 和 `n` 是同一个数量级。在数学上，我们说 $f(n) = \Theta(n^{\log_b a})$。
*   这完全符合**情况2：双方势均力敌**。

**第四步：得出结论**

*   根据主定理的情况2，当双方势均力敌时，最终的时间复杂度是 $T(n) = \Theta(n^{\log_b a} \log n)$。
*   代入我们的值：$T(n) = \Theta(n \log n)$。

### 总结

所以，“没看懂”的部分其实就是主定理最核心的应用过程：
1.  **从递推式 $T(n) = aT(n/b) + f(n)$ 中找出 a, b, f(n)。**
    *   对于归并排序，就是 a=2, b=2, f(n)=O(n)。
2.  **计算出“递归的威力” $n^{\log_b a}$。**
    *   对于归并排序，就是 $n^{\log_2 2} = n$。
3.  **比较 $f(n)$ 和 $n^{\log_b a}$ 的增长速度。**
    *   对于归并排序，`O(n)` 和 `n` 是同一级别，所以是“势均力敌”。
4.  **套用主定理三种情况中对应的那一个。**
    *   归并排序对应情况2，所以最终结果是 $\Theta(n \log n)$。

希望这个分解解释能帮助你理解！