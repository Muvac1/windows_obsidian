#时间复杂度分析 的核心是找到 #执行频率最高的语 句，并计算它相对于 #问题规模`n`的 #执行次数

*   $O(m+n)$ 或 $O(\max(m, n))$: 线性复杂度，表示算法时间与两个输入的总规模成正比。
*   $O(\min(m, n))$: 线性复杂度，但只与较小的那个输入规模有关。这通常发生在算法在其中一个输入处理完毕后就可以提前结束的情况下。
*   $O(mn)$: 平方级复杂度，通常涉及嵌套循环，对一个输入的每个元素都要遍历另一个完整的输入。




**1. $O(\log n)$ - 对数复杂度**

如果循环控制变量是以乘法或除法方式变化的，通常会导致对数复杂度。

*   **示例代码**：
    ```c
    int i = 1;
    while (i < n) {
        i = i * 2; // 或者 i = i * c, c > 1
    }
    ```
*   **分析**：假设循环执行 `k` 次，则 `i` 的值依次为 $2^0, 2^1, 2^2, \dots, 2^k$。循环终止时有 $2^k \ge n$，解得 $k \ge \log_2 n$。因此时间复杂度为 $O(\log n)$。

**2. $O(n)$ - 线性复杂度**

这是最常见的复杂度，循环控制变量以加法或减法方式线性增长。

*   **示例代码**：
    ```c
    for (int i = 0; i < n; i++) {
        // O(1) 操作
    }
    ```
*   **分析**：循环体执行了 `n` 次，时间复杂度为 $O(n)$。

**3. $O(n \log n)$ - 线性对数复杂度**

通常出现在嵌套循环中，或者在分治算法中（如归并排序、快速排序）。

*   **示例代码**：
    ```c
    for (int i = 0; i < n; i++) {
        for (int j = 1; j < n; j = j * 2) {
            // O(1) 操作
        }
    }
    ```
*   **分析**：外层循环执行 `n` 次，内层循环是我们在上面讨论过的对数复杂度 $O(\log n)$。总的复杂度是两者相乘，即 $O(n \log n)$。

[[++i vs. i++ 的时间复杂度影响]] 

*   **问题**：如果原题中的 `sum += ++i;` 改为 `sum += i++;`，时间复杂度会变吗？
*   **分析**：`sum += i++;` 等价于 `sum = sum + i; i = i + 1;`。
    *   **第1次循环**：`sum` = 0 + 0 = 0, `i` 变为 1。
    *   **第2次循环**：`sum` = 0 + 1 = 1, `i` 变为 2。
    *   **第k次循环**：`sum` 的值是 $0 + 1 + 2 + \dots + (k-1)$。
    *   求和为 $sum = \frac{(k-1)k}{2}$。
    *   同样令 $sum \approx n$，我们得到 $\frac{k(k-1)}{2} \approx n$，即 $k^2 - k \approx 2n$。
*   **结论**：在渐近分析中，$k^2-k$ 和 $k^2+k$ 的主导项都是 $k^2$。因此，求解后得到的复杂度依然是 $O(\sqrt{n})$。在时间复杂度的大O分析层面，这两者没有区别，但这可能作为一个细节题来考察对自增运算符的理解。