一个核心比喻来贯穿整个解释：**登山**。

*   **递归深度 (Recursion Depth)**：你在任意时刻所处的**海拔高度**。我们通常关心的是你到达的**最高海拔（最大深度）**。
*   **递归次数 (Recursion Count)**：你从山脚到山顶再返回，总共**走了多少步**。

---

### 一、核心区别

| 方面       | 递归深度 (Recursion Depth)                   | 递归次数 (Recursion Count)                     |
| :------- | :--------------------------------------- | :----------------------------------------- |
| **核心含义** | **嵌套的层级**：函数同时存在于调用栈中的最大数量。              | **调用的总和**：函数在整个执行过程中被调用的总次数。               |
| **衡量重点** | **空间复杂度**：它直接关系到调用栈需要占用多少内存。深度越大，内存消耗越多。 | **时间复杂度**：它直接关系到算法执行了多少次操作，即计算量。次数越多，耗时越长。 |
| **关注点**  | **某一时刻的“状态”**：在最深的点，调用栈里有多少个“未完成”的函数。    | **整个过程的“累计”**：从开始到结束，一共触发了多少次函数调用。         |
| **相关问题** | **栈溢出 (Stack Overflow)**：深度超过系统限制。       | **性能低下 (Poor Performance)**：次数过多导致程序运行缓慢。  |

---

### 二、代码示例：树的遍历

这个例子能非常清晰地展示两者的区别。假设我们有这样一棵二叉树，我们要统计所有节点的数量。

```
      A
     / \
    B   C
       / \
      D   E
```

递归代码如下：
```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

# 我们的递归函数
def count_nodes(node):
    if node is None:
        return 0
    
    # 每次调用，我们都打印一下信息
    print(f"正在访问节点: {node.value}")
    
    # 递归调用
    left_count = count_nodes(node.left)
    right_count = count_nodes(node.right)
    
    # 返回节点总数 (自身 + 左子树 + 右子树)
    return 1 + left_count + right_count

# 创建树
#      A(1)
#     / \
#    B(2) C(3)
#         / \
#        D(4) E(5)
root = TreeNode('A',
          left=TreeNode('B'),
          right=TreeNode('C',
                   left=TreeNode('D'),
                   right=TreeNode('E')))

total = count_nodes(root)
print(f"\n节点总数: {total}")
```

#### 执行过程分析：

让我们一步步跟踪，同时记录**当前深度**和**累计次数**。

| 步骤 | 调用函数 | 当前深度 | 累计次数 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | `count_nodes(A)` | 1 | 1 | 开始执行，进入第一层。 |
| 2 | `count_nodes(B)` | 2 | 2 | A调用其左子节点，进入第二层。 |
| 3 | `count_nodes(B)`返回 | 1 | 2 | B没有子节点，返回。深度减一。 |
| 4 | `count_nodes(C)` | 2 | 3 | A调用其右子节点，再次进入第二层。 |
| 5 | `count_nodes(D)` | **3** | 4 | C调用其左子节点，进入第三层。**这是目前的最大深度**。 |
| 6 | `count_nodes(D)`返回 | 2 | 4 | D没有子节点，返回。深度减一。 |
| 7 | `count_nodes(E)` | **3** | 5 | C调用其右子节点，再次进入第三层。 |
| 8 | `count_nodes(E)`返回 | 2 | 5 | E没有子节点，返回。深度减一。 |
| 9 | `count_nodes(C)`返回 | 1 | 5 | C的左右子树都计算完毕，返回。深度减一。 |
| 10 | `count_nodes(A)`返回 | 0 | 5 | A的左右子树都计算完毕，返回。程序结束。 |

#### 结论分析：

*   **最大递归深度 (Maximum Recursion Depth)**：
    在整个过程中，调用栈最深达到了 3 层（当计算 `D` 或 `E` 时，调用链是 `A -> C -> D` 或 `A -> C -> E`）。所以，最大深度是 **3**。这对应了树的高度。
*   **递归总次数 (Total Recursion Count)**：
    `count_nodes` 函数总共被调用了 **5** 次（分别针对 A, B, C, D, E 这五个节点）。所以，递归次数是 **5**。这对应了树的节点数。

### 三、何时两者会相等（或接近）？

在**线性递归**中，递归深度和递归次数通常是相等的。我们之前用过的阶乘就是典型的例子。

```python
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)
```

调用 `factorial(4)`：
*   调用链是 `factorial(4) -> factorial(3) -> factorial(2) -> factorial(1)`。
*   **最大深度**：4
*   **总调用次数**：4

在这种情况下，因为每次调用只会产生一个“分支”（即下一次调用），所以深度和次数同步增长。

### 总结

记住这个核心区别：

*   **深度 (Depth)** 关心的是**“同时”**，与**内存（栈空间）**相关。
*   **次数 (Count)** 关心的是**“总共”**，与**时间（计算量）**相关。

对于复杂的、有分支的递归（如树的遍历、分治算法），这两者的差异会非常显著。一个高度为 H 的完美二叉树，其**最大深度**约为 H，而其**递归次数**（节点数）约为 2^H，是指数级的差异！