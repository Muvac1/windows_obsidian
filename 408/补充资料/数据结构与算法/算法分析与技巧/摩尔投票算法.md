#摩尔投票算法   摩尔投票算法的核心思想：对拼消耗

这个算法的核心思想非常巧妙，可以理解为“对拼消耗”或者“阵地攻防”。

1.  **基本推论**：如果一个元素是主元素，那么它的数量比**所有其他元素数量的总和**还要多。
    *   设主元素为 $M$，其数量为 $count(M)$。
    *   数组总长度为 $n$。
    *   根据定义，$count(M) > n/2$。
    *   所有其他元素的数量总和为 $count(Others) = n - count(M)$。
    *   因为 $count(M) > n/2$，所以 $n < 2 \cdot count(M)$，即 $n - count(M) < count(M)$。
    *   结论：$count(Others) < count(M)$。

2.  **对拼过程**：
    *   我们可以把寻找主元素的过程看作一场战争。我们假设第一个元素是“守城将军”，占据阵地。
    *   我们遍历数组，如果遇到的下一个士兵和“守城将军”是同一国的，我们就增加守城方的兵力（计数器加一）。
    *   如果遇到的士兵是敌国的（和将军不是同一个元素），那就进行“一换一”的消耗，即守城方派出一个士兵和这个敌国士兵同归于尽（计数器减一）。
    *   如果守城方的兵力被消耗殆尽（计数器变为0），那么阵地就被下一个到来的士兵占据，他成为新的“守城将军”，兵力（计数器）重置为1。

3.  **最终结果**：
    *   由于主元素 $M$ 的数量比所有其他元素加起来还多，所以在这种“一换一”的消耗战中，经过一轮遍历后，最后守在阵地上的那个“将军”**必然是主元素 $M$**（如果主元素存在的话）。其他所有非主元素都会被主元素或者其他元素消耗掉。

4.  **为什么需要第二轮验证？**
    *   第一轮遍历结束后，我们找到了一个**候选者 (candidate)**。这个候选者是**唯一可能**成为主元的元素。
    *   但是，这个候选者不一定是真正的主元。例如，对于数组 `A = [1, 2, 3]`，按算法流程，最后留下的候选者是 `3`，但它的数量并没有超过 $n/2$。
    *   因此，我们必须进行第二轮遍历，**重新统计**这个候选者在原数组中实际出现的次数，以验证它是否真的满足“数量超过 $n/2$”的条件。