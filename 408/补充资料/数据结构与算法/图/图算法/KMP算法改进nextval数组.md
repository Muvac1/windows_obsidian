#KMP算法改进nextval数组  [[KMP算法]] 
标准的 KMP 算法在某些情况下存在缺陷。例如，对于模式串 `t = "aaaaab"`，其 `next` 数组为 `[-1, 0, 1, 2, 3, 4]`。当在主串中匹配到 `...aaaaac...` 时，`t[5]` ('b') 与 `s[i]` ('c') 失配。
*   此时 `j=5`，`i` 不变，`j` 变为 `next[5]=4`。
*   下一次比较 `s[i]` 和 `t[4]`。但我们知道 `t[5] != s[i]` 且 `t[4] == t[5] == 'a'`，所以这次比较也必然失败。
*   `j` 会依次变为 3, 2, 1, 0，进行了多次不必要的比较。

为了解决这个问题，引入了 `nextval` 数组。其计算规则如下：
1.  令 `k = next[j]`。
2.  如果 `t[j] == t[k]`，则说明在 `j` 位置失配后，跳转到 `k` 位置仍然会因为同一个字符而失配，所以应该继续向前跳转。因此 `nextval[j] = nextval[k]`。
3.  如果 `t[j] != t[k]`，则跳转到 `k` 位置是有意义的。因此 `nextval[j] = k`。

**为 `t = "abaabc"` 计算 `nextval` 数组:**
*   `nextval[0] = -1`。
*   `j=1, k=next[1]=0`。 `t[1]`('b') `!=` `t[0]`('a'). 所以 `nextval[1] = 0`。
*   `j=2, k=next[2]=0`。 `t[2]`('a') `==` `t[0]`('a'). 所以 `nextval[2] = nextval[0] = -1`。
*   `j=3, k=next[3]=1`。 `t[3]`('a') `!=` `t[1]`('b'). 所以 `nextval[3] = 1`。
*   `j=4, k=next[4]=1`。 `t[4]`('b') `==` `t[1]`('b'). 所以 `nextval[4] = nextval[1] = 0`。
*   `j=5, k=next[5]=2`。 `t[5]`('c') `!=` `t[2]`('a'). 所以 `nextval[5] = 2`。

最终 `nextval` 数组为 `[-1, 0, -1, 1, 0, 2]`。
