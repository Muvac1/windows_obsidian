#BFS和DFS的根本区别——**BFS用队列实现层序遍历，DFS用栈/递归实现深度探索**  
1. #广度优先搜索BFS (Breadth-First Search, BFS) 
	*   **核心思想**: "层层推进"。从一个起始顶点开始，首先访问其所有直接相邻的邻居顶点。然后，再按顺序依次访问这些邻居顶点的、尚未被访问过的邻居。这个过程就像水波纹一样，从中心一圈一圈地向外扩散。  #层次遍历 
	*   **实现方式**: 通常使用一个 #队列（Queue） 来实现，遵循“先进先出”（FIFO）的原则。
	*   **算法步骤**:
    1.  选择一个起始顶点，将其放入队列，并标记为已访问。
    2.  当队列不为空时，循环执行以下操作：
        a. 从 #队列头部 取出一个顶点 `u`。
        b. 访问 `u`（即将其加入遍历序列）。
        c. 查找 `u` 的所有邻接点，将其中尚未被访问过的邻接点 `v` 依次放入队列尾部，并标记为已访问。
2. #深度优先搜索DFS (Depth-First Search, DFS)
	*   **核心思想**: "一条路走到黑"。从起始顶点开始，沿着一条路径尽可能深地访问，直到不能再前进为止，然后回溯到上一个顶点，选择另一条尚未走过的路径继续深入。
	*   **实现方式**: 通常使用**栈（Stack）**或**递归**来实现，遵循“后进先出”（LIFO）的原则。

3. #算法复杂度 
	*   对于一个有$V$个顶点和$E$条边的图，BFS和DFS的时间复杂度在使用**邻接表**存储时都是$O(V+E)$。因为每个顶点和每条边都只会被访问一次。
	*   空间复杂度都是$O(V)$。BFS的空间开销主要在队列，最坏情况下可能存储所有顶点；DFS的空间开销主要在递归栈，最坏情况下深度为$V$。 

4. #算法应用 
    *   #BFS的应用 :
        *   **求无权图的最短路径**: BFS按层遍历的特性保证了第一次找到目标节点时，其路径就是最短的。
        *   **社交网络的好友推荐**: 查找二度、三度好友。
        *   **在棋盘类游戏中寻找最少步数**。
    *   #DFS的应用 :
        *   **判断图中是否存在环路**: 在遍历时遇到一个已经访问过但不是其父节点的节点，则存在环。
        *   **拓扑排序**: 用于有向无环图（DAG）中确定任务的执行顺序。
        *   **寻找图的连通分量**。
        *   **解决迷宫问题（寻找一条可行路径）**。
5. #算法变种  
    *   **双向BFS**: 从起点和终点同时开始BFS，当两个搜索相遇时，找到最短路径。
    *   **A\* 搜索**: 在BFS基础上加入启发式函数，是一种更高效的寻路算法。
    *   **迭代加深的深度优先搜索 (IDDFS)**: 结合了DFS的空间优势和BFS的最短路径特性。
