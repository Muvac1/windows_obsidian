 1. #冲突 (Collision)
	 1. 当两个不同的键经过哈希函数计算后得到了相同的哈希地址，这种情况就称为冲突
2. #冲突解决方法：
	1. #线性探测再散列法 (Linear Probing)：题目中使用的方法。当发生冲突时，从冲突位置开始，依次向后探测，直到找到一个空闲的位置来存放元素。探测公式为$H_i=(H(key)+i)\pmod{m}$，其中$m$是表长，$i=1, 2, 3, \dots$。
		1.   **缺点**：容易产生**一次堆积 (Primary Clustering)**，即不同哈希值的关键字争夺同一个后续探测序列，导致大片连续的聚集区。
	2. #二次探测法    $H_i = (H(key) \pm d_i) \pmod{m}$，其中 $d_i = 1^2, 2^2, 3^2, ...$。
        *   **优点**：可以有效避免一次堆积。
        *   **缺点**：会产生**二次堆积 (Secondary Clustering)**，即哈希值相同的关键字会拥有相同的探测序列。 
	3. 再散列法/双散列法
		1. $H_i = (H(key) + i \cdot H_2(key)) \pmod{m}$，使用第二个哈希函数 $H_2$ 来确定步长。
        *   **优点**：能很好地避免一次和二次堆积，是开放定址法中性能最好的方法。
	4. #双向平方试探法 
		1. $d_i = \pm i^2$。即序列为$1^2, -1^2, 2^2, -2^2, \dots$。
		    *   **性质：** 当且仅当表长$M$是形如$4k+3$的素数时，这种探测方法可以遍历表中的**所有**位置。
3. #堆积 
	1. 在使用 #开放定址法 处理冲突时，一个位置的冲突可能会导致后续一连串的位置也被占用，从而形成一个元素“聚集”的区域。这种现象就叫堆积 
		1. 举例（线性探测法）
			假设哈希表大小为10，哈希函数为 `H(key) = key % 10`。现在要插入关键字 12, 22, 32。
            *   插入 12: `H(12) = 2`，位置2为空，放入。
            *   插入 22: `H(22) = 2`，位置2被占用（冲突）。线性探测法会向后查找，位置3为空，将22放入位置3。
            *   插入 32: `H(32) = 2`，位置2被占用。向后查找，位置3也被22占用。继续向后，位置4为空，将32放入位置4。
        *   在这个例子中，本应都放在位置2的元素，因为冲突而占据了位置2, 3, 4，形成了一个“堆积”或“聚集”的块
