### 1. 算法步骤

1. **选择基准元素**：从列表中选择一个元素作为基准（pivot）。选择方式可以是第一个元素、最后一个元素、中间元素或随机元素。
    
2. **分区**：将列表重新排列，使得所有小于基准元素的元素都在基准的左侧，所有大于基准元素的元素都在基准的右侧。基准元素的位置在分区完成后确定。
    
3. **递归排序**：对基准元素左侧和右侧的子列表分别递归地进行快速排序。
    
4. **合并**：由于分区操作是原地进行的，递归结束后整个列表已经有序。
    

### 2. 动图演示

![](https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif)

假设有一个待排序的列表 `[3, 6, 8, 10, 1, 2, 1]`，选择最后一个元素作为基准（pivot），排序过程如下：

1. **初始状态**：
    
    - 列表：`[3, 6, 8, 10, 1, 2, 1]`。
        
    - 基准元素：`1`（最后一个元素）。
        
2. **第一轮分区**：
    
    - 将小于基准的元素放在左侧，大于基准的元素放在右侧。
        
    - 分区后列表：`[1, 1, 2, 10, 6, 8, 3]`。
        
    - 基准元素 `1` 的位置确定。
        
3. **递归排序**：
    
    - 对左侧子列表 `[1]` 和右侧子列表 `[2, 10, 6, 8, 3]` 分别进行快速排序。
        
    - 左侧子列表已经有序。
        
    - 对右侧子列表 `[2, 10, 6, 8, 3]` 选择基准元素 `3`（最后一个元素）：
        
        - 分区后列表：`[2, 3, 6, 8, 10]`。
            
        - 基准元素 `3` 的位置确定。
            
    - 继续递归排序右侧子列表 `[6, 8, 10]`：
        
        - 选择基准元素 `10`（最后一个元素）：
            
            - 分区后列表：`[6, 8, 10]`。
                
            - 基准元素 `10` 的位置确定。
                
        - 继续递归排序左侧子列表 `[6, 8]`：
            
            - 选择基准元素 `8`（最后一个元素）：
                
                - 分区后列表：`[6, 8]`。
                    
                - 基准元素 `8` 的位置确定。
                    
            - 继续递归排序左侧子列表 `[6]`，已经有序。
                
4. **最终结果**：
    
    - 列表完全有序：`[1, 1, 2, 3, 6, 8, 10]`。
## 实例

def quick_sort(arr):  
    if len(arr) <= 1:  
        return arr  
  
    # 选择基准元素（这里选择最后一个元素）  
    pivot = arr[-1]  
    # 分区：小于基准的元素放在左侧，大于基准的元素放在右侧  
    left = [x for x in arr[:-1] if x <= pivot]  
    right = [x for x in arr[:-1] if x > pivot]  
    # 递归排序并合并  
    return quick_sort(left) + [pivot] + quick_sort(right)  
  
# 示例  
arr = [3, 6, 8, 10, 1, 2, 1]  
sorted_arr = quick_sort(arr)  
print(sorted_arr)  # 输出: [1, 1, 2, 3, 6, 8, 10]  

### 时间复杂度

- **分解**：每次将列表分成两半，需要 O(log n) 层递归。
    
- **合并**：每层递归需要 O(n) 的时间来合并子列表。
    
- **总时间复杂度**：O(n log n)。  
    

---

### 空间复杂度

- O(n)，归并排序需要额外的空间来存储临时列表。 O(log n) ~ O(n) 
    

---

### 优缺点

- **优点**：
    
    - 时间复杂度稳定为 O(n log n)，适合大规模数据。
        
    - 稳定排序算法（相同元素的相对顺序不会改变）。
        
    - 适合外部排序（如对磁盘文件进行排序）。
        
- **缺点**：
    
    - 需要额外的存储空间，空间复杂度为 O(n)。
        
    - 对于小规模数据，性能可能不如插入排序等简单算法。
        

---

### 适用场景

- 大规模数据集的排序。
    
- 需要稳定排序算法的场景。
    
- 外部排序（如对磁盘文件进行排序）。
C++ 代码实例
```C++
 int Paritition1(int A[], int low, int high) {
   int pivot = A[low];
   while (low < high) {
     while (low < high && A[high] >= pivot) {
       --high;
     }
     A[low] = A[high];
     while (low < high && A[low] <= pivot) {
       ++low;
     }
     A[high] = A[low];
   }
   A[low] = pivot;
   return low;
 }

 void QuickSort(int A[], int low, int high) //快排母函数
 {
   if (low < high) {
     int pivot = Paritition1(A, low, high);
     QuickSort(A, low, pivot - 1);
     QuickSort(A, pivot + 1, high);
   }
 }
 ```

 #递归和处理的区别
   
-   **处理过一次数据**：指的是执行了一次 **`partition`（分区）** 操作。这是快速排序的“体力活”。
*   **递归过了一次**：指的是完成了一次 **`quicksort` 函数** 的完整调用。这是快速排序的“指挥官”。

下面我们用一个具体的例子来详细分解。

假设我们要排序的数组是： `[7, 2, 8, 1, 5, 4]`

---

### 一、什么叫“处理过一次数据”？—— 核心是 `Partition`（分区）操作

“处理一次数据”指的是对数组（或其一部分）执行一次完整的 **`partition`** 操作。这个操作的目标是：

1.  从数组中选一个元素作为 **基准（Pivot）**。
2.  重新排列数组，使得所有比基准小的元素都在基准的左边，所有比基准大的元素都在基准的右边。
3.  操作结束后，**这个基准元素就到达了它最终的、已排序的位置**。

#### 示例：对 `[7, 2, 8, 1, 5, 4]` 的第一次 `Partition`

1.  **选择基准 (Pivot)**：我们选择最后一个元素 `4` 作为基准。
    *   数组: `[7, 2, 8, 1, 5, **4**]`
    *   基准: `4`

2.  **重新排列 (Partitioning)**：我们用两个指针（或类似方法）从头开始遍历。
    *   遇到 `7` (比`4`大)，不动。
    *   遇到 `2` (比`4`小)，把它和 `7` 交换位置。数组变为：`[2, 7, 8, 1, 5, 4]`
    *   遇到 `8` (比`4`大)，不动。
    *   遇到 `1` (比`4`小)，把它和 `7` 交换位置。数组变为：`[2, 1, 8, 7, 5, 4]`
    *   遇到 `5` (比`4`大)，不动。

3.  **放置基准**：遍历结束后，我们将基准 `4` 放到所有“小数”和所有“大数”的分界线上（这里是和 `8` 交换）。
    *   数组最终变为： `[2, 1, **4**, 7, 5, 8]`

**到这里，我们就说“处理过了一次数据”**。

**这次处理的结果是：**
*   基准 `4` 已经找到了它在最终排序数组中的正确位置（索引2）。
*   数组被分成了两部分：
    *   左边子数组 `[2, 1]` (所有元素都 <= 4)
    *   右边子数组 `[7, 5, 8]` (所有元素都 >= 4)
*   **注意**：子数组内部仍然是无序的！

---

### 二、什么叫“递归过了一次”？—— 一次完整的 `quicksort` 函数调用

“递归过了一次”指的是一次 `quicksort` 函数从被调用到它发起新的递归调用（或结束）的整个过程。

一次 `quicksort` 函数的调用，通常包含以下步骤：

1.  **检查终止条件**：如果要排序的数组部分只有一个或零个元素，直接返回（因为已经有序了）。
2.  **执行一次 `Partition` 操作**：也就是我们上面说的“处理一次数据”。
3.  **发起两个新的递归调用**：对 `Partition` 操作产生的左边子数组和右边子数组，分别调用 `quicksort` 函数。

#### 示例：对 `[7, 2, 8, 1, 5, 4]` 的第一次递归

1.  **初始调用（第1次递归）**: `quicksort(array, 0, 5)` 被调用。
    *   **步骤 A (Partition)**：它首先对整个数组 `[7, 2, 8, 1, 5, 4]` 执行了我们上面描述的 `Partition` 操作。
    *   `Partition` 的结果是数组变为 `[2, 1, 4, 7, 5, 8]`，并告诉我们基准 `4` 的最终位置是索引 `2`。
    *   **步骤 B (发起新调用)**：现在，这个函数知道左边 `[2, 1]` 和右边 `[7, 5, 8]` 还需要排序。于是它发起了两个新的调用：
        *   `quicksort(array, 0, 1)`  // 对 `[2, 1]` 进行排序
        *   `quicksort(array, 3, 5)`  // 对 `[7, 5, 8]` 进行排序

**当 `quicksort(array, 0, 5)` 完成了这两步（Partition + 发起新调用）之后，它自己的任务就结束了**（虽然它会等待子调用返回结果）。我们就说**第一次递归调用完成了**。

接下来，程序会进入更深的递归层次：

*   **第2次递归**: `quicksort(array, 0, 1)` 被执行。它会对 `[2, 1]` 进行 `Partition`，然后发起新的调用...
*   **第3次递归**: `quicksort(array, 3, 5)` 被执行。它会对 `[7, 5, 8]` 进行 `Partition`，然后发起新的调用...

以此类推，直到所有子数组都被处理完毕。

---

### 总结与对比

| 概念 | 动作 | 目标 | 范围 | 比喻 |
| :--- | :--- | :--- | :--- | :--- |
| **处理一次数据<br>(一次 Partition)** | 选基准、交换元素、放置基准。 | **将一个元素（基准）放到其最终的正确位置**，并将数组一分为二。 | 数组的一个**片段**。 | 团队里的一个**实干者**，负责完成一件具体的排序任务。 |
| **递归过了一次<br>(一次 Quicksort 调用)** | 1. 调用 `Partition`<br>2. 发起两个新的递归调用 | **分解问题**：将一个大的排序任务，分解成两个更小的排序任务。 | 函数的一次**执行周期**。 | 团队里的一个**项目经理**，负责拆分任务并分配给下属（新的递归调用）。 |

所以，**一次递归调用**必然**包含一次数据处理（Partition）**，但它更重要的角色是作为“指挥官”来驱动整个分而治之的流程。