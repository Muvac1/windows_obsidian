#基数排序
#### 1. 核心思想
基数排序不是通过比较元素大小来排序，而是利用“分配”和“收集”两种操作，按元素的**关键字**（在这里是数字的每一位）进行排序。它是一种**桶排序 (Bucket Sort)** 的扩展。
	一种非比较型整数排序算法。原理是将整数按位数切割成不同的数字，然后按每个位数分别比较

- **分类：**
    *   **LSD (Least Significant Digit)**：从最低位开始排序（常用，必须稳定）。
    *   **MSD (Most Significant Digit)**：从最高位开始排序（通常用递归分桶实现，对稳定性要求不同，但题目通常默认指LSD）。
		*  为什么LSD比MSD更常用？
			*  LSD 不需要递归，实现简单，且由于从低位到高位处理，容易利用计算机的缓存特性。MSD 需要递归地对子桶进行排序，管理开销较大。   
#### 2. 关键概念
*   **基数 (Radix):** 进行排序所依据的进制基数，通常用 $k$ 表示。对于十进制整数，基数 $k=10$。对于二进制数，基数 $k=2$。
*   **趟 (Pass):** 每一轮的“分配-收集”过程称为一趟。排序的趟数由数据中位数最多的那个元素决定，用 $d$ 表示。例如，对于序列 `(10, 99, 120)`，最大数是 `120`，有3位，所以需要进行3趟排序。
*   **稳定性 (Stability):** 基数排序是一种**稳定**的排序算法。这意味着，如果两个元素有相同的关键字（例如，在按十位数排序时，`110` 和 `911` 的十位数都是1），它们在排序后的相对位置与排序前保持一致。这是基数排序能够正确工作的关键。在上面的例子中，因为在第1趟排序后 `110` 在 `911` 前面，所以在第2趟分配到同一个桶时，`110` 依然排在 `911` 前面。

#### 3. 算法复杂度
*   **时间复杂度:** $O(d(n+k))$
    *   $n$ 是待排序元素的个数。
    *   $d$ 是关键字的位数（最大数的位数）。
    *   $k$ 是基数（桶的数量）。
    当 $k$ 和 $d$ 相对 $n$ 较小时，时间复杂度近似为线性的 $O(n)$，效率非常高。
*   **空间复杂度:** $O(n+k)$
    需要 $k$ 个桶来存储元素，并且在最坏情况下，所有 $n$ 个元素可能都落入同一个桶中。
- 稳定性 (Stability)
	*   **定义：** 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，$r_i=r_j$，且 $r_i$ 在 $r_j$ 之前，而在排序后的序列中，$r_i$ 仍在 $r_j$ 之前，则称这种排序算法是稳定的；否则称为不稳定的。

- 如果题目让你分析性能，你可能需要写出如下形式：
	若对 $N$ 个整数进行排序，范围在 $0$ 到 $R^d-1$ 之间（即 $d$ 位 $R$ 进制数），则：
	*   时间复杂度：$T(n)=O(d \cdot (n+R))$
	*   空间复杂度：$S(n)=O(n+R)$