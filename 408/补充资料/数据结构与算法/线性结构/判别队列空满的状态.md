 
 在题目给定的指针定义下（$front$ 指向队头，$rear$ 指向队尾），如何判断队列是空还是满？
	   **初始状态 (空)**：根据我们的推导，为 $front=0$，$rear=n-1$。
	   **一个元素时**：$front=0$，$rear=0$。
	   **两个元素时**：$front=0$，$rear=1$。
	   **...**
	   **满状态时**：$front$ 仍然为 $0$，$rear$ 经过 $n-1$ 次移动，最终会停在 $n-1$ 的位置。此时 $front=0$, $rear=n-1$。
**问题出现了**：在这种指针定义下，**队空**（$front=0, rear=n-1$）和**队满**（$front=0, rear=n-1$）的状态完全一样，无法区分！
#解决方案 
  - 方案一： #牺牲一个存储单元
    *   这是最常见的方法。约定“队尾指针的下一个位置是队头”时为队满。
    *   **队满条件**：$(rear + 1) \% n == front$
    *   **队空条件**：$front == rear$
    *   在这种约定下，为了满足题目条件（第一个元素入队到 $A[0]$），初始时 $front$ 和 $rear$ 都会被设为 $0$。入队时，先将元素放入 $rear$ 指向的位置，再移动 $rear$。这样与题目的指针定义（$rear$ 指向队尾元素）不符，但这是最经典的实现方式。

*   **方案二：增设一个标志位 (flag/tag)**
    *   设置一个布尔变量 `tag`，`tag=0` 表示最后一次操作是出队，`tag=1` 表示最后一次操作是入队。
    *   当 $front == rear$ 时：
        *   如果 `tag=0`，则队列为空。
        *   如果 `tag=1`，则队列为满。

*   **方案三：增设一个计数器 (size)**
    *   设置一个整型变量 `size` 来记录队列中元素的个数。
    *   **队空条件**：$size == 0$
    *   **队满条件**：$size == n$
    *   这种方法最直观，判断效率高，但额外增加了一个变量的维护成本。