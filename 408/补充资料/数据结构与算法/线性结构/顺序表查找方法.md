### 1. 顺序查找 (Sequential Search)

也称为线性查找 (Linear Search)。这是最简单、最直观的查找方法。

*   **核心思想**：从表的一端（通常是开头）开始，逐个将元素与目标值进行比较，直到找到相等的元素或搜遍整个表。

*   **前提条件**：**无任何要求**。适用于任何顺序表，无论是否有序。

*   **执行步骤**：
    1.  从表的第一个元素（索引`i=0`）开始。
    2.  比较 `L[i]` 与要查找的关键字 `key`。
    3.  如果 `L[i] == key`，查找成功，返回当前位置 `i`。
    4.  如果 `L[i] != key`，则 `i` 增加 1，继续比较下一个元素。
    5.  如果 `i` 超出了表的范围，说明表中没有该元素，查找失败。

*   **时间复杂度**：
    *   **最好情况**：O(1) - 第一个元素就是目标。
    *   **最坏情况**：O(n) - 目标是最后一个元素，或者目标不存在。
    *   **平均情况**：O(n) - 平均需要比较 n/2 次。

*   **优缺点**：
    *   **优点**：实现简单，对表无任何排序要求，插入删除元素方便。
    *   **缺点**：当 n 很大时，查找效率极低。

*   **适用场景**：表中的元素数量较少，或者元素本身是无序的。

---

### 2. #折半查找 (Binary Search) #折半查找法（二分查找）  [[二分查找]]

也称为二分查找，就是原题中考察的方法。

*   **核心思想**：通过不断将查找范围缩小一半来快速定位目标。是一种分治策略。

*   **前提条件**：**表必须是有序的**。

*   **执行步骤**：
    1.  设置查找区间的左右指针 `low` 和 `high`。
    2.  计算中间位置 `mid = (low + high) / 2`。
    3.  将 `L[mid]` 与目标值 `key` 比较：
        *   若 `L[mid] == key`，查找成功。
        *   若 `key < L[mid]`，说明目标在左半部分，更新 `high = mid - 1`。
        *   若 `key > L[mid]`，说明目标在右半部分，更新 `low = mid + 1`。
    4.  重复步骤 2 和 3，直到 `low > high`，此时表示查找失败。

*   **时间复杂度**：
    *   **最好情况**：O(1) - 中间元素就是目标。
    *   **最坏/平均情况**：**O(log n)** - 每次都将问题规模减半。

*   **优缺点**：
    *   **优点**：查找效率极高。
    *   **缺点**：要求表必须有序。如果表是动态的，频繁的插入和删除操作会破坏有序性，维护成本很高。

*   **适用场景**：适用于不经常变动（静态）的大型有序表。

---

### 3. 插值查找 (Interpolation Search)

这是折半查找的一种优化。

*   **核心思想**：折半查找每次都从“中间”分开，而插值查找则根据**目标值在整个查找范围内的“可能”位置**来动态选择分割点。它假设元素是**均匀分布**的。

*   **前提条件**：**表必须有序**，且表中元素**分布比较均匀**。

*   **执行步骤**：与折半查找类似，但 `mid` 的计算公式不同：
    `mid = low + (high - low) * (key - L[low]) / (L[high] - L[low])`
    这个公式的直观理解是：如果 `key` 的值更接近 `L[low]`，那么 `mid` 就会更偏向 `low`；反之亦然。就像查字典，如果要找 "b" 开头的词，你不会从中间翻开，而是会从靠前的位置翻。

*   **时间复杂度**：
    *   **最好/平均情况**：**O(log log n)** - 在数据均匀分布时，收敛速度比 O(log n) 更快。
    *   **最坏情况**：**O(n)** - 当数据分布极不均匀时（例如指数分布），性能会退化为顺序查找。

*   **优缺点**：
    *   **优点**：在数据均匀分布的情况下，效率高于折半查找。
    *   **缺点**：对于分布不均的数据，性能不稳定且可能很差。计算 `mid` 的开销也比折半查找大。

*   **适用场景**：表长、关键字分布均匀的有序表。

---

### 4. 分块查找 (Block Search)

也称为索引顺序查找 (Indexed Sequential Search)，是顺序查找和折半查找的折中。

*   **核心思想**：将整个表分成若干“块”（Block），并为每个块建立一个“索引项”。索引项通常包含该块内最大的关键字和该块的起始地址。

*   **前提条件**：要求“**块间有序，块内可以无序**”。即，第 `i` 块中的所有元素都必须小于第 `i+1` 块中的所有元素。

*   **执行步骤**：
    1.  **查索引**：在索引表中使用折半查找（或顺序查找）来确定目标 `key` 应该在哪个块中。
    2.  **块内查找**：定位到目标块后，在该块内部使用**顺序查找**来找到 `key`。

*   **时间复杂度**：介于 O(n) 和 O(log n) 之间。如果表长为 n，分为 b 块，每块 s 个元素 (n=b*s)，则其复杂度大约为 `O(log b + s)`（索引表用折半查找）或 `O(b + s)`（索引表用顺序查找）。

*   **优缺点**：
    *   **优点**：效率介于顺序和折半之间，对动态插入删除操作比折半查找更友好（通常只需要调整一个块）。
    *   **缺点**：需要额外的空间来存储索引表，实现也更复杂。

*   **适用场景**：表很大，但又需要频繁进行动态插入、删除操作的场景。

### 总结对比

| 查找方法 | 前提条件 | 平均时间复杂度 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **顺序查找** | 无要求 | O(n) | 实现简单，无需排序 | 效率低 |
| **折半查找** | **必须有序** | O(log n) | 效率极高 | 要求有序，维护成本高 |
| **插值查找** | **有序**且**均匀分布** | O(log log n) | 均匀数据下效率最高 | 数据分布不均时性能差 |
| **分块查找** | **块间有序** | 介于O(log n)和O(n)之间 | 效率和灵活性折中 | 需额外索引空间，实现复杂 |
