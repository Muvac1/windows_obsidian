1. #表达式树
  *   任何一个表达式都可以用一棵二叉树来表示。叶子节点是操作数，非叶子节点是操作符。
    *   对表达式树进行不同的遍历可以得到不同的表达式形式：
        *   **中序遍历 (In-order Traversal)** 得到中缀表达式（可能需要加括号）。
        *   **后序遍历 (Post-order Traversal)** 得到后缀表达式。
        *   **前序遍历 (Pre-order Traversal)** 得到前缀表达式。
    *   **考点:** 可能会要求根据给定的中缀或后缀表达式构建表达式树，或者根据表达式树写出三种形式的表达式。
好的，我们来深入讲解一下 **表达式树 (Expression Tree)** 这个重要的知识点。

### 1. 什么是表达式树？

表达式树是一种二叉树，它用来直观地表示一个数学表达式的结构。它有两个基本规则：

*   **叶子节点 (Leaf Nodes):** 存放**操作数** (Operands)，比如数字 `6`, `5` 或者变量 `a`, `b`。
*   **非叶子节点 (Internal Nodes):** 存放**操作符** (Operators)，比如 `+`, `-`, `*`, `/`。每个操作符节点的子节点是它的操作数。

**例：** 中缀表达式 `(3 + 4) * 5` 可以表示为下面这棵树：

```
      *
     / \
    +   5
   / \
  3   4
```

**为什么表达式树很有用？**
因为它**消除了歧义**。在中缀表达式中，我们需要用括号和运算符优先级来确定运算顺序。但在表达式树中，运算顺序由树的结构唯一确定：**一个运算（父节点）必须在它的所有操作数（子节点）都准备好之后才能进行**。

### 2. 表达式树的遍历与三种表达式形式

对这棵树进行不同的遍历，就可以得到我们之前提到的三种表达式。我们以上面的 `(3 + 4) * 5` 这棵树为例。

#### A. 后序遍历 (Post-order Traversal) -> 后缀表达式

*   **规则:** 先遍历**左子树**，再遍历**右子树**，最后访问**根节点** (Left -> Right -> Root)。
*   **过程:**
    1.  从根节点 `*` 开始，先看左子树 `+`。
    2.  在 `+` 子树中，先看它的左子树 `3`。`3`是叶子节点，访问它，输出 **`3`**。
    3.  再看 `+` 子树的右子树 `4`。`4`是叶子节点，访问它，输出 **`4`**。
    4.  最后访问 `+` 子树的根节点，输出 **`+`**。
    5.  现在 `*` 的左子树遍历完了。接着看 `*` 的右子树 `5`。`5`是叶子节点，访问它，输出 **`5`**。
    6.  最后访问整个树的根节点 `*`，输出 **`*`**。
*   **结果:** `3 4 + 5 *`
    *   这正是我们熟悉的后缀表达式。

#### B. 前序遍历 (Pre-order Traversal) -> 前缀表达式

*   **规则:** 先访问**根节点**，再遍历**左子树**，最后遍历**右子树** (Root -> Left -> Right)。
*   **过程:**
    1.  从根节点 `*` 开始，访问它，输出 **`*`**。
    2.  然后看左子树 `+`。访问它的根节点，输出 **`+`**。
    3.  再看 `+` 的左子树 `3`，输出 **`3`**。
    4.  再看 `+` 的右子树 `4`，输出 **`4`**。
    5.  `*` 的左子树遍历完了。接着看 `*` 的右子树 `5`，输出 **`5`**。
*   **结果:** `* + 3 4 5`
    *   这就是前缀表达式（也叫波兰表达式）。

#### C. 中序遍历 (In-order Traversal) -> 中缀表达式

*   **规则:** 先遍历**左子树**，再访问**根节点**，最后遍历**右子树** (Left -> Root -> Right)。
*   **过程:**
    1.  从根节点 `*` 开始，先看左子树 `+`。
    2.  在 `+` 子树中，先看它的左子树 `3`，输出 **`3`**。
    3.  然后访问 `+` 子树的根节点，输出 **`+`**。
    4.  再看 `+` 子树的右子树 `4`，输出 **`4`**。
    5.  `*` 的左子树遍历完了。现在访问根节点 `*`，输出 **`*`**。
    6.  最后看 `*` 的右子树 `5`，输出 **`5`**。
*   **结果:** `3 + 4 * 5`
    *   **注意一个问题！** 这个结果 `3 + 4 * 5` 按正常的运算优先级是 `3 + 20 = 23`，而我们原始的表达式 `(3 + 4) * 5` 的结果是 `7 * 5 = 35`。
    *   **结论：** 为了保持正确的运算顺序，**中序遍历在还原表达式时，如果一个子树的根是操作符，那么在遍历完这个子树后需要给它的结果加上括号**。
    *   **修正后的遍历过程：** 遍历 `+` 子树时，得到 `3 + 4`，因为它的根是操作符，所以给它加上括号，变成 **`(3 + 4)`**。然后再访问根 `*` 和右子树 `5`。
*   **正确结果:** `(3 + 4) * 5`

---

### 3. 如何构建表达式树 (考点)

从后缀表达式构建表达式树是最简单直接的，因为它没有优先级和括号的困扰。算法同样需要使用**栈**，但这次栈里存放的是**树的节点 (Node)**。

**算法：从后缀表达式构建表达式树**

1.  **初始化：** 创建一个空的**节点栈**。
2.  **扫描：** 从左到右遍历后缀表达式的每一个元素。
3.  **判断：**
    *   如果当前元素是**操作数**：创建一个新的**叶子节点**，并将其压入栈中。
    *   如果当前元素是**操作符**：
        a.  创建一个新的**内部节点** (根为该操作符)。
        b.  从栈中弹出一个节点，作为新节点的**右子节点**。
        c.  再从栈中弹出一个节点，作为新节点的**左子节点**。
        d.  将这个新创建的子树的根节点压回栈中。
4.  **结束：** 遍历完成后，栈中只会剩下一个节点，它就是整个表达式树的根节点。

#### 例题演示: 根据后缀表达式 $6\;5\;2\;3\;+\;8\;*\;+\;3\;+\;*$ 构建表达式树

**表达式:** `6 5 2 3 + 8 * + 3 + *`

| 步骤 | 扫描元素 | 操作 | 节点栈的状态 (栈底 -> 栈顶) |
| :--- | :---: | :--- | :--- |
| 1-4 | `6,5,2,3` | 创建叶子节点，压栈 | `[Node(6), Node(5), Node(2), Node(3)]` |
| 5 | **+** | 弹出`3`,`2`，创建`+`树，压栈 | `[Node(6), Node(5), Node(+)]` (其中`+`的左右子为`2`,`3`) |
| 6 | **8** | 创建叶子节点，压栈 | `[Node(6), Node(5), Node(+), Node(8)]` |
| 7 | **\*** | 弹出`8`,`Node(+)`，创建`*`树，压栈 | `[Node(6), Node(5), Node(*)]` (其中`*`的左右子为`+`,`8`) |
| 8 | **+** | 弹出`Node(*)`,`5`，创建`+`树，压栈 | `[Node(6), Node(+)]` (其中`+`的左右子为`5`,`*`) |
| 9 | **3** | 创建叶子节点，压栈 | `[Node(6), Node(+), Node(3)]` |
| 10 | **+** | 弹出`3`,`Node(+)`，创建`+`树，压栈 | `[Node(6), Node(+)]` (其中`+`的左右子为旧的`+`树, `3`) |
| 11 | **\*** | 弹出`Node(+)`,`6`，创建`*`树，压栈 | `[Node(*)]` (其中`*`的左右子为`6`, 最后的`+`树) |

扫描结束，栈中唯一的元素就是整棵树的根。这棵树的结构如下：

```
           *
          / \
         6   +
            / \
           +   3
          / \
         5   *
            / \
           +   8
          / \
         2   3
```

**验证 (考点):**

*   **后序遍历这棵树:** 你会得到 `6 5 2 3 + 8 * + 3 + *` (原始后缀表达式)。
*   **中序遍历这棵树 (加括号):** 你会得到 `(6 * ((5 + ((2 + 3) * 8)) + 3))` (原始中缀表达式)。
*   **前序遍历这棵树:** 你会得到 `* 6 + + 5 * + 2 3 8 3` (对应的前缀表达式)。

### 总结

*   **表达式树**是表达式的结构化表示，没有歧义。
*   **后序遍历** -> **后缀表达式** (最自然、最常用)。
*   **前序遍历** -> **前缀表达式**。
*   **中序遍历** -> **中缀表达式** (需要注意添加括号以保持原意)。
*   使用**栈**可以非常方便地**从后缀表达式构建表达式树**，这个算法是理解和应用表达式树的关键。