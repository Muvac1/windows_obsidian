#前缀编码与二叉树 
前缀编码可以非常直观地用二叉树来表示。
*   从根节点出发，向左的分支代表 `0`，向右的分支代表 `1`。
*   每一个码字都对应从根节点到树上某个节点的一条路径。
*   **一个编码方案是前缀编码的充要条件是：所有码字对应的节点都是树的叶子节点。**

如果某个码字对应的节点是一个非叶子节点（即它还有子节点），那么这个码字的路径就是通往其子孙节点路径的前缀，这就违反了前缀编码的规则。

让我们用二叉树来验证选项 D：
*   `0`: 根 -> 左 (这是一个码字)
*   `100`: 根 -> 右 -> 左 -> 左 (这是一个码字)
*   `110`: 根 -> 右 -> 右 -> 左 (这是一个码字)
*   `1110`: 根 -> 右 -> 右 -> 右 -> 左 (这是一个码字)
*   `1100`: 根 -> 右 -> 右 -> 左 -> 左 (这是一个码字)

画出这棵树（部分）：
```
      (root)
      /    \
     0*     1
           / \
          0   1
         /   / \
        0   0*  1
       /       / \
      *       0*  1
             /
            0*
```
（带 `*` 的是码字对应的节点）

我们可以看到，码字 `110` 对应的节点（根->右->右->左）不是叶子节点，它还有一个代表 `0` 的左孩子，这个孩子最终构成了码字 `1100`。因此，`110` 是 `1100` 的前缀，该编码方案不是前缀编码。