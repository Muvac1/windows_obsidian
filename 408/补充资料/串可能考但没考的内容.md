![[Pasted image 20251216055837.png]]

### 知识点一：时间复杂度分析

**题目 1：**
在 KMP 算法和 Boyer-Moore (BM) 算法中，我们都需要预处理模式串 $P$（长度为 $m$）。请问：
1.  构造 KMP 算法的 `next` 表的时间复杂度是多少？
2.  构造 BM 算法中的 `ss` 表（Suffix Size）和 `gs` 表（Good Suffix）的时间复杂度分别是多少？

**【解答】**
1.  **KMP `next` 表：** 时间复杂度为 **$O(m)$**。利用递推关系，只需对模式串 $P$ 进行一次线性扫描即可求出所有位置的 `next` 值。
2.  **BM `ss` 表和 `gs` 表：**
    *   构造 `ss` 表的最优时间复杂度为 **$O(m)$**。虽然暴力构造是 $O(m^2)$，但通过类似 Z-algorithm 或扩展 KMP 的逻辑，可以在线性时间内完成。
    *   构造 `gs` 表的时间复杂度为 **$O(m)$**。`gs` 表是基于 `ss` 表生成的，只需要对 `ss` 表进行两次线性扫描（一次处理整个后缀匹配的情况，一次处理部分后缀匹配的情况）即可完成。

---

### 知识点二：具体的 ss 表和 gs 表构造

**题目 2：**
给定模式串 $P = \text{"BCABAB"}$（下标从 0 开始），请手动计算该串的 `ss` 表（Suffix Size table）。
*提示：`ss[i]` 定义为子串 $P[0 \dots i]$ 与整个模式串 $P$ 的最长公共后缀长度。*

**【解答】**
模式串 $P$: `B C A B A B`，长度 $m=6$。

*   **i = 5 (`BCABAB`):** 显然与自身的最长公共后缀是自身，长度为 6。$\rightarrow ss[5] = 6$
*   **i = 4 (`BCABA`):** 末尾是 `A`，模式串末尾是 `B`，不匹配。$\rightarrow ss[4] = 0$
*   **i = 3 (`BCAB`):** 末尾 `AB` 与模式串末尾 `AB` 匹配，再往前 `C` 与 `B` 不匹配。$\rightarrow ss[3] = 2$
*   **i = 2 (`BCA`):** 末尾 `A` 与模式串末尾 `B` 不匹配。$\rightarrow ss[2] = 0$
*   **i = 1 (`BC`):** 末尾 `C` 与模式串末尾 `B` 不匹配。$\rightarrow ss[1] = 0$
*   **i = 0 (`B`):** 末尾 `B` 与模式串末尾 `B` 匹配。$\rightarrow ss[0] = 1$

**结果：** `ss` 表为 `[1, 0, 0, 2, 0, 6]`。

*(注：`gs` 表的构造依赖于 `ss` 表，通常考试中考察 `ss` 表的概率较大，因为它是理解 `gs` 的基础)*

---

### 知识点三：01 串下的 KMP 与 仅含 bc 表的 BM 比较

**题目 3：**
假设字符集仅由 0 和 1 组成（即二进制串）。在此情况下，比较 KMP 算法与**仅使用坏字符规则（bc 表）**的 BM 算法在最坏情况下的性能，并解释原因。

**【解答】**
*   **结论：** KMP 算法性能优于仅使用 `bc` 表的 BM 算法。
*   **原因分析：**
    *   **KMP 算法：** 无论字符集大小如何，KMP 的最坏时间复杂度稳定在 $O(n)$（$n$ 为文本串长度），因为它保证主串指针不回退。
    *   **仅 bc 表的 BM 算法：** 坏字符规则的核心在于将模式串向右移动，移动距离取决于坏字符在模式串中上一次出现的位置。在 01 串中，字符集 $|\Sigma|=2$ 非常小。
        *   当发生失配时，坏字符要么是 '0' 要么是 '1'。
        *   由于字符集极小，这个“坏字符”极大概率就出现在当前对齐位置的非常靠近右侧的地方（或者就是前一个字符）。
        *   这导致模式串每次可能只能向右移动 1 位或很少的位数，无法发挥 BM 算法“大跳跃”的优势。
        *   此时算法退化为接近朴素匹配算法，时间复杂度趋近于 $O(n \times m)$。

---

### 知识点四：为什么不倾向于使用二维的 bc 表（重点，结合图片内容）

**题目 4：**
在 BM 算法中，标准的坏字符规则（bc）使用一维数组 `bc['x']` 记录字符 'x' 在模式串中最靠右出现的位置。
针对“坏字符在模式串当前位置 $j$ 的右侧，导致位移量为负”的情况，有人提出了一种改进方案：
*构造一个二维表 `bc[j]['x']`，记录在模式串下标 $j$ 的**左侧**，最靠右的字符 'x' 的位置。*

请结合图片中的【解答】思路，回答：**为什么在实际应用中，我们通常不倾向于使用这种二维 `bc` 表的方法？**

**【解答】**
根据图片内容，主要有以下三个原因，其中第三点最为关键：

1.  **逻辑复杂化：** 虽然预处理时间和空间增长不大（$m \times |\Sigma|$），但这会使匹配算法的逻辑控制变得更加复杂。
2.  **空间成本：** 尽管增长“不大”，但相比一维表，二维表仍然增加了额外的空间开销。
3.  **核心原因（最重要）：** **`gs` 表（好后缀规则）的完全替代性。**
    *   如果这个二维 `bc` 表能发挥作用（即产生较大的正向移动），前提条件通常是当前已经匹配了较长的后缀（好后缀）。
    *   当“好后缀”很长时，BM 算法中的另一个核心规则——**`gs` 表（好后缀规则）通常能提供比坏字符规则更大或相等的位移量**。
    *   在这种情况下，`gs` 表完全可以替代这个复杂的二维 `bc` 表的功能，因此引入二维表的性价比极低。

---

### 知识点五：KR 算法的指纹碰撞概率

**题目 5：**
在使用 Karp-Rabin (KR) 算法进行字符串匹配时，假设散列表容量（模数）为 $M$，且满足“各字符皆独立且均匀分布”的假定条件。请问指纹（Hash值）发生碰撞（即不同字符串产生相同 Hash 值）的可能性是多少？

**【解答】**
**$1/M$**。
在理想的“独立且均匀分布”假设下，任意两个不同字符串的 Hash 值碰撞的概率等于散列表地址空间大小的倒数，即 $1/M$。这也是为什么 KR 算法在实际应用中需要选取较大的素数作为 $M$ 以降低误判率的原因。

