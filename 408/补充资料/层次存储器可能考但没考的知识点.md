![[Pasted image 20251216213602.png]]


### 知识点一：综合题（TLB、页表、Cache 内容结合）
**考查点：** 虚拟地址到物理地址的转换流程，以及TLB、Page Table、Cache的协同工作。

**【习题】**
假设某系统采用**页式存储**，虚拟地址为 16 位，物理地址为 14 位，页面大小为 4KB。Cache 采用**2路组相联**映射，块大小为 16 字节，Cache 总共有 8 组（Set）。
TLB 采用全相联映射。

当前系统状态如下：
1.  **TLB 内容（部分）：**
    | Valid | Tag (VPN) | PPN |
    | :--- | :--- | :--- |
    | 1 | 0x2 | 0x1 |
    | 1 | 0x5 | 0x3 |

2.  **Cache 内容（部分，仅列出Set 0和Set 4）：**
    *   Set 0, Line 0: Valid=1, Tag=0x04, Data=...
    *   Set 0, Line 1: Valid=0, ...
    *   Set 4, Line 0: Valid=1, Tag=0x04, Data=[0x11, 0x22, 0x33, 0x44...]
    *   Set 4, Line 1: Valid=1, Tag=0x05, Data=...

**问题：**
CPU 发出虚拟地址 `0x2040` 读取数据。
1.  计算该地址的 VPN（虚页号）和 Offset（页内偏移）。
2.  TLB 是否命中？如果命中，物理地址（PA）是多少？
3.  Cache 是否命中？请写出 Cache 的组索引（Index）和标记（Tag）。
4.  若命中，读取到的数据（第一个字节）假设为 Cache Line 中的首字节，请问是多少？

**【解析】**
1.  **地址分解：**
    *   页面大小 4KB = $2^{12}$，所以 Offset 占低 12 位。
    *   虚拟地址 16 位，VPN 占高 4 位。
    *   `0x2040` = `0010 0000 0100 0000` (二进制)。
    *   **VPN** = `0010` = **0x2**。
    *   **Offset** = `0000 0100 0000` = **0x040**。

2.  **TLB 查找：**
    *   查找 TLB 中 Tag 为 0x2 的项。
    *   表中存在 Tag=0x2 且 Valid=1 的项，PPN=0x1。
    *   **TLB 命中**。
    *   物理地址 PA = PPN + Offset = `0x1` 拼接 `0x040` = **0x1040**。

3.  **Cache 查找：**
    *   PA = `0x1040` = `01 0000 0100 0000` (14位)。
    *   Cache 参数：块大小 16B ($2^4$) $\rightarrow$ 字节偏移占 4 位。
    *   组数 8 ($2^3$) $\rightarrow$ Index 占 3 位。
    *   PA 分解：
        *   Byte Offset (4位): `0000` (末尾)
        *   Index (3位): `100` (即 **4**)
        *   Tag (剩余位): `0100000` $\rightarrow$ `001 0000` (即 **0x10**，也就是十进制16，或者看作高7位)。 *修正：让我们仔细算一下Tag位数*
        *   PA总共14位。Offset 4位，Index 3位，Tag = 14 - 4 - 3 = 7位。
        *   PA = `00 0100 0001 0000` (二进制，0x1040)
        *   Byte Offset = `0000` (0x0)
        *   Index = `100` (0x4)
        *   Tag = `0001000` = **0x08** (注意：这里要非常小心二进制拆分，0x1040 = 01 0000 0100 0000。低4位0，接下来的3位是100(4)，剩下的高位是0010000(0x10)？不对，0x1040二进制是 `01 0000 0100 0000`。
        *   重算：
            *   Addr: `01 0000 0100 0000`
            *   Byte Off (4 bit): `0000`
            *   Index (3 bit): `100` (即 Set 4)
            *   Tag (7 bit): `0100000` (即 **0x20** ? 不对，是 `0010000` = 0x10 吗？
            *   让我们把14位完整写出来： `01 0000 0100 0000`。
            *   [13:7] Tag, [6:4] Index, [3:0] Offset.
            *   Index = bit 4,5,6 = `100` = 4。
            *   Tag = bit 7~13 = `0100000` = **0x20** (32)。
    *   查看 Set 4 的内容：
        *   Line 0: Tag=0x04 (不匹配 0x20)。
        *   Line 1: Tag=0x05 (不匹配 0x20)。
    *   **结论：Cache 不命中 (Miss)。**

    *(注：如果题目给出的 Cache Tag 是 0x20，则命中。题目数据中 Set 4 的 Tag 分别是 0x04 和 0x05，故不命中。此题重点在于计算流程)*

---

### 知识点二：二重循环与 Cache 命中率
**考查点：** 空间局部性（Spatial Locality）对 Cache 性能的影响，行优先 vs 列优先存储。

**【习题】**
C语言中数组按**行优先**存储。设有二维数组 `int A[1024][1024]`，Cache 块大小为 64 字节，整数（int）占 4 字节。Cache 总容量远小于数组大小。
现有两个程序段：

**程序段 I:**
```c
for(int i = 0; i < 1024; i++)
    for(int j = 0; j < 1024; j++)
        sum += A[i][j];
```

**程序段 II:**
```c
for(int j = 0; j < 1024; j++)
    for(int i = 0; i < 1024; i++)
        sum += A[i][j];
```

**问题：**
假设初始 Cache 为空，忽略变量 i, j, sum 的访问，仅考虑数组 A 的访问。请分别计算程序段 I 和程序段 II 的 Cache 缺失率（Miss Rate）。

**【解析】**
1.  **分析块大小：**
    Cache Block = 64B。每个 int = 4B。
    一个 Block 可以容纳 $64 / 4 = 16$ 个数组元素。
2.  **程序段 I (按行访问 `A[i][j]`):**
    *   访问顺序：A[0][0], A[0][1], ... A[0][15], A[0][16]...
    *   当访问 A[0][0] 时，Cache Miss，将 A[0][0]~A[0][15] 调入 Cache。
    *   接下来的 15 次访问（A[0][1]~A[0][15]）全部命中。
    *   模式：1 次 Miss，15 次 Hit。
    *   **缺失率 = 1 / 16 = 6.25%**。
3.  **程序段 II (按列访问 `A[i][j]` - 内层循环变 i):**
    *   访问顺序：A[0][0], A[1][0], A[2][0]...
    *   A[0][0] 在内存地址 N，A[1][0] 在内存地址 $N + 1024 \times 4$。
    *   由于数组很大（1024行），A[0][0] 和 A[1][0] 相距甚远，不在同一个 Cache Block 中。
    *   每访问一个元素，都跳到了下一行，导致之前的块不仅没被利用，甚至可能因为 Cache 容量不足（Conflict Miss）被替换掉。
    *   每次访问都需要调入新的块。
    *   **缺失率 = 100%** (假设 Cache 无法容纳整列数据，发生抖动)。

---

### 知识点三：影响命中率的因素
**考查点：** Cache 参数与性能的关系。

**【习题】**
下列关于 Cache 参数对命中率影响的描述，哪一项是**错误**的？并说明理由。
A. 增加 Cache 的总容量通常会提高命中率。
B. 增加 Cache 的关联度（Associativity）通常会降低冲突缺失（Conflict Miss）。
C. 增加 Cache 块（Block）的大小一定会提高命中率。
D. 替换算法（如 LRU vs FIFO）会影响命中率。

**【解析】**
*   **答案：C**。
*   **理由：** 增加块大小利用了空间局部性，通常能提高命中率。但是，如果块太大：
    1.  Cache 中的总块数（行数）会减少，导致**冲突缺失**增加。
    2.  大块调入时可能包含许多未被使用的数据（“数据污染”），挤占了有用数据的位置。
    由此可能导致命中率反而下降（出现“Cache 污染”现象）。

---

### 知识点四：Cache 接入系统的方法
**考查点：** 隔断法（Look-through）与侧接法（Look-aside）的区别。

**【习题】**
设 CPU 执行一次存储器读操作，Cache 的访问时间为 $t_c$，主存的访问时间为 $t_m$。
1.  **侧接法（Look-aside/Parallel）：** CPU 同时向 Cache 和主存发请求。
2.  **隔断法（Look-through/Serial）：** CPU 先向 Cache 发请求，若不命中再向主存发请求。

**问题：**
请分别写出在 Cache **命中**和**不命中**两种情况下，两种接入方式所需的访问时间（忽略总线延迟）。

**【解析】**
1.  **侧接法（Look-aside）：**
    *   **命中：** CPU 拿到 Cache 数据即停止主存请求。时间 = $t_c$。
    *   **不命中：** CPU 等待主存完成。由于是同时发出的请求，时间 = $t_m$。
2.  **隔断法（Look-through）：**
    *   **命中：** 直接从 Cache 读取。时间 = $t_c$。
    *   **不命中：** 先查 Cache ($t_c$)，发现没有，再查主存 ($t_m$)。总时间 = $t_c + t_m$。

*注：隔断法的优点是降低了系统总线的负担（命中时不需要占用总线），但缺失损失（Miss Penalty）较大。*

---

### 知识点五：DRAM 刷新相关问题
**考查点：** 刷新周期、死区时间计算。

**【习题】**
某 DRAM 芯片容量为 $4M \times 8$位，内部存储阵列为 $2048 \times 2048$（即有 2048 行）。规定刷新周期为 2ms。存取周期（读写周期）为 0.5$\mu s$。
请计算在以下两种刷新方式下的相关指标：
1.  **集中刷新：** “死时间”（CPU 无法访问存储器的时间）是多少？
2.  **分散刷新：** 假设将存取周期延长一倍，前半段读写，后半段刷新。这种方式的优点和缺点是什么？

**【解析】**
1.  **集中刷新：**
    *   需要在 2ms 内刷新完所有 2048 行。
    *   集中刷新是指在 2ms 的最后时段集中进行。
    *   刷新一行需要 1 个存取周期（或专门的刷新周期），即 0.5$\mu s$。
    *   总刷新时间 = $2048 \times 0.5 \mu s = 1024 \mu s = 1.024 ms$。
    *   **死时间 = 1.024 ms** （在2ms周期内，有一半多的时间 CPU 不能用内存，效率极低）。

2.  **分散刷新（Distributed/Interleaved）：**
    *   做法：将周期变为 $0.5 \times 2 = 1 \mu s$。前 0.5$\mu s$ 给 CPU 读写，后 0.5$\mu s$ 用于刷新一行。
    *   **优点：** 没有死区时间（CPU 永远不会被阻塞）。
    *   **缺点：** 存取周期变长了（系统变慢），且 $2048 \times 1 \mu s = 2.048 ms$，虽然这里刚好能满足刷新要求，但一般来说这种方式会导致刷新过于频繁，浪费功率。
    *   *(通常考试更常考“异步刷新/分布刷新”，即每隔 $2ms / 2048 \approx 1 \mu s$ 插入一次刷新，死时间分散)*。

---

### 知识点六：TLB、页表、Cache 命中的 8 种情况
**考查点：** 理解图片底部的真值表，特别是“不可能”的情况。

**【习题】**
根据图片中的表格，分析以下两种情况是否可能发生，并说明理由。
1.  **情况 A：** TLB 命中，页表不命中，Cache 命中。
2.  **情况 B：** TLB 不命中，页表不命中，Cache 命中。

**【解析】**
1.  **情况 A (TLB hit, PT miss, Cache hit)：**
    *   **不可能**。
    *   **理由：** TLB 是页表（Page Table）的高速缓存，是页表的**子集**。如果 TLB 中有该页面的表项（TLB 命中），说明该页表项一定存在且有效（Valid）。因此页表不可能显示“不命中”（即缺页）。
    *   *(注：除非是硬件一致性错误，否则逻辑上讲不通)*。

2.  **情况 B (TLB miss, PT miss, Cache hit)：**
    *   **不可能**。
    *   **理由：**
        *   “页表不命中”意味着发生了**缺页中断 (Page Fault)**，数据不在主存中，而在硬盘（Swap区）里。
        *   Cache 中的数据是主存数据的副本。如果数据连主存里都没有，怎么可能在 Cache 里？
        *   Cache 采用物理地址索引（通常 VIPT 或 PIPT），必须先得到物理地址。缺页导致无法得到物理地址，自然无法在 Cache 中找到有效数据。