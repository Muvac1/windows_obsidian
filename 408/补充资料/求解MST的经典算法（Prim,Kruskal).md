#求解MST的经典算法

求解MST的算法都是基于 #贪心策略 (Greedy Strategy)  的，幸运的是，对于MST问题，贪心策略可以得到全局最优解。最著名的两个算法是 **Prim算法** 和 **Kruskal算法**。

#### A. #Prim算法 (普里姆算法)

*   **核心思想**: “**加点法**”。从一个点开始，不断地把离当前这棵“小树”最近的点和边加进来，逐步扩大树的规模，直到覆盖所有顶点。
*   **好比**: 你已经在村庄A建立了基站，现在要选一个离A最近的村庄B连进来。现在A和B都连通了，你再从所有“已连通村庄”出发，找一个离它们最近的“未连通村庄”C连进来，以此类推。
*   **执行步骤**:
    1.  任意选择一个顶点作为起始点，加入集合 `U` (表示已在MST中的顶点)。
    2.  重复 `V-1` 次（V是顶点总数）：
        a. 找到一条权重最小的边 `(u, v)`，其中 `u` 在集合 `U` 中，而 `v` 不在 `U` 中。
        b. 将顶点 `v` 加入集合 `U`，将边 `(u, v)` 加入最小生成树。
*   **适合场景**: **稠密图**（边的数量接近顶点数量的平方）。
*   **实现**: 通常使用 #优先队列（最小堆） 来优化查找最小边的过程。

#### B. #Kruskal算法 (克鲁斯卡尔算法)

*   **核心思想**: “**加边法**”。将所有边按权重从小到大排序，然后依次考察每一条边。如果这条边连接的两个顶点当前不连通，就采纳这条边；否则，就放弃它（因为它会形成环路）。
*   **好比**: 你是项目经理，有一张包含所有可能的光缆铺设计划和成本的清单。你从成本最低的计划开始审批，只要这个计划不会造成网络冗余（形成环），就批准施工。
*   **执行步骤**:
    1.  将图中所有的边按照权重从小到大排序。
    2.  初始化一个空的MST。
    3.  遍历排序后的边列表：
        a. 取出当前权重最小的边 `(u, v)`。
        b. **检查** `u` 和 `v` 是否已经连通。如果它们不连通，则：
            i.  将这条边加入MST。
            ii. 记录 `u` 和 `v` 现在已经连通了。
        c. 如果 `u` 和 `v` 已经连通，则跳过这条边。
    4.  当MST中有 `V-1` 条边时，算法结束。
*   **核心技术**: 如何高效地检查两个顶点是否连通？答案是使用 #并查集 (Disjoint Set Union, DSU)  数据结构。
*   **适合场景**: **稀疏图**（边的数量远小于顶点数量的平方），因为算法效率主要取决于边的排序。

#### 算法对比
#普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法的特点 

| 特性       | Prim 算法    | Kruskal 算法              |
| :------- | :--------- | :---------------------- |
| **策略**   | 从点出发，逐步扩张  | 从边出发，连接各个部分             |
| **数据结构** | 优先队列（最小堆）  | 并查集 + 排序                |
| **复杂度**  | O(E log V) | O(E log E) 或 O(E log V) |
| **适用图**  | 稠密图        | 稀疏图                     |
| **过程**   | 始终保持一个连通的树 | 开始时是森林，最后合成一棵树          |
*   **Kruskal:** 时间复杂度主要取决于对边的排序，为 $O(E \log E)$，其中 $E$ 是边数。它更适合**稀疏图**（边数 $E$ 远小于 $V^2$）。
*   **Prim:**
	*   使用邻接矩阵实现：$O(V^2)$。
	*   使用优先队列（最小堆）优化：$O(E \log V)$。
	*   Prim算法的 $O(V^2)$ 版本适合**稠密图**（边数 $E$ 接近 $V^2$）。
