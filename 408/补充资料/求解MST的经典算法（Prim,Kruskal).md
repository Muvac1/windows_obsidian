#求解MST的经典算法

求解MST的算法都是基于 #贪心策略 (Greedy Strategy)  的，幸运的是，对于MST问题，贪心策略可以得到全局最优解。最著名的两个算法是 **Prim算法** 和 **Kruskal算法**。

#### A. #Prim算法 (普里姆算法) 

*   **核心思想**: “**加点法**”。从一个点开始，不断地把离当前这棵“小树”最近的点和边加进来，逐步扩大树的规模，直到覆盖所有顶点。
*   **好比**: 你已经在村庄A建立了基站，现在要选一个离A最近的村庄B连进来。现在A和B都连通了，你再从所有“已连通村庄”出发，找一个离它们最近的“未连通村庄”C连进来，以此类推。
*   **执行步骤**:
    1.  任意选择一个顶点作为起始点，加入集合 `U` (表示已在MST中的顶点)。
    2.  重复 `V-1` 次（V是顶点总数）：
        a. 找到一条权重最小的边 `(u, v)`，其中 `u` 在集合 `U` 中，而 `v` 不在 `U` 中。
        b. 将顶点 `v` 加入集合 `U`，将边 `(u, v)` 加入最小生成树。
*   **适合场景**: **稠密图**（边的数量接近顶点数量的平方）。
*   **实现**: 通常使用 #优先队列（最小堆） 来优化查找最小边的过程。
	*  [[斐波那契查找（Fibonacci查找）]]  优化 Prim 算法，时间复杂度是多少？  
		* 使用斐波那契堆优化后，Prim 算法的时间复杂度可以降低到$O(e+n\log n)$。在超大规模的稀疏图中，理论上这比二叉堆优化版$O(e\log n)$更快，但在实际工程中由于斐波那契堆常数较大且实现复杂，并不常用。
	

#### B. #Kruskal算法 (克鲁斯卡尔算法)

*   **核心思想**: “**加边法**”。将所有边按权重从小到大排序，然后依次考察每一条边。如果这条边连接的两个顶点当前不连通，就采纳这条边；否则，就放弃它（因为它会形成环路）。
*   **好比**: 你是项目经理，有一张包含所有可能的光缆铺设计划和成本的清单。你从成本最低的计划开始审批，只要这个计划不会造成网络冗余（形成环），就批准施工。
*   **执行步骤**:
    1.  将图中所有的边按照权重从小到大排序。
    2.  初始化一个空的MST。
    3.  遍历排序后的边列表：
        a. 取出当前权重最小的边 `(u, v)`。
        b. **检查** `u` 和 `v` 是否已经连通。如果它们不连通，则：
            i.  将这条边加入MST。
            ii. 记录 `u` 和 `v` 现在已经连通了。
        c. 如果 `u` 和 `v` 已经连通，则跳过这条边。
    4.  当MST中有 `V-1` 条边时，算法结束。
*   **核心技术**: 如何高效地检查两个顶点是否连通？答案是使用 #并查集 (Disjoint Set Union, DSU)  数据结构。
*   **适合场景**: **稀疏图**（边的数量远小于顶点数量的平方），因为算法效率主要取决于边的排序。
	* Kruskal 算法中使用了 #并查集 ，其操作的时间复杂度是多少？
		**答：** 如果同时使用了**路径压缩 (Path Compression)** 和 **按秩合并 (Union by Rank)** 优化，并查集的单次操作时间复杂度近似为常数，具体为$O(\alpha(n))$，其中$\alpha$是反阿克曼函数，增长极慢（对宇宙中所有实际数据可视为小于 5）。因此 Kruskal 的瓶颈完全在于边的排序$O(e\log e)$。

#### 算法对比
#普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法的特点 

| 特性       | Prim 算法    | Kruskal 算法              |
| :------- | :--------- | :---------------------- |
| **策略**   | 从点出发，逐步扩张  | 从边出发，连接各个部分             |
| **数据结构** | 优先队列（最小堆）  | 并查集 + 排序                |
| **复杂度**  | O(E log V) | O(E log E) 或 O(E log V) |
| **适用图**  | 稠密图        | 稀疏图                     |
| **过程**   | 始终保持一个连通的树 | 开始时是森林，最后合成一棵树          |
*   **Kruskal:** 时间复杂度主要取决于对边的排序，为 $O(E \log E)$，其中 $E$ 是边数。它更适合**稀疏图**（边数 $E$ 远小于 $V^2$）。
*   **Prim:**
	*   使用邻接矩阵实现：$O(V^2)$。
	*   使用优先队列（最小堆）优化：$O(E \log V)$。
	*   Prim算法的 $O(V^2)$ 版本适合**稠密图**（边数 $E$ 接近 $V^2$）。

- 图的存储结构选择    
	- **问：** 为了实现 $O(n^2)$ 的 Prim 算法，图应该用什么方式存储？为了实现 Kruskal 算法呢？
		**答：**  [[邻接矩阵，邻接表 ，稀疏图，稠密图]] 
		*   朴素 Prim ($O(n^2)$)：适合使用  #邻接矩阵 ，因为需要频繁读取任意两点间的边权，且适合稠密图。
		*   Kruskal / 堆优化 Prim：适合使用 **邻接表** 或 **边集数组**，因为算法重点在于遍历边（Kruskal 甚至只需要一个边的列表即可）。

	