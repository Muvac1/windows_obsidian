#伸展树 是一种自平衡的二叉搜索树，它的特点是每当访问（查询、插入、删除）一个节点时，都会通过一系列的旋转操作 （称为“伸展”或`splay`操作）将该节点移动到树的根部。这样做的好处是，经常被访问的节点会离根节点更近，从而使得后续对这些节点的访问速度更快。
 #自平衡二叉搜索树   [[平衡二叉树的旋转]]
2. #伸展树使用场景
    *   **简介**：由于其“访问局部性”的特点（经常访问的元素会靠近根），它在缓存（Cache）、内存分配器、网络路由等场景中表现优异，因为这些场景下的访问模式往往不是均匀随机的。
3. #伸展树势能的最小值 ：
    *   **考点**：伸展树的总势能何时达到最小？最小值大约是多少？
    *   **简介**：当树的形态为一棵**完全二叉树**（最平衡的形态）时，总势能最小。此时，大部分节点的子树规模 $s(x)$ 都比较小，因此 $\log_2(s(x))$ 的值也较小。其总势能的下界是 $\Omega(n)$。
    *   相对地，当树退化成一条**链**时，总势能最大，接近 $O(n \log n)$。因为此时各节点的子树大小为 $1, 2, 3, ..., n$，总势能为 $\sum_{i=1}^n \log_2(i) = \log_2(n!) \approx O(n \log n)$。
4. **伸展操作 (Splaying)：** 通过一系列特定的旋转操作将目标节点提升至根。主要有三种旋转组合：
    1.  **Zig (单旋转):** 当目标节点 `x` 的父节点 `p` 就是根节点时，进行一次单旋转。
    2.  **Zig-Zig (一字形旋转):** 当 `x` 和 `p` 都是左孩子（或都是右孩子）时，先旋转 `p`，再旋转 `x`。
    3.  **Zig-Zag (之字形旋转):** 当 `x` 是右孩子而 `p` 是左孩子（或反之）时，先旋转 `x`，再将 `x` 旋转到根。

*   **时间复杂度：** 伸展树的所有基本操作（插入、查找、删除）的**摊还时间复杂度**（Amortized Time Complexity）都是$O(\log n)$。这意味着虽然单次操作的最坏情况可能是$O(n)$（例如，顺序访问一个链状的树），但一系列连续操作的平均时间开销是对数级的。
![动图](https://pic4.zhimg.com/v2-026937b0590d5252b3d74114c00fabc3_b.webp)