#伸展树 是一种自平衡的二叉搜索树，它的特点是每当访问（查询、插入、删除）一个节点时，都会通过一系列的旋转操作 （称为“伸展”或`splay`操作）将该节点移动到树的根部。这样做的好处是，经常被访问的节点会离根节点更近，从而使得后续对这些节点的访问速度更快。
 #自平衡二叉搜索树   [[平衡二叉树的旋转]]
2. #伸展树使用场景
    *   **简介**：由于其“访问局部性”的特点（经常访问的元素会靠近根），它在缓存（Cache）、内存分配器、网络路由等场景中表现优异，因为这些场景下的访问模式往往不是均匀随机的。
3. #伸展树势能的最小值 ： [[摊还分析与势能法]]
    *   **考点**：伸展树的总势能何时达到最小？最小值大约是多少？
    *   **简介**：当树的形态为一棵**完全二叉树**（最平衡的形态）时，总势能最小。此时，大部分节点的子树规模 $s(x)$ 都比较小，因此 $\log_2(s(x))$ 的值也较小。其总势能的下界是 $\Omega(n)$。 #时间复杂度下界理论  #算法下界 [[渐进符号]]
    *   相对地，当树退化成一条**链**时，总势能最大，接近 $O(n \log n)$。因为此时各节点的子树大小为 $1, 2, 3, ..., n$，总势能为 $\sum_{i=1}^n \log_2(i) = \log_2(n!) \approx O(n \log n)$。
4. **伸展操作 (Splaying)：** 通过一系列特定的旋转操作将目标节点提升至根。主要有三种旋转组合：
    1.  **Zig (单旋转):** 当目标节点 `x` 的父节点 `p` 就是根节点时，进行一次单旋转。
    2.  **Zig-Zig (一字形旋转):** 当 `x` 和 `p` 都是左孩子（或都是右孩子）时，先旋转 `p`，再旋转 `x`。
    3.  **Zig-Zag (之字形旋转):** 当 `x` 是右孩子而 `p` 是左孩子（或反之）时，先旋转 `x`，再将 `x` 旋转到根。

*   **时间复杂度：** 伸展树的所有基本操作（插入、查找、删除）的**摊还时间复杂度**（Amortized Time Complexity）都是$O(\log n)$。这意味着虽然单次操作的最坏情况可能是$O(n)$（例如，顺序访问一个链状的树），但一系列连续操作的平均时间开销是对数级的。
![动图](https://pic4.zhimg.com/v2-026937b0590d5252b3d74114c00fabc3_b.webp)


1. #伸展树性质  
	- **无需记录高度或平衡因子：** 与AVL树（需要存高度）或红黑树（需要存颜色）不同，伸展树只存数据和指针，空间利用率高，代码相对简单。
    *   **分摊复杂度$O(\log n)$：** 长期看效率与AVL树相当。
    *   **局部性强（Locality of Reference）：** 图片中的$O(\log k)$是指，如果一个节点最近被访问过，它会处于靠近根的位置。如果下一次访问的节点距离当前位置很近（距离为$k$），访问速度极快。这非常适合缓存（Cache）场景。
    *   **不能杜绝单次最坏情况：** 这是一个关键点。虽然**平均**是$O(\log n)$，但**单次**最坏情况可能是$O(n)$（例如树是一条链，且访问最底部的元素）。