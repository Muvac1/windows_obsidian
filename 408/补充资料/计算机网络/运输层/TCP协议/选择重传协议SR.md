#选择重传协议SR  是为了克服**回退N帧协议 (Go-Back-N, GBN)** 中因单个帧丢失而导致大量帧被重传的低效率问题而设计的。

#### SR 协议的核心机制

1.  **独立的确认 (Individual Acknowledgement)**
    *   接收方会对每一个正确接收的数据帧（无论是否按序）都发送一个独立的确认（ACK）。例如，收到 5 号帧就回复 ACK5。
    *   这与 GBN 的**累积确认 (Cumulative Acknowledgement)** 形成鲜明对比。在 GBN 中，ACKn 表示接收方已经正确接收了 n 号帧以及之前的所有帧。

2.  **发送方：为每个帧设置独立计时器**
    *   发送方在其发送窗口内，为每一个已发送但尚未被确认的帧都维护一个独立的计时器。
    *   当某个帧的计时器超时，发送方只重传这一个帧。
    *   当收到某个帧的 ACK 时，就取消对应帧的计时器。

3.  **接收方：缓存失序帧**
    *   接收方有一个接收窗口，可以接收并缓存那些未按序到达但没有出错的帧。
    *   例如，接收方期望收到 2 号帧，但先收到了 3 号和 4 号帧。它会缓存 3 号和 4 号帧，并分别发送 ACK3 和 ACK4。
    *   当它最终收到 2 号帧后，就可以将 2、3、4 号帧按顺序一次性地交付给上层应用。
[[SR 协议与 GBN 协议的关键区别]]‘



 #SR协议的窗口大小
 SR 协议中，为了保证协议的正确性，发送窗口大小 ($W_T$) 和接收窗口大小 ($W_R$) 的和不能超过序列号的总数。
	$W_T + W_R \le 2^n$
通常情况下，为了最大化利用信道，我们会让发送窗口和接收窗口的大小相等，即 $W_T = W_R$。此时，窗口大小满足：
	$W_T \le 2^{n-1}$ 
**为什么会有这个限制？**
设想一个场景，序列号有 4 个 (0, 1, 2, 3)，即 $n=2$，$2^n=4$。如果窗口大小 $W_T = W_R = 3 > 2^{2-1}$。
-   **初始状态**：发送方发送 0, 1, 2 号帧。接收方也准备接收 0, 1, 2。
-   **接收与确认**：接收方成功收到 0, 1, 2，并发送了 ACK0, ACK1, ACK2。接收窗口向前滑动，变为准备接收 3, 0, 1。
-   **ACK 丢失**：不幸的是，这三个 ACK 全部丢失了。
-   **超时与重传**：发送方超时，重传 0 号帧。
-   **歧义产生**：此时，接收方收到了一个 0 号帧。但它无法判断：这个 0 号帧是发送方重传的**旧的** 0 号帧，还是一个**新的** 0 号帧（因为它的窗口已经滑动到了 {3, 0, 1}）？这种歧义会导致协议出错。

通过将窗口大小限制在 $W_T \le 2^{n-1}$，就可以确保发送方窗口和接收方窗口的序列号区间不会重叠，从而避免上述歧义。 