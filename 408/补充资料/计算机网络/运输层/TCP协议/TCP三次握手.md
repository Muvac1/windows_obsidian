
#TCP三次握手 TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的 #传输层 通信协议。在数据传输之前，必须通过“三次握手”建立连接。
[[TCP四次挥手]]
整个过程如下（假设客户端为A，服务器为B）：

1.  **第一次握手 (SYN)**
    *   **A -> B**: A发送一个TCP段。
    *   标志位: $SYN=1$, $ACK=0$
    *   序号: $seq=x$ (x是A随机选择的初始序号)
    *   A进入 SYN_SENT 状态。

2.  **第二次握手 (SYN-ACK)**
    *   **B -> A**: B收到A的请求后，发送一个TCP段作为响应。
    *   标志位: $SYN=1$, $ACK=1$
    *   序号: $seq=y$ (y是B随机选择的初始序号)
    *   确认号: $ack=x+1$ (表示已成功收到A的序号x，期望下一个是x+1)
    *   B进入 SYN_RCVD 状态。

3.  **第三次握手 (ACK)**
    *   **A -> B**: A收到B的确认后，再发送一个确认TCP段。
    *   标志位: $SYN=0$, $ACK=1$
    *   序号: $seq=x+1$ (A自己的序号也要增加)
    *   确认号: $ack=y+1$ (表示已成功收到B的序号y，期望下一个是y+1)
    *   此报文段发送后，A和B都进入 ESTABLISHED 状态，连接建立成功，可以开始传输数据。

为什么是三次握手，而不是两次或四次？
*   **防止已失效的连接请求报文段突然又传送到了服务器**：这是主要原因。如果采用两次握手，客户端发出连接请求，但因网络延迟未立即到达。客户端超时重发，建立连接，传输数据，然后释放连接。此时，那个延迟的旧连接请求才到达服务器。服务器会误以为是新的连接请求，发送确认，并分配资源等待客户端数据。但客户端无意建立新连接，不会响应，导致服务器资源白白浪费。三次握手通过客户端的第三次确认，确保了客户端确实要建立当前的连接。
-    **考点**: 可能会考查握手和挥手过程中各个报文段的 #标志位 （SYN, ACK, FIN）以及状态变迁。