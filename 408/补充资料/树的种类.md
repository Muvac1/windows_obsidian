
### 一、 按节点度（分支数）分类

这是最基本的分类方式，根据每个节点最多可以拥有的子节点数量来划分。

#### 1. 一般树（General Tree）
没有对子节点数量做任何限制的树。一个节点可以有任意数量的子节点。

#### 2. N叉树（N-ary Tree）
每个节点**最多**只能有N个子节点的树。
*   **应用**：文件系统目录结构（一个文件夹下可以有多个文件或子文件夹）、组织架构图等。

#### 3. 二叉树（Binary Tree）
这是最常用、研究最深入的一类树，每个节点**最多**只有两个子节点，通常称为“左子节点”和“右子节点”。

<img src="https://g.co/kgs/a79D7aU" alt="Binary Tree" width="300"/>

**二叉树的特殊形态：**

*   **满二叉树（Full Binary Tree）**：一棵深度为k且有2^k - 1个节点的二叉树。在国内的定义中，除叶子节点外，每个节点的度都为2。
![[Pasted image 20250805052703.png]]
*   **完全二叉树（Complete Binary Tree）**：深度为k，除了第k层外，其余各层（1~k-1）的节点数都达到最大值，且第k层所有的节点都连续集中在最左边。堆（Heap）通常就是用完全二叉树实现的。
![[Pasted image 20250805052655.png]]
*   **斜树（Skewed Tree）**：所有节点都只有左子节点（左斜树）或只有右子节点（右斜树），形态类似链表，查找性能最差。

### 二、 按特性和应用分类

这类树通常是为了解决特定问题而设计的，它们在基础结构之上增加了一些规则。

#### 1. 查找树（Search Trees）

这类树的主要目的是为了高效地进行数据查找、插入和删除。

*   **二叉搜索树（BST, Binary Search Tree）**
    *   **定义**：一种特殊的二叉树，对于树中任意节点，其左子树上所有节点的值均小于该节点的值；其右子树上所有节点的值均大于该节点的值。
    *   **优点**：在理想情况下，查找、插入、删除的平均时间复杂度为O(log n)。
    *   **缺点**：在极端情况下（如插入一个有序序列），会退化成斜树，时间复杂度降为O(n)。

*   **平衡二叉搜索树（Balanced Binary Search Tree）**
    为了解决BST可能退化的问题，平衡二叉搜索树通过自平衡操作，使得树的高度保持在log n的量级，从而确保操作效率。

    *   **AVL树**：最早被发明的自平衡二叉搜索树。它要求任何节点的左右两个子树的高度差绝对值不超过1。插入和删除节点后，可能需要通过“旋转”操作来维持平衡。
    ![[Pasted image 20250805052751.png]]
	
	*   **红黑树（Red-Black Tree）**：一种近似平衡的二叉搜索树。它通过为每个节点增加一个颜色属性（红色或黑色）并遵循特定规则来维持平衡，确保从根到最远叶子路径的长度不超过最短路径的两倍。它的平衡条件没有AVL树那么严格，因此插入删除时的旋转操作相对较少。在C++的STL（如`std::map`, `std::set`）和Java的`TreeMap`中广泛使用。
![[Pasted image 20250805052742.png]]

*   **B树（B-Tree）**
    *   **定义**：一种多路（multi-way）平衡查找树，即每个节点可以有两个以上的子节点。它专门为磁盘等外部存储设备设计，因为磁盘I/O操作远慢于内存访问，B树通过减少树的高度来降低I/O次数。
    *   **特点**：
        *   所有叶子节点都在同一层。
        *   每个非叶子节点可以存储多个键和指向子节点的指针。
    *   **应用**：绝大多数现代文件系统和数据库系统的索引结构，如MySQL的InnoDB引擎。
![[Pasted image 20250805052805.png]]
*   **B+树（B+ Tree）**
    *   **定义**：是B树的变种，为数据库索引做了进一步优化。
    *   **与B树的区别**：
        1.  所有数据都只存储在叶子节点中，非叶子节点只存储键（索引）。
        2.  所有叶子节点通过指针连接成一个有序链表。
    *   **优点**：由于非叶子节点不存数据，可以存放更多索引，使树更“矮胖”，进一步减少I/O。叶子节点的链表结构非常适合范围查询。
    *   **应用**：数据库索引的标准实现方式。
![[Pasted image 20250805052811.png]]
#### 2. 堆（Heap）

*   **定义**：通常是一个可以被看做一棵完全二叉树的数组对象。它需要满足“堆属性”：父节点的值总是大于或等于（大顶堆）或小于或等于（小顶堆）其子节点的值。
*   **种类**：
    *   **大顶堆（Max-Heap）**：根节点是整个堆中的最大值。
    *   **小顶堆（Min-Heap）**：根节点是整个堆中的最小值。
    当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。如下图所示，左边为最大堆，右边为最小堆。
*   **应用**：
    *   **优先队列（Priority Queue）**：可以高效地插入元素和取出优先级最高（最大或最小）的元素。
    *   **堆排序（Heap Sort）**。
![[Pasted image 20250805052855.png]]
#### 3. 字典树/前缀树（Trie / Prefix Tree）

*   **定义**：一种专门用于处理字符串的多叉树结构。树的每个节点通常代表一个字符，从根到某个节点的路径连接起来就构成一个字符串。
*   **特点**：
    *   根节点不包含字符，除根节点外每一个节点都只包含一个字符。
    *   从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
*   **应用**：
    *   搜索引擎的自动补全、关键词提示。
    *   词频统计。
    *   IP路由表的最长前缀匹配。
![[Pasted image 20250805053036.png]]
#### 4. 哈夫曼树（Huffman Tree）

*   **定义**：也叫最优二叉树，是一种带权路径长度最短的树。权值较大的节点离根较近。
*   **应用**：哈夫曼编码，一种著名的数据压缩算法。通过为出现频率高的字符分配较短的编码，为出现频率低的字符分配较长的编码，来实现文本的有效压缩。
![[Pasted image 20250805053110.png]]
哈夫曼的构造过程 

![[Pasted image 20250805053120.png]]


### 总结图表

| **大类** | **具体树种** | **核心特点** | **主要应用场景** |
| :--- | :--- | :--- | :--- |
| **按分支数** | 一般树 | 无子节点数限制 | 任意层级关系表示 |
| | 二叉树 | 最多2个子节点 | 各种高级树结构的基础 |
| **查找树** | 二叉搜索树 (BST) | 左小右大 | 基础的动态数据查找 |
| | AVL树 | 严格高度平衡 (高度差≤1) | 对查找性能要求极高的场景 |
| | 红黑树 | 近似平衡 (颜色规则) | 语言库中的Map/Set，Linux内核 |
| | B树 / B+树 | 多路平衡，矮胖结构 | 数据库索引、文件系统 |
| **专用树** | 堆 (Heap) | 父节点与子节点的大小关系固定 | 优先队列、堆排序 |
| | 字典树 (Trie) | 共享字符串前缀 | 字符串检索、词频统计、自动补全 |
| | 哈夫曼树 | 带权路径长度最短 | 数据压缩（哈夫曼编码） |

希望这份详细的介绍能帮助您全面地理解数据结构中树的种类和用途！