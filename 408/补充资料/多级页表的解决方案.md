多级页表的思想很简单：**对页表本身进行分页**。既然我们觉得整个页表太大了，那就把它拆分成小块，然后用另一张“目录表”来管理这些小块。
一个典型的32位系统的例子：

*   **虚拟地址空间:** 32位地址，总空间为 $2^{32}$ 字节 = 4GB。
*   **页面大小 (Page Size):** 假设为 4KB，即 $2^{12}$ 字节。
*   **页表项大小 (PTE Size):** 假设每个页表项需要4字节来存储物理页框号和其他控制位。
*  引入**二级页表**：

1.  **拆分虚拟地址：**
    一个32位的虚拟地址被分为三部分：
    *   **页目录索引 (Page Directory Index):** 10位
    *   **页表索引 (Page Table Index):** 10位
    *   **页内偏移 (Offset):** 12位

    结构如下： `| 10位 | 10位 | 12位 |`

2.  **建立两级结构：**
    *   **页目录 (Page Directory) / 顶级页表:** 它有 $2^{10} = 1024$ 个表项。每个表项指向一个二级页表。
    *   **二级页表 (Second-level Page Table):** 每个二级页表也有 $2^{10} = 1024$ 个表项。每个表项指向一个最终的物理页框。 表项至少

3.  **计算空间占用：**
    *   页目录大小：$1024 \text{ 项} \times 4 \text{ B/项} = 4 \text{ KB}$。
    *   每个二级页表大小：$1024 \text{ 项} \times 4 \text{ B/项} = 4 \text{ KB}$。

    注意到，页目录和每个二级页表的大小都正好是 4KB，这恰好是一个物理页的大小。这意味着我们可以把页目录放在一个物理页中，把每个二级页表也分别放在一个物理页中。

4.  **核心优点体现：**
    *   **离散存储：** 页目录本身只需要一个4KB的连续空间（一个页框）。它所指向的各个二级页表可以被存放在物理内存中任意不连续的页框里。这就完美解决了需要大块连续内存的问题。
    *   **节省空间：** 对于一个程序来说，它在运行初期可能只用到了虚拟地址空间的一小部分。比如，一个4GB的虚拟地址空间，程序可能只用到了头部的几MB和尾部的几MB（用于栈）。在这种情况下，我们**只需要为被用到的那部分地址空间创建二级页表**。那些从未被访问过的巨大地址空间，我们根本不需要为它们创建对应的二级页表，只需在页目录中将相应的表项标记为无效即可。这极大地节省了物理内存。



