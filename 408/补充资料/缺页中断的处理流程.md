一个完整的 #缺页中断处理流程 可以分解为以下步骤：
1.  **硬件陷入 (Trap):** CPU尝试访问某虚拟地址，MMU在翻译地址时发现对应页表项的有效位为0，触发缺页中断，CPU控制权从用户态转到内核态，并跳转到操作系统的缺页中断处理程序。
2.  **合法性检查:** 操作系统检查此次内存访问是否合法。例如，地址是否越界，或者是否有写入只读页面的权限冲突。如果访问非法，则终止该进程（如产生段错误 Segmentation Fault）。
3.  **定位页面:** 如果访问合法，操作系统需要在外存（交换区）找到该页面所在的位置。
4.  **分配物理页框:** 操作系统在物理内存中寻找一个空闲页框。
    *   **情况A (有空闲页框):** 直接分配一个空闲页框。
    *   **情况B (无空闲页框):** 启动**页面置换算法 (Page Replacement Algorithm)**，选择一个“牺牲页”，将其换出内存。如果这个牺牲页是“脏”的（即被修改过），则必须先将其写回外存，这会引发一次额外的磁盘I/O。
5.  **调入页面:** 操作系统发起一次**磁盘I/O**请求，将目标页面从外存读入到第4步中准备好的物理页框中。
6.  **进程阻塞与调度:** 磁盘I/O是非常耗时的操作。在此期间，操作系统会将引起缺页的进程置于阻塞状态，并调度其他就绪的进程来运行，以提高CPU利用率。
7.  **I/O完成中断:** 当磁盘读取操作完成后，磁盘控制器会向CPU发送一个中断信号。
8.  **更新页表和唤醒进程:** 操作系统在接收到I/O完成中断后，会**修改**引起缺页的进程的页表，更新对应页表项的有效位、物理页框号等信息。然后，将该进程的状态从阻塞态改回就绪态，放入就绪队列。
9.  **返回并重启指令:** 当该进程再次被调度运行时，它会从之前被中断的指令处重新开始执行。此时，由于页表已更新，MMU可以成功完成地址翻译，内存访问顺利进行。