1. 实现拓扑排序的算法 
 - [[Kahn算法]]  (基于入度) 
	*   这是本题所使用的方法。
	    *   **步骤**：
	        1.  计算所有顶点的入度，并将所有入度为0的顶点放入一个队列（或集合）中。
	        2.  当队列不为空时，取出一个顶点 $u$，将其加入到拓扑排序结果序列中。
	        3.  遍历 $u$ 的所有邻接点 $v$，将边 $(u, v)$ “删除”，即把 $v$ 的入度减1。
	        4.  如果 $v$ 的入度减为0，则将 $v$ 加入队列。
	        5.  重复此过程直到队列为空。
	    *   **环路检测**：如果算法结束后，结果序列中的顶点数量少于图中总顶点数，说明图中存在环
* [[广度优先搜索（BFS）和深度优先搜索（DFS）]]  
	* DFS算法 (基于深度优先搜索) 
		1.  创建一个栈（或列表）来存储排序结果。
        2.  创建一个集合来记录已访问的顶点。
        3.  对图中的每一个顶点，如果它没有被访问过，就对它进行DFS。
        4.  在DFS函数中，当一个顶点的所有邻接点都已经被访问（即递归调用已返回）后，将该顶点压入栈中。
        5.  所有顶点都访问完毕后，从栈中依次弹出的顶点序列就是拓扑排序的结果（或者说，将列表反转）。
    *   **环路检测**：在DFS过程中，可以通过维护一个“递归栈”来检测环路。如果在访问一个顶点 $u$ 的邻接点 $v$ 时，发现 $v$ 已经存在于当前的递归路径上，则说明存在环