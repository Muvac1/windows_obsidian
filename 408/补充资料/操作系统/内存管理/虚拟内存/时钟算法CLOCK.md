1. #时钟算法Clock  #时钟算法 
	*   **概念**: 将所有页框组织成一个环形链表，用一个指针指向下一个要检查的页框。每个页框有一个访问位 (use bit)。当需要置换页面时，从指针处开始扫描，若访问位为1，则清零并跳过；若为0，则置换该页。
    *   **考点**: 对比本题策略和标准时钟算法的异同。本题是周期性扫描，而标准时钟算法是在缺页时才扫描。可能会要求手写模拟标准的时钟算法或 #改进的时钟算法 （例如增加 #修改位 ）。
		*  简单CLOCK只使用访问位 $A$。它扫描时跳过 $A=1$ 的页（并将其置为 $A=0$），替换第一个遇到的 $A=0$ 的页。改进型CLOCK增加了修改位 $M$ 的判断，使得它能区分“干净页”和“脏页”，从而优先淘汰“干净页”，减少了I/O开销 
		* **与LRU（最近最少使用）算法的比较**: LRU算法能实现最优的替换效果（理论上），但需要昂贵的硬件支持（如时间戳或栈）来精确记录每个页面的访问顺序，开销很大。CLOCK及其改进型算法是LRU的一种低开销的近似实现，性能接近LRU，但实现简单得多。
	    *   **与FIFO（先进先出）算法的比较**: FIFO实现最简单，但性能可能很差，因为它可能会淘汰掉一个经常被访问的“老”页面，容易导致“Belady异常”（即分配更多物理帧反而导致缺页率上升的现象）。