这是操作系统的核心考点，尤其是在 #分页式存储管理 中。
#虚拟地址到物理地址的转换 
*   **基本过程**:
    1.  CPU生成一个虚拟地址（或称线性地址）。
    2.  这个地址被逻辑上划分为**页号 (Page Number, p)** 和**页内偏移 (Offset, d)**。
    3.  MMU使用页号 $p$ 作为索引，在**页表 (Page Table)** 中查找对应的**帧号 (Frame Number, f)**。页表的基地址通常存储在CPU的特殊寄存器（如CR3）中。
    4.  如果页表项有效，则取出帧号 $f$。
    5.  将帧号 $f$ 与页内偏移 $d$ 组合起来，形成最终的物理地址。

*   **相关公式**:
    假设页大小为 $PageSize$ (通常是 $2^n$ 字节)，一个虚拟地址为 $VA$。
    *   页号的计算: $p = \lfloor \frac{VA}{PageSize} \rfloor$
    *   页内偏移的计算: $d = VA \pmod{PageSize}$
    *   物理地址的计算: $PA = f \times PageSize + d$![[截屏2025-09-19 上午6.49.45.png]]一个简化的流程如下：
		1.  CPU给出虚拟地址。
		2.  MMU首先查询**快表（TLB）**。TLB是一个高速缓存，存储了近期使用过的页表项（虚拟页号 -> 物理页帧号的映射）。
		3.  **TLB命中（Hit）**：如果在TLB中找到了对应的页表项，MMU直接用它来计算出物理地址。这个过程非常快，通常在一个时钟周期内完成。
		4.  **TLB未命中（Miss）**：如果在TLB中没有找到，MMU必须去访问存放在**主内存**中的**页表**。
		    a.  MMU根据页表基址寄存器和虚拟地址中的页号，在主内存中查找对应的页表项。这需要一次或多次（对于多级页表）内存访问，比访问TLB慢得多。
		    b.  找到页表项后，用它来计算物理地址。
		    c.  同时，为了利用程序的局部性原理，MMU会将这个新查到的页表项放入TLB中，以便下次快速访问。
		5.  **页表项无效（Page Fault）**：如果在主内存的页表中发现该页不在内存中（可能被换出到磁盘了），会触发一个**缺页中断**。操作系统介入，从磁盘（交换区）中将所需的页面调入内存，并更新页表。这个过程涉及磁盘I/O，是所有情况中最慢的。