1. #中断与子程序调用的区别
    *   **考点:** `CALL`指令和中断在实现跳转、保存返回地址、触发时机等方面有什么不同？
    *   详解:
        *   **时机:** `CALL`是程序预设的，在程序代码中明确写出，是同步的。中断是由外部或内部事件随机触发的，是异步的。
        *   **地址:** `CALL`指令直接指定或计算出目标地址。中断通过中断向量在中断向量表中查找目标地址。
        *   **状态保存:** `CALL`只保存返回地址（PC）。中断不仅保存PC，还自动保存 #程序状态字PSW   。
        *   **响应:** `CALL`是无条件执行的。中断响应需要满足中断允许等条件。
 [[中断、异常和系统调用的区别与联系]]  [[区分中断、异常和系统调用]] 
- 分析共同点
	- 题目指出，“中断处理”和“子程序调用”都需要“压栈以保护现场”。这里的“现场”指的是程序在被暂停（无论是被中断还是去调用子程序）前的瞬间状态
	- 为了能够正确地返回并继续执行，最核心的信息是**返回地址**
		- 也就是下一条应该执行的指令的地址。这个地址存放在 #程序计数器PC  （Program Counter, $PC$）中。因此，无论是中断还是子程序调用，都必须保存$PC$的内容。这排除了选项A，因为$PC$是两者都需要保存的，而不是它们的区别分析差异点

1.  **分析差异点**：现在我们需要找出 #中断处理 **一定**会保存，而 #子程序调用 **不一定**需要保存的东西。
    *   **子程序调用 (Subroutine Call)**：这是一个**同步**的、由程序代码预先安排好的跳转。例如，一条`CALL`指令。程序员在编写代码时，是知道这次跳转的。调用子程序的主要目的是完成一个特定功能然后返回。子程序可能会改变某些标志位（比如运算后产生进位），这甚至是它设计的功能之一。因此，除非有特殊需要（由编译器或程序员根据调用约定来决定），否则没有硬性规定必须保存调用前的CPU状态。其最根本的需求只是记录返回点（$PC$）。
    *   **中断处理 (Interrupt Handling)**：这是一个**异步**的、突发的事件，与当前正在执行的指令通常没有逻辑关系（例如，一个外部设备完成了数据传输，或者发生了电源故障）。CPU必须暂停当前程序，去处理这个紧急事件，处理完后，再**完全恢复**到被打断前的状态，让原程序“毫无察觉”地继续运行。为了做到“毫无察觉”，不仅要记住返回地址（$PC$），还必须保存中断发生瞬间的CPU所有状态，比如进位标志、零标志、中断是否开启等。这些状态信息被集中存放在**程序状态字寄存器（Program Status Word, $PSW$）**中。这个保存动作通常是由硬件自动完成的，是中断响应过程的一部分，以确保现场的完整性。
