1. #系统调用的过程  
	用户程序设置参数 -> 执行陷入指令（如`int 0x80`或`syscall`） -> CPU切换到核心态并跳转到内核入口 -> 内核根据参数执行相应服务 -> 内核返回结果 -> CPU切换回用户态 -> 用户程序继续执行
	*   用户程序准备参数，并将系统调用号放入指定寄存器。
    *   用户程序执行 `trap` 指令。
    *   CPU硬件响应`trap`，保存当前程序的上下文（PC, PSW等），将CPU模式切换到内核态，并根据中断向量表跳转到对应的系统调用总入口。
    *   内核的 #系统调用处理程序 根据 #系统调用号 ，分发到具体的 #服务例程 （如 `do_read`）。
    *   内核执行所需功能（如从磁盘读取数据）。
    *   内核将结果返回给用户程序（通常通过寄存器）。
    *   内核执行特权的返回指令，恢复用户程序的上下文，并将CPU模式切回用户态。
    *   用户程序从`trap`指令的下一条指令继续执行。
* #系统调用 是应用程序请求操作系统提供服务的接口，例如读写文件、创建进程等  #系统调用处理程序 
- 用户程序如何向内核传递参数？内核如何找到对应的服务程序？
	通常通过 #寄存器 传递参数。每个系统调用被赋予一个唯一的编号。用户程序将系统调用号放入指定寄存器（如`eax`），执行`syscall`指令。内核在核心态被唤醒后，根据这个编号在 #系统调用表 中查找对应的服务例程地址并执行 
- **考点**： #系统调用的参数传递方式 、 #用户态和内核态堆栈的切换 