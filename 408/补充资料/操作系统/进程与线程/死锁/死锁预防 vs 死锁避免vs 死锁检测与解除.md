 #死锁预防vs死锁避免vs死锁检测与解除  
*   **死锁预防 (Deadlock Prevention)**：这是一种**静态**的策略。它通过破坏产生死锁的四个必要条件中的任意一个，来从根本上杜绝死锁的发生。这四个条件是：
    1.  **互斥 (Mutual Exclusion)**：资源不能被共享。
    2.  **请求和保持 (Hold and Wait)**：进程在持有至少一个资源的同时，又去请求其他进程正持有的资源。
    3.  **不可剥夺 (No Preemption)**：资源不能被强制性地从持有它的进程中剥夺。
    4.  **循环等待 (Circular Wait)**：存在一个进程资源的循环等待链。
    预防策略的限制性很强，可能会导致系统资源利用率和吞吐量下降。

*   **死锁避免 (Deadlock Avoidance)**：这是一种**动态**的策略。它不破坏死锁的必要条件，而是在资源分配的过程中，使用某种算法（如**银行家算法**）来预测本次分配是否会导致系统进入**不安全状态**。如果会，则拒绝分配，让进程等待。通过确保系统始终处于**安全状态**，来避免死锁的发生。

- **死锁检测与解除 (Deadlock Detection and Recovery) - S2 的策略**
    这种策略最为宽松，它**允许系统进入不安全状态，甚至允许死锁发生**。
    *   **核心思想**：不采取任何预防或避免措施，而是定期运行一个“检测算法”来判断系统当前**是否已经发生**死锁。
    *   **如果检测到死锁**：系统会采取措施来“解除”死锁，例如剥夺某些进程的资源或终止一个或多个死锁进程。
    *   **前提条件**：它**不需要**任何关于进程未来资源需求的预先信息。它只关心当前系统的资源分配情况。
    *   **行为**：它会满足进程的资源请求（只要有可用资源），即使这个请求会导致死锁。