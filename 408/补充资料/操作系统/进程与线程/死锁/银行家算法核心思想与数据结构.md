#银行家算法核心思想与数据结构 
	通过模拟银行贷款系统来工作，确保系统总能满足所有进程未来的资源需求。 这是 #死锁避免的核心
**核心数据结构:**

假设系统中有 `n` 个进程和 `m` 种资源。

1.  **可利用资源向量 (Available)**:
    *   一个长度为 `m` 的向量，`Available[j] = k` 表示第 `j` 种资源现有 `k` 个实例。

2.  **最大需求矩阵 (Max)**:
    *   一个 `n x m` 的矩阵，`Max[i][j] = k` 表示进程 `i` 对第 `j` 种资源的最大需求量是 `k`。

3.  **分配矩阵 (Allocation)**:
    *   一个 `n x m` 的矩阵，`Allocation[i][j] = k` 表示进程 `i` 当前已分配到的第 `j` 种资源的数量是 `k`。

4.  **需求矩阵 (Need)**:
    *   一个 `n x m` 的矩阵，`Need[i][j] = k` 表示进程 `i` 要完成任务，还需要的第 `j` 种资源的数量是 `k`。
    *   它们之间的关系可以用以下公式表示：
        $Need[i][j] = Max[i][j] - Allocation[i][j]$
 
    **判断当前系统是否安全**：你需要运行 #安全性算法 ，看能否找到一个安全序列。算法步骤是：
        1.  初始化工作向量 $Work = Available$ 和 $Finish[i] = false$。
        2.  查找是否存在一个进程 $P_i$，满足 $Finish[i] == false$ 且 $Need_i \le Work$。
        3.  如果找到，则执行 $Work = Work + Allocation_i$，$Finish[i] = true$，然后回到步骤2。
        4.  如果找不到这样的进程，则检查是否所有 $Finish[i] 都为 true。如果是，则系统安全；否则，系统不安全。
 
 [[银行家算法vs安全性算法]]   、[[死锁检测算法]] 