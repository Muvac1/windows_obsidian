### 临界区问题是什么？——“单人卫生间问题”

想象一下，你们办公室只有一个单人卫生间。这个卫生间就是**共享资源 (Shared Resource)**。

*   **临界区 (Critical Section)**：就是**一个人正在使用卫生间的这段时间（以及他执行的动作）**。
*   **进程 (Process)**：就是想上卫生间的**员工**（比如员工P0和员工P1）。

现在，**临界区问题 (Critical Section Problem)** 就来了：我们必须设计一套**规则（算法）**，来保证任何时候最多只有一个人在卫生间里。如果两个人同时闯进去，那就会出大问题！这个“出问题”在计算机里就叫做**竞争条件 (Race Condition)**，会导致数据错乱、程序崩溃


--- 
*   **临界区**：是访问共享资源的代码片段。
*   **互斥**：是确保任何时候最多只有一个进程在临界区内执行的同步约束。
*   **同步机制**：为了实现互斥和其他复杂的协作关系，操作系统提供了多种同步机制，最经典的是**信号量（Semaphore）**。

一个[[信号量]] `S`是一个整数变量，只能通过两个原子操作来访问：`P`操作和`V`操作。

*   **P(S) 操作 (wait/down)**：
    1.  将信号量的值减1：$S.value = S.value - 1$。
    2.  如果结果为负数（$S.value < 0$），则表示资源不可用，执行该操作的进程被阻塞（放入该信号量的等待队列）。
    3.  如果结果为非负数（$S.value \ge 0$），则进程继续执行。

*   **V(S) 操作 (signal/up)**：
    1.  将信号量的值加1：$S.value = S.value + 1$。
    2.  如果结果小于或等于0（$S.value \le 0$），则表示有进程正在等待该资源，因此从该信号量的等待队列中唤醒一个进程。

使用信号量实现互斥的伪代码如下：
```
semaphore mutex = 1; // 初始化信号量为1，表示资源可用

Process Pi:
do {
    P(mutex); // 进入临界区前执行P操作
    
    // --- 临界区 ---
    // 访问共享资源
    
    V(mutex); // 离开临界区后执行V操作
    
    // --- 剩余区 ---
    
} while(TRUE);
```
从这个模型可以看出，`P`和`V`操作保护的是临界区代码块，如果进程在临界区内被调度程序剥夺了CPU，它仍然“持有”这个信号量（因为没有执行`V(mutex)`）。其他进程尝试执行`P(mutex)`时就会被阻塞，从而保证了互斥，但系统调度本身并未被禁止。