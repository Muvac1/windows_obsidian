#皮特森算法 是一个基于软件的、解决了**两个进程**临界区问题的经典算法。它巧妙地结合了“意愿标记”（`flag`数组）和“谦让轮转”（`turn`变量）来满足临界区问题的三个核心要求。
[[临界区问题]] 
 - **临界区**：是访问共享资源的代码片段。
1. #临界区问题的三个核心要求 ：
	*   **互斥 (Mutual Exclusion):** 如上文分析，任何时候最多只有一个进程在临界区内。
	*   **前进 (Progress):** 如果没有进程在临界区中，且有进程希望进入，那么只有那些希望进入的进程可以参与选择，并且这个选择不能被无限推迟。皮特森算法满足这一点：如果 P1 不想进入 (`flag[1]`为`FALSE`)，P0 绝不会被阻塞。
	*   **有限等待 (Bounded Waiting):** 一个进程提出进入临界区的请求后，在它的请求被允许之前，其他进程进入临界区的次数是有限的。皮特森算法满足这一点：一个进程最多等待另一个进程进入一次。这个特性保证了不会发生饥饿。

**2. 算法的精髓——“先举手，后谦让”**
皮特森算法最巧妙的地方在于 `flag[i] = TRUE;` 和 `turn = j;` 这两行代码的顺序。

*   `flag[i] = TRUE;`: **先表明自己的意图（举手）**。
*   `turn = j;`: **然后把优先权让给对方（谦让）**。

如果两个进程同时执行，它们都先举手，然后都把 `turn` 让给对方。由于 `turn` 变量的写操作是原子的，最终 `turn` 的值只会是最后一次写入的值。那个**最后完成谦让动作**的进程，也就是最后设置 `turn` 值的进程，会让自己进入等待状态，而让对方先行。


