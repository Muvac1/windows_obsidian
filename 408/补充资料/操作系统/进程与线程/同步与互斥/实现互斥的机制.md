信号量由Dijkstra提出的经典同步工具。可以使用一个初值为1的 #二元信号量（互斥锁，Mutex） 来保护临界区。
        ```
        semaphore mutex = 1;

        // P1
        P(mutex);       // 等待并锁住
        load R1, x;
        inc R1;
        store x, R1;
        V(mutex);       // 释放锁

        // P2
        P(mutex);       // 等待并锁住
        load R2, x;
        dec R2;
        store x, R2;
        V(mutex);       // 释放锁
        ```
        使用信号量后，两个临界区代码段将互斥执行，结果将始终为1。

*   **锁(Lock)**: 更现代的编程语言和库中提供的同步原语，功能与互斥信号量类似。

*   **硬件指令支持**: 如`TestAndSet`[[TSL指令]]、 `CompareAndSwap`等原子指令，它们是实现锁和信号量的底层基础。

1. #实现互斥的机制 
    *   **锁（Locks）**: 如互斥锁（Mutex）。在进入临界区前加锁（lock），退出后解锁（unlock）。
    *   **信号量（Semaphores）**: 一个更通用的同步工具。一个值为1的二元信号量可以实现互斥锁的功能。计数信号量可以允许有限个线程同时访问资源。
    *   **监视器（Monitors）**: 一种更高级的同步结构，将共享数据和操作这些数据的过程封装在一起，确保任何时候只有一个线程能执行其中的过程。
    *   **原子操作（Atomic Operations）**: 硬件层面提供的一些不可中断的指令，如`Test-and-Set`, `Compare-and-Swap`。现代编程语言也提供原子类型（如C++的`std::atomic`），可以安全地对变量进行`++`、`--`等操作。