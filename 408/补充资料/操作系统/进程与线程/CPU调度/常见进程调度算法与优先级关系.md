#### 3. #进程调度算法 及其与优先级的关系
1. #优先级调度算法 (Priority Scheduling)：直接考查本题知识点。
2. #时间片轮转算法 (Round Robin, RR)：
	工作原理: 将所有就绪进程按FCFS的原则排成一个队列。调度程序每次选择队首的进程，让它运行一个固定的时间单位（时间片, quantum）。时间片用完后，如果进程还没结束，就把它移到队尾，然后调度队首的新进程。
	1. 优点:
	       响应快: 特别适合分时系统和交互式系统，用户不会感觉自己的程序被完全阻塞。
	       不会饥饿: 每个进程都能在一定时间内（至多是 $(n-1) \times q$ 时间，其中n是进程数，q是时间片长度）获得一次CPU时间。
	2. 缺点:
	       不满足短任务优先: 它对所有任务一视同仁，不关心任务长短。一个短任务可能需要轮转好几次才能完成。
	       上下文切换开销: 时间片如果太小，会导致频繁的上下文切换，增加系统开销。  [[进程状态模型]] 
3.  #多级反馈队列调度算法 （ #高响应比优先 ） (Multilevel Feedback Queue Scheduling)：
       这是集大成者，也是非常重要的考点。它完美体现了动态优先级的思想。
       工作原理：
        1.  设置多个就绪队列，每个队列有不同的优先级（高优先级队列通常时间片更短）。
        2.  新进程首先进入最高优先级队列。
        3.  如果进程用完了当前队列的时间片，它会被降级到下一个更低优先级的队列。
        4.  如果进程在时间片用完前主动放弃CPU（例如去进行I/O），它下次会回到原来的队列或更高优先级的队列。
        5.  在低优先级队列中等待时间过长的进程，会被提升到更高优先级的队列（老化）。
       优点：兼顾了各种类型的进程。对交互式/I/O型进程（短CPU脉冲）响应快，对CPU型进程（长CPU脉冲）也能保证其运行，同时通过老化防止饥饿。
4. #静态优先数调度  #静态优先级调度 
	*   **工作原理：** 每个进程在创建时被赋予一个固定的、不会改变的优先级。调度程序总是选择就绪队列中优先级最高的进程来执行。
	*   **是否导致饥饿：** **会**。这是一个典型的会导致饥饿的算法。如果有一个或多个高优先级的进程持续处于就绪状态（例如，它们是周期性任务或不断被I/O唤醒），那么一个低优先级的进程可能永远也无法获得CPU。
5. #非抢占式短作业优先SJF  
	*   **工作原理：** 调度程序从就绪队列中选择**估计运行时间最短**的作业，一旦选中，就让它一直运行直到完成，期间不会被抢占。
	*   **是否导致饥饿：** **会**。SJF可以看作是一种特殊的优先级调度，其中“作业长度”就是优先级（作业越短，优先级越高）。如果系统中有一个长作业正在等待，而此时不断有新的短作业到来，那么这个长作业的执行时间会一直被推迟，从而导致饥饿。
6. #抢占式短作业优先SRTF 
	*   **工作原理：** 调度程序总是选择**剩余运行时间最短**的进程来执行。如果一个新的进程进入就绪队列，其总运行时间比当前正在执行进程的*剩余*运行时间还要短，那么当前进程就会被抢占，新的短进程将获得CPU。
	*   **是否导致饥-饿：** **会**。这种算法对长作业更加不友好。一个长作业不仅可能在等待时被新来的短作业“插队”，甚至在已经开始执行后，还可能被一个更短的新作业抢占CPU。如果短作业源源不断，长作业可能永远无法完成，导致严重的饥饿问题。
