![[Pasted image 20251215210807.png]]

### 知识点一：堆的插入和删除的具体过程

**核心考点：**
*   **插入（Insert）：** 将新元素放到堆的末尾，然后执行“上滤”（Shift Up / Swim）操作。
*   **删除（Delete）：** 通常指删除堆顶元素。将堆顶元素与堆底最后一个元素交换，删除最后一个元素，然后对新的堆顶执行“下滤”（Shift Down / Sink）操作。

#### 【模拟题 1：堆的插入】
**题目：**
已知一个大根堆（Max Heap）的数组序列为 $\{90, 80, 70, 60, 40, 30, 20\}$。现在要插入元素 **85**，请写出插入调整完成后的数组序列。

**【解析】**
1.  **放入末尾：** 将 85 放在数组最后位置。
    *   当前序列：$\{90, 80, 70, 60, 40, 30, 20, \mathbf{85}\}$
    *   逻辑结构：85 是 60（索引3）的左孩子（索引7）。
2.  **上滤（对比父节点）：**
    *   85 与其父节点 60 对比。因为 $85 > 60$，不满足大根堆性质，**交换**。
    *   序列变动：$\{90, 80, 70, \mathbf{85}, 40, 30, 20, \mathbf{60}\}$
    *   此时 85 的父节点是 80（索引1）。
3.  **继续上滤：**
    *   85 与其父节点 80 对比。因为 $85 > 80$，**交换**。
    *   序列变动：$\{90, \mathbf{85}, 70, \mathbf{80}, 40, 30, 20, 60\}$
    *   此时 85 的父节点是 90（索引0）。
4.  **终止：**
    *   85 与 90 对比， $85 < 90$，满足堆性质，停止。

**答案：** $\{90, 85, 70, 80, 40, 30, 20, 60\}$

---

#### 【模拟题 2：堆的删除】
**题目：**
在一个小根堆（Min Heap）$\{10, 20, 15, 40, 50, 30, 35\}$ 中，执行一次删除堆顶元素的操作，请写出调整后的数组序列。

**【解析】**
1.  **替换堆顶：**
    *   删除堆顶 10，用序列最后一个元素 **35** 填补堆顶位置。
    *   临时序列：$\{\mathbf{35}, 20, 15, 40, 50, 30\}$ （35 暂时移除了）
2.  **下滤（对比子节点）：**
    *   当前堆顶是 35。它的左孩子是 20，右孩子是 15。
    *   在小根堆中，找最小的孩子。右孩子 15 最小，且 $15 < 35$。
    *   **交换** 35 和 15。
    *   序列变动：$\{15, 20, \mathbf{35}, 40, 50, 30\}$
3.  **继续下滤：**
    *   此时 35 在索引 2 的位置。它的左孩子是 30（索引5），无右孩子。
    *   对比 35 和 30。因为 $30 < 35$，**交换**。
    *   序列变动：$\{15, 20, \mathbf{30}, 40, 50, \mathbf{35}\}$
4.  **终止：** 35 已经是叶子节点，无法继续下沉。

**答案：** $\{15, 20, 30, 40, 50, 35\}$

---

### 知识点二：习题解析中的常见结论

**核心考点：**
这类考点通常涉及堆的性质、高度、复杂度等理论判断。

#### 【模拟题 3：性质判断】
**题目：**
关于堆（Heap）的数据结构，以下说法错误的是（ ）？
A. 建堆（Build Heap）的时间复杂度为 $O(n)$。
B. 堆排序的时间复杂度为 $O(n \log n)$。
C. 在一个大根堆中，最小的元素一定在叶子节点上。
D. 第 $k$ 小的元素可以通过 $k$ 次删除堆顶操作在 $O(k)$ 时间内找到。

**【解析】**
*   **A 正确：** 这是一个经典的结论。虽然单次插入是 $\log n$，但自下而上的线性建堆算法数学推导结果是收敛于线性的 $O(n)$。
*   **B 正确：** 堆排序是不稳定的排序，平均和最坏复杂度都是 $O(n \log n)$。
*   **C 正确：** 大根堆的性质是父节点大于子节点，因此越往下越小，最小值一定分布在某一个叶子节点（不一定是最后一个）。
*   **D 错误：** 每次删除堆顶后需要重新调整堆（下滤），调整的时间复杂度是 $O(\log n)$。进行 $k$ 次删除的总时间应该是 $O(k \log n)$，而不是 $O(k)$。

**答案：** D

---

### 知识点三：堆排序的具体过程

**核心考点：**
1.  **初始建堆：** 从最后一个非叶子节点开始，自下而上进行调整。
2.  **排序过程：** 将堆顶元素与末尾交换（固定最大值），然后对剩余元素进行一次堆调整。

#### 【模拟题 4：堆排序全过程】
**题目：**
给定待排序序列 $A = \{5, 3, 17, 10, 84, 19, 6, 22, 9\}$。
1.  请写出将其调整为**大根堆（初始堆）**后的序列。
2.  基于构建好的初始堆，输出**第一趟排序**后的序列状态。

**【解析】**

**第一步：构建初始大根堆**
*   数组索引：0~8。最后一个非叶子节点索引为 $\lfloor (9-1)/2 \rfloor = 4$，即元素 **84**。
*   **调整节点 4 (84)：** 左孩子 22(索引9)不存在? 抱歉，题目里有9个元素。
    *   数组：$[5, 3, 17, 10, 84, 19, 6, 22, 9]$
    *   索引 4 是 84。左孩子索引9 (9)。右孩子无。$84 > 9$，无需调整。
*   **调整节点 3 (10)：** 左孩子 22(索引7)，右孩子 9(索引8)。
    *   $22 > 10$，交换 10 和 22。
    *   序列：$[5, 3, 17, \mathbf{22}, 84, 19, 6, \mathbf{10}, 9]$
*   **调整节点 2 (17)：** 左孩子 19，右孩子 6。
    *   $19 > 17$，交换 17 和 19。
    *   序列：$[5, 3, \mathbf{19}, 22, 84, \mathbf{17}, 6, 10, 9]$
*   **调整节点 1 (3)：** 左孩子 22，右孩子 84。
    *   最大孩子是 84。交换 3 和 84。
    *   序列：$[5, \mathbf{84}, 19, 22, \mathbf{3}, 17, 6, 10, 9]$
    *   *连锁反应：* 3 被换到了索引4。3 的左孩子是 9 (索引9，无)。3的左孩子应为索引9。等等，原数组长度为9个元素，最大索引是8。
    *   *纠正索引计算：*
        *   Index: 0(5), 1(3), 2(17), 3(10), 4(84), 5(19), 6(6), 7(22), 8(9).
        *   Node 4 (84): 左孩子 index 9 (越界). 无需调整。
        *   Node 3 (10): 左 22, 右 9. Swap 10 & 22. -> $[..., 22, 84, ..., 10, 9]$
        *   Node 2 (17): 左 19, 右 6. Swap 17 & 19. -> $[..., 19, ..., 17, 6, ...]$
        *   Node 1 (3): 左 22, 右 84. Swap 3 & 84. -> $[5, \mathbf{84}, 19, 22, \mathbf{3}, 17, 6, 10, 9]$
            *   *Check Node 4 (now 3):* Leaf. OK.
        *   Node 0 (5): 左 84, 右 19. Swap 5 & 84. -> $[\mathbf{84}, \mathbf{5}, 19, 22, 3, 17, 6, 10, 9]$
            *   *Check Node 1 (now 5):* 左 22, 右 3. Swap 5 & 22. -> $[84, \mathbf{22}, 19, \mathbf{5}, 3, 17, 6, 10, 9]$
            *   *Check Node 3 (now 5):* 左 10, 右 9. Swap 5 & 10. -> $[84, 22, 19, \mathbf{10}, 3, 17, 6, \mathbf{5}, 9]$

**初始大根堆答案：** $\{84, 22, 19, 10, 3, 17, 6, 5, 9\}$

**第二步：第一趟排序**
*   **交换：** 将堆顶（84）与末尾元素（9）交换。84 归位（已排序）。
    *   序列：$\{\mathbf{9}, 22, 19, 10, 3, 17, 6, 5, \mathbf{84}\}$
*   **调整（对前8个元素）：** 堆顶现在是 9，需要下沉。
    *   9 的孩子是 22 和 19。最大是 22。交换 9 和 22。
    *   序列：$\{22, \mathbf{9}, 19, 10, 3, 17, 6, 5, | 84\}$
    *   现在 9 在索引1。孩子是 10 和 3。最大是 10。交换 9 和 10。
    *   序列：$\{22, 10, 19, \mathbf{9}, 3, 17, 6, 5, | 84\}$
    *   现在 9 在索引3。孩子是 5 和 (索引8已在堆外)。最大是 5。$9 > 5$，无需交换。

**第一趟排序后答案：** $\{22, 10, 19, 9, 3, 17, 6, 5, 84\}$

---

### 总结
这张图片提示你要特别注意**手动模拟**算法过程的能力。
1.  **画图法：** 做这类题时，务必在草稿纸上画出二叉树结构，不要光看数组，容易看错索引。
2.  **区分方向：** 插入是从下往上（找爸爸），删除/建堆是从上往下（找最大的儿子）。
3.  **边界条件：** 注意最后一个节点是否有左右孩子。