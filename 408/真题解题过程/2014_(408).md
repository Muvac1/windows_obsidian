![[2014-exam-paper-ocr.pdf#page=1&rect=72,609,547,700|2014-exam-paper-ocr, p.1]]
[[Pasted image 20250909031611.png]]
1. `for (j=1; j<=n; j++)`  [[时间复杂度分析]]
	1. 这个循环从1开始，每次加1，直到`j`大于`n`为止。因此，对于每一次外层循环，这个内层循环都会执行 **n** 次。它的时间复杂度是$O(n)$
2. `for (k=1; k<=n; k*=2)` 
	1. 循环的终止条件是$k>n$。也就是说，循环会一直执行，直到$2^{x-1} > n$。我们可以反过来思考，循环执行的条件是$k \le n$，即：
		$2^{x-1} \le n$ 
		解出$x$，我们对两边取以2为底的对数：
		$\log_2(2^{x-1}) \le \log_2 n$
		$x-1 \le \log_2 n$
		$x \le \log_2 n + 1$
	所以，外层循环的执行次数$x$大约是$\log_2 n$次。因此，外层循环的时间复杂度是$O(\log_2 n)$常写为$O(\log n)$  
	嵌套循环结构，内层循环的执行次数不依赖于外层循环的变量`k`。根据 #时间复杂度的乘法法则  
	$T(n) = O(n\log_2 n)$  
- 对[[数阶复杂度的识别]] ($O(\log n)$) 的识别 
- 衍生
	- 内层循环依赖于外层循环变量 
		- 把内层循环的条件`j<=n`改成`j<=k`：
    ```c
    for (k=1; k<=n; k*=2)
        for (j=1; j<=k; j++)
            count++;
    ```
    这时，总执行次数不再是简单的相乘。我们需要将内层循环的执行次数进行累加：
    当 $k=1$ 时，内层执行1次。
    当 $k=2$ 时，内层执行2次。
    当 $k=4$ 时，内层执行4次。
    ...
    直到 $k$ 的最大值（约为$n$）。
    总执行次数 = $1 + 2 + 4 + 8 + \dots + 2^{\log_2 n}$。这是一个等比数列求和。
    总和 $S = \frac{a_1(1-q^m)}{1-q} = \frac{1(1-2^{\log_2 n + 1})}{1-2} = 2^{\log_2 n + 1} - 1 = 2n - 1$。
    因此，这种变种的时间复杂度是$O(n)$。
- #循环变量步长变化 
	*   **算术级数**：`for (i=1; i<=n; i+=c)`，复杂度为$O(n)$。
    *   **平方根**：`for (i=1; i*i<=n; i++)`，循环在$i \approx \sqrt{n}$时停止，复杂度为$O(\sqrt{n})$。
-  #多个并列循环 
   ```c
    for (i=1; i<=n; i++) { ... } // O(n)
    for (j=1; j<=n; j*=2) { ... } // O(log n)
    ```
    根据**加法法则**，总复杂度为$O(\max(n, \log n)) = O(n)$
 - 递归函数的时间复杂度 
	 - 除了循环，递归也是一个重要的考点。例如，计算 #斐波那契数列的递归算法 ，其时间复杂度是指数级的$O(2^n)$。而 #二分查找的递归实现 ，其时间复杂度是对数级的$O(\log n)$。分析递归通常需要使用主定理（Master Theorem）或递归树


![[2014-exam-paper-ocr.pdf#page=1&rect=74,562,531,609|2014-exam-paper-ocr, p.1]]
1. [[表达式转换（前中后缀）]] 
	1. [[栈]]
**运算符处理规则（关键部分）：**
*   **遇到左括号`(`**：直接压入栈中。
*   **遇到右括号`)`**：将栈顶的运算符依次弹出并输出，直到遇到左括号`(`为止。左括号`(`也从栈中弹出，但**不输出**。
*   **遇到其他运算符**（`+`, `-`, `*`, `/`）：
    *   若栈为空，或栈顶元素为`(`，则直接将该运算符压入栈中。
    *   否则，比较该运算符与栈顶运算符的**优先级**。
        *   若该运算符的优先级**高于**栈顶运算符，则将其压入栈中。
        *   若该运算符的优先级**小于或等于**栈顶运算符，则将栈顶运算符弹出并输出，然后**再次**将当前运算符与新的栈顶运算符比较，重复此过程，直到当前运算符可以被压入栈中。

B
 [[Pasted image 20250909032332.png]]
[[Pasted image 20250909032350.png]]
- #后缀表达式求值 
	这是另一个经典的栈应用。给定一个后缀表达式，如 $ab/cd*ef*-g+$，计算其值。
    *   **算法**：从左到右扫描表达式，使用一个**操作数栈**。
    *   遇到**操作数**，压入栈中。
    *   遇到**运算符**，从栈中弹出两个操作数（注意顺序：先弹出的是右操作数，后弹出的是左操作数），进行运算，并将结果压回栈中。
    *   扫描结束后，栈中唯一剩下的元素就是最终结果。
- #前缀表达式求值 
	与后缀求值类似，但需要**从右到左**扫描。
    *   遇到**操作数**，压入栈中。
    *   遇到**运算符**，从栈中弹出两个操作数（先弹出的是左操作数，后弹出的是右操作数），运算后将结果压回栈中。
- #表达式的等价性 
	- 可能会给出多个不同形式的表达式（中缀、前缀、后缀），判断它们是否代表同一个运算逻辑。解决方法是将它们都转换为同一种形式（通常是后缀或中缀）进行比较
- #运算符的结合性 
	- 在处理 #右结合运算符 时 比如幂运算`^`，中缀转后缀的规则需要微调：当待处理的运算符优先级与栈顶运算符**相同时**，当前运算符直接入栈，而不是弹出栈顶元素  





![[2014-exam-paper-ocr.pdf#page=1&rect=77,455,534,561|2014-exam-paper-ocr, p.1]]
[[Pasted image 20250909032402.png]]
1. 考察的是用一维数组实现循环队列时，如何判断队列为空（队空）和队列为满（队满）的条件。我们来一步步推导 
	1. 队列中最多能容纳 $M-1$ 个元素。这个条件非常关键，它暗示了我们使用“牺牲一个存储单元”的方法来区分队空和队满 
2. 推导队空的条件  [[判别队列空满的状态]]
	*   队列初始状态为空。按照惯例，初始化时队头和队尾指针指向同一个位置，比如下标0。即 $end1 = 0$, $end2 = 0$。
	*   当队列为空时，没有任何元素。此时，队头指针 `end1` 和队尾指针 `end2` 相遇。
	*   因此，**队空的判断条件是：$end1 == end2$**。
	*   根据这个条件，我们可以排除选项 C 和 D。
3.  推导队满的条件 
	1.  题目明确指出，队列最多容纳 $M-1$ 个元素，而数组大小为 $M$。这意味着当队列满时，数组中还有一个空闲的位置。
	2.   我们通过一个具体的例子来推导。假设队列从数组下标0开始入队，一直到队满。
    *   入队第1个元素，存放在 `A[0]`。
    *   ...
    *   入队第 $M-1$ 个元素，存放在 `A[M-2]`。
*   此时，队列已满，包含了 $M-1$ 个元素。我们来看指针的状态：
    *   队头元素在 `A[0]`，所以队头指针 $end1 = 0$
    *   队尾元素在 `A[M-2]`，而 `end2` 指向队尾元素的**后一个位置**，所以队尾指针 $end2 = M-1$。
*   现在我们来验证选项 A 和 B 中队满的条件：
    *   **选项 A 的条件**: $end1 == (end2 + 1) \pmod M$
        *   将 $end1 = 0$ 和 $end2 = M-1$ 代入：
        *   $0 == ((M-1) + 1) \pmod M$
        *   $0 == M \pmod M$
        *   $M \pmod M$ 的结果是 0。所以等式 $0 == 0$ 成立。
    *   **选项 B 的条件**: $end2 == (end1 + 1) \pmod {M-1}$
        *   首先，模数是 $M-1$ 是不正确的，因为数组的循环周期是 $M$（下标从0到$M-1$）。仅凭这一点就可以判断 B 是错误的。
        *   即使我们代入验证：$M-1 == (0 + 1) \pmod {M-1}$
        *   $M-1 == 1 \pmod {M-1}$
        *   $1 \pmod {M-1}$ 的结果是 1 (假设$M>2$)。等式 $M-1 == 1$ 显然不成立。

*   **结论**: 队满的条件是 $end1 == (end2 + 1) \pmod M$。这个条件的几何意义是，在循环的意义下，队尾指针 end2 的下一个位置就是队头指针 `end1`，这表示队列已经满了，只留下一个“隔离”空间。
1. 综合以上两点：
	*   队空条件: $end1 == end2$
	*   队满条件: $end1 == (end2 + 1) \pmod M$ 
A  
- 衍生 
1. [[循环队列]] [[循环队列判别队空与队满的三种方法]] 
	1. #指针定义的变化
		考试中另一个常见的“陷阱”是改变指针的定义。本题的定义是**最常见**的一种：
		*   `front` (即 `end1`): 指向**队头元素**。
		*   `rear` (即 `end2`): 指向**队尾元素的下一个位置**。
		还有一种定义方式：
		*   `front`: 指向**队头元素的前一个位置**。
		*   `rear`: 指向**队尾元素**。
		如果采用这种定义，那么入队和出队的操作以及判空/判满的条件都会相应改变：
		*   **初始化**: `front = rear = 0` (或-1，取决于约定)
		*   **入队**: `rear = (rear + 1) % M; A[rear] = x;`
		*   **出队**: `front = (front + 1) % M; x = A[front];` 
		*   **队空条件**: `front == rear`
		*   **队满条件**: `(rear + 1) \pmod M == front` (牺牲一个单元的情况下)
	* 无论指针如何定义，在使用“ #牺牲一个单元”法时，队空和队满的条件表达式是相同的，但入队和出队操作中指针移动和存取数据的先后顺序会不同。做题时一定要**首先看清指针的定义**。 
* #计算队列长度 
	* 在本题的指针定义下，队列长度 `length` 的计算公式为：
		$length = (end2 - end1 + M) \pmod M$ 
		这个公式可以优雅地处理 `end2` < `end1` 的回环情况。例如，当 $end1=0, end2=M-1$ 时，长度为 $(M-1 - 0 + M) \pmod M = (2M-1) \pmod M = M-1$`，是正确的。当队列为空 `$end1 == end2$ 时，长度为0



![[2014-exam-paper-ocr.pdf#page=1&rect=74,355,500,455|2014-exam-paper-ocr, p.1]]
[[Pasted image 20250909032412.png]]
- [[线索二叉树]]  [[前驱后继，前中后序]] [[中序线索化]] 
	- **左线索**：如果一个结点的左孩子指针为空，则该指针被改造为指向其**中序前驱**的线索。
	- **右线索**：如果一个结点的右孩子指针为空，则该指针被改造为指向其**中序后继**的线索。
1. 二叉树的中序遍历
	1. 左-根-右
2.  线索二叉树
-  解题
1. 第一步：写出该二叉树的中序遍历序列 
	1.  从根结点`a`开始，先访问其左子树（以`b`为根）。
	2.  在`b`结点，先访问其左子树（以`d`为根）。
	3.  在`d`结点，它没有左子树，所以先访问根结点`d`。
	4.  然后访问`d`的右子树（结点`e`）。`e`没有左右子树，直接访问`e`
	5.  `d`的左右子树都访问完毕，`d`子树的遍历结果是 `d, e`。
	6.  回到`b`，左子树（`d`子树）已访问完。现在访问根结点`b`。
	7.  然后访问`b`的右子树（结点`x`）。`x`没有左右子树，直接访问`x`。
	8.  `b`的左右子树都访问完毕，`b`子树的遍历结果是 `d, e, b, x`。
	9.  回到`a`，左子树（`b`子树）已访问完。现在访问根结点`a`。
	10. 最后访问`a`的右子树（结点`c`）。`c`没有左右子树，直接访问`c`。
		1. 完整的中序遍历序列为： d, e, b, x, a, c
2. 第二步：在序列中找到结点x的前驱和后继
	- 在序列中，紧邻`x`**之前**的结点是 `b`。因此，`x`的**中序前驱**是`b`。
	- 在序列中，紧邻`x`**之后**的结点是 `a`。因此，`x`的**中序后继**是`a`。
3. 第三步：确定线索指向并选择答案 
	1. 根据线索二叉树的定义：
	- 结点`x`在原树中没有左孩子，所以它的左指针域是空闲的，将被用作**左线索**，指向其中序前驱`b`。
	- 结点`x`在原树中没有右孩子，所以它的右指针域是空闲的，将被用作**右线索**，指向其中序后继`a`。
D
- 在不生成完整序列的情况下寻找前驱/后继
	- 寻找中序后继
		*   若结点`p`有右子树，则其后继是其**右子树中最左边的结点**。
		*   若结点`p`没有右子树，则其后继是“第一个在`p`的右边的祖先”，即从`p`向上回溯，直到找到一个结点，`p`是这个祖先结点的左子树的一部分。这个祖先结点就是`p`的后继。
		*   *例：* 结点`x`没有右子树，向上回溯到`b`，`x`是`b`的右孩子，继续回溯到`a`，`b`是`a`的左孩子，所以`a`是`x`的后继。
	- 寻找中序前驱 
		*   若结点`p`有左子树，则其前驱是其**左子树中最右边的结点**。
        *   若结点`p`没有左子树，则其前驱是“第一个在`p`的左边的祖先”，即从`p`向上回溯，直到找到一个结点，`p`是这个祖先结点的右子树的一部分。这个祖先结点就是`p`的前驱。
        *   *例：* 结点`x`没有左子树，向上回溯到`b`，`x`是`b`的右孩子，所以`b`是`x`的前驱。
- 线索二叉树的遍历算法 
    *   考察如何在已线索化的二叉树上进行中序遍历。由于有了线索，可以不使用栈或递归，实现一个循环迭代式的遍历算法，空间复杂度为$O(1)$





![[2014-exam-paper-ocr.pdf#page=1&rect=75,303,488,353|2014-exam-paper-ocr, p.1]]
[[截屏2025-09-09 上午3.33.21.png]]













![[2014-exam-paper-ocr.pdf#page=1&rect=72,255,443,306|2014-exam-paper-ocr, p.1]]
![[截屏2025-09-09 上午3.33.32.png]]

![[2014-exam-paper-ocr.pdf#page=1&rect=72,137,512,255|2014-exam-paper-ocr, p.1]]
![[截屏2025-09-09 上午3.33.41.png]]


![[2014-exam-paper-ocr.pdf#page=1&rect=72,86,525,138|2014-exam-paper-ocr, p.1]]
![[Pasted image 20250909033517.png]]

![[2014-exam-paper-ocr.pdf#page=1&rect=78,46,452,87|2014-exam-paper-ocr, p.1]]
![[Pasted image 20250909033523.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=78,768,527,814|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909033542.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=75,732,507,768|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909033806.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=77,684,514,733|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909033813.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=75,648,513,684|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909033820.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=77,602,526,649|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040125.png]]
![[Pasted image 20250909040135.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=76,550,529,604|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040144.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=78,502,449,549|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040153.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=74,438,531,502|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040204.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=79,376,521,443|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040410.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=73,317,528,381|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040417.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=75,266,531,319|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040424.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=80,194,373,267|2014-exam-paper-ocr, p.2]]
![[截屏2025-09-09 上午4.09.22.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=75,130,520,192|2014-exam-paper-ocr, p.2]]
![[截屏2025-09-09 上午4.09.29.png]]
![[截屏2025-09-09 上午4.09.41.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=81,73,420,130|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040948.png]]

#死锁 ![[2014-exam-paper-ocr.pdf#page=2&rect=72,27,529,74|2014-exam-paper-ocr, p.2]]![[截屏2025-09-09 上午4.10.00.png]]



![[2014-exam-paper-ocr.pdf#page=3&rect=72,779,501,825|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041014.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=73,729,458,783|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041027.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=71,671,527,736|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041036.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=76,622,492,670|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041049.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=73,571,515,625|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041056.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=78,497,521,574|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041104.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=76,420,371,501|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041111.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,373,469,420|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041117.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,338,473,372|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041125.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,181,525,335|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041132.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,148,504,184|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041144.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=73,64,519,148|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041209.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=77,754,530,820|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041217.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=77,678,525,754|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041228.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=76,630,487,682|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041355.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=81,590,474,631|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041402.png]]

![[2014-exam-paper-ocr.pdf#page=4&rect=80,476,531,594|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041414.png]]
![[Pasted image 20250909042005.png]]

![[2014-exam-paper-ocr.pdf#page=4&rect=76,41,537,481|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909042018.png]]
![[Pasted image 20250909042026.png]]
![[Pasted image 20250909042038.png]]
![[2014-exam-paper-ocr.pdf#page=5&rect=68,696,531,824|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042112.png]]


![[2014-exam-paper-ocr.pdf#page=5&rect=67,357,539,695|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042201.png]]
![[Pasted image 20250909042138.png]]





![[2014-exam-paper-ocr.pdf#page=5&rect=74,225,534,360|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042353.png]]
![[Pasted image 20250909042400.png]]

![[2014-exam-paper-ocr.pdf#page=5&rect=70,107,535,229|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042411.png]]


![[2014-exam-paper-ocr.pdf#page=5&rect=70,32,523,112|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042419.png]]
![[Pasted image 20250909042427.png]]