![[2014-exam-paper-ocr.pdf#page=1&rect=72,609,547,700|2014-exam-paper-ocr, p.1]]
[[Pasted image 20250909031611.png]]
1. `for (j=1; j<=n; j++)`  [[时间复杂度分析]]
	1. 这个循环从1开始，每次加1，直到`j`大于`n`为止。因此，对于每一次外层循环，这个内层循环都会执行 **n** 次。它的时间复杂度是$O(n)$
2. `for (k=1; k<=n; k*=2)` 
	1. 循环的终止条件是$k>n$。也就是说，循环会一直执行，直到$2^{x-1} > n$。我们可以反过来思考，循环执行的条件是$k \le n$，即：
		$2^{x-1} \le n$ 
		解出$x$，我们对两边取以2为底的对数：
		$\log_2(2^{x-1}) \le \log_2 n$
		$x-1 \le \log_2 n$
		$x \le \log_2 n + 1$
	所以，外层循环的执行次数$x$大约是$\log_2 n$次。因此，外层循环的时间复杂度是$O(\log_2 n)$常写为$O(\log n)$  
	嵌套循环结构，内层循环的执行次数不依赖于外层循环的变量`k`。根据 #时间复杂度的乘法法则  
	$T(n) = O(n\log_2 n)$  
- 对[[数阶复杂度的识别]] ($O(\log n)$) 的识别 
- 衍生
	- 内层循环依赖于外层循环变量 
		- 把内层循环的条件`j<=n`改成`j<=k`：
    ```c
    for (k=1; k<=n; k*=2)
        for (j=1; j<=k; j++)
            count++;
    ```
    这时，总执行次数不再是简单的相乘。我们需要将内层循环的执行次数进行累加：
    当 $k=1$ 时，内层执行1次。
    当 $k=2$ 时，内层执行2次。
    当 $k=4$ 时，内层执行4次。
    ...
    直到 $k$ 的最大值（约为$n$）。
    总执行次数 = $1 + 2 + 4 + 8 + \dots + 2^{\log_2 n}$。这是一个等比数列求和。
    总和 $S = \frac{a_1(1-q^m)}{1-q} = \frac{1(1-2^{\log_2 n + 1})}{1-2} = 2^{\log_2 n + 1} - 1 = 2n - 1$。
    因此，这种变种的时间复杂度是$O(n)$。
- #循环变量步长变化 
	*   **算术级数**：`for (i=1; i<=n; i+=c)`，复杂度为$O(n)$。
    *   **平方根**：`for (i=1; i*i<=n; i++)`，循环在$i \approx \sqrt{n}$时停止，复杂度为$O(\sqrt{n})$。
-  #多个并列循环 
   ```c
    for (i=1; i<=n; i++) { ... } // O(n)
    for (j=1; j<=n; j*=2) { ... } // O(log n)
    ```
    根据**加法法则**，总复杂度为$O(\max(n, \log n)) = O(n)$
 - 递归函数的时间复杂度 
	 - 除了循环，递归也是一个重要的考点。例如，计算 #斐波那契数列的递归算法 ，其时间复杂度是指数级的$O(2^n)$。而 #二分查找的递归实现 ，其时间复杂度是对数级的$O(\log n)$。分析递归通常需要使用主定理（Master Theorem）或递归树


![[2014-exam-paper-ocr.pdf#page=1&rect=74,562,531,609|2014-exam-paper-ocr, p.1]]
1. [[表达式转换（前中后缀）]] 
	1. [[栈]]
**运算符处理规则（关键部分）：**
*   **遇到左括号`(`**：直接压入栈中。
*   **遇到右括号`)`**：将栈顶的运算符依次弹出并输出，直到遇到左括号`(`为止。左括号`(`也从栈中弹出，但**不输出**。
*   **遇到其他运算符**（`+`, `-`, `*`, `/`）：
    *   若栈为空，或栈顶元素为`(`，则直接将该运算符压入栈中。
    *   否则，比较该运算符与栈顶运算符的**优先级**。
        *   若该运算符的优先级**高于**栈顶运算符，则将其压入栈中。
        *   若该运算符的优先级**小于或等于**栈顶运算符，则将栈顶运算符弹出并输出，然后**再次**将当前运算符与新的栈顶运算符比较，重复此过程，直到当前运算符可以被压入栈中。

B
 [[Pasted image 20250909032332.png]]
[[Pasted image 20250909032350.png]]
- #后缀表达式求值 
	这是另一个经典的栈应用。给定一个后缀表达式，如 $ab/cd*ef*-g+$，计算其值。
    *   **算法**：从左到右扫描表达式，使用一个**操作数栈**。
    *   遇到**操作数**，压入栈中。
    *   遇到**运算符**，从栈中弹出两个操作数（注意顺序：先弹出的是右操作数，后弹出的是左操作数），进行运算，并将结果压回栈中。
    *   扫描结束后，栈中唯一剩下的元素就是最终结果。
- #前缀表达式求值 
	与后缀求值类似，但需要**从右到左**扫描。
    *   遇到**操作数**，压入栈中。
    *   遇到**运算符**，从栈中弹出两个操作数（先弹出的是左操作数，后弹出的是右操作数），运算后将结果压回栈中。
- #表达式的等价性 
	- 可能会给出多个不同形式的表达式（中缀、前缀、后缀），判断它们是否代表同一个运算逻辑。解决方法是将它们都转换为同一种形式（通常是后缀或中缀）进行比较
- #运算符的结合性 
	- 在处理 #右结合运算符 时 比如幂运算`^`，中缀转后缀的规则需要微调：当待处理的运算符优先级与栈顶运算符**相同时**，当前运算符直接入栈，而不是弹出栈顶元素  





![[2014-exam-paper-ocr.pdf#page=1&rect=77,455,534,561|2014-exam-paper-ocr, p.1]]
[[Pasted image 20250909032402.png]]
1. 考察的是用一维数组实现循环队列时，如何判断队列为空（队空）和队列为满（队满）的条件。我们来一步步推导 
	1. 队列中最多能容纳 $M-1$ 个元素。这个条件非常关键，它暗示了我们使用“牺牲一个存储单元”的方法来区分队空和队满 
2. 推导队空的条件  [[判别队列空满的状态]]
	*   队列初始状态为空。按照惯例，初始化时队头和队尾指针指向同一个位置，比如下标0。即 $end1 = 0$, $end2 = 0$。
	*   当队列为空时，没有任何元素。此时，队头指针 `end1` 和队尾指针 `end2` 相遇。
	*   因此，**队空的判断条件是：$end1 == end2$**。
	*   根据这个条件，我们可以排除选项 C 和 D。
3.  推导队满的条件 
	1.  题目明确指出，队列最多容纳 $M-1$ 个元素，而数组大小为 $M$。这意味着当队列满时，数组中还有一个空闲的位置。
	2.   我们通过一个具体的例子来推导。假设队列从数组下标0开始入队，一直到队满。
    *   入队第1个元素，存放在 `A[0]`。
    *   ...
    *   入队第 $M-1$ 个元素，存放在 `A[M-2]`。
*   此时，队列已满，包含了 $M-1$ 个元素。我们来看指针的状态：
    *   队头元素在 `A[0]`，所以队头指针 $end1 = 0$
    *   队尾元素在 `A[M-2]`，而 `end2` 指向队尾元素的**后一个位置**，所以队尾指针 $end2 = M-1$。
*   现在我们来验证选项 A 和 B 中队满的条件：
    *   **选项 A 的条件**: $end1 == (end2 + 1) \pmod M$
        *   将 $end1 = 0$ 和 $end2 = M-1$ 代入：
        *   $0 == ((M-1) + 1) \pmod M$
        *   $0 == M \pmod M$
        *   $M \pmod M$ 的结果是 0。所以等式 $0 == 0$ 成立。
    *   **选项 B 的条件**: $end2 == (end1 + 1) \pmod {M-1}$
        *   首先，模数是 $M-1$ 是不正确的，因为数组的循环周期是 $M$（下标从0到$M-1$）。仅凭这一点就可以判断 B 是错误的。
        *   即使我们代入验证：$M-1 == (0 + 1) \pmod {M-1}$
        *   $M-1 == 1 \pmod {M-1}$
        *   $1 \pmod {M-1}$ 的结果是 1 (假设$M>2$)。等式 $M-1 == 1$ 显然不成立。

*   **结论**: 队满的条件是 $end1 == (end2 + 1) \pmod M$。这个条件的几何意义是，在循环的意义下，队尾指针 end2 的下一个位置就是队头指针 `end1`，这表示队列已经满了，只留下一个“隔离”空间。
1. 综合以上两点：
	*   队空条件: $end1 == end2$
	*   队满条件: $end1 == (end2 + 1) \pmod M$ 
A  
- 衍生 
1. [[循环队列]] [[循环队列判别队空与队满的三种方法]] 
	1. #指针定义的变化
		考试中另一个常见的“陷阱”是改变指针的定义。本题的定义是**最常见**的一种：
		*   `front` (即 `end1`): 指向**队头元素**。
		*   `rear` (即 `end2`): 指向**队尾元素的下一个位置**。
		还有一种定义方式：
		*   `front`: 指向**队头元素的前一个位置**。
		*   `rear`: 指向**队尾元素**。
		如果采用这种定义，那么入队和出队的操作以及判空/判满的条件都会相应改变：
		*   **初始化**: `front = rear = 0` (或-1，取决于约定)
		*   **入队**: `rear = (rear + 1) % M; A[rear] = x;`
		*   **出队**: `front = (front + 1) % M; x = A[front];` 
		*   **队空条件**: `front == rear`
		*   **队满条件**: `(rear + 1) \pmod M == front` (牺牲一个单元的情况下)
	* 无论指针如何定义，在使用“ #牺牲一个单元”法时，队空和队满的条件表达式是相同的，但入队和出队操作中指针移动和存取数据的先后顺序会不同。做题时一定要**首先看清指针的定义**。 
* #计算队列长度 
	* 在本题的指针定义下，队列长度 `length` 的计算公式为：
		$length = (end2 - end1 + M) \pmod M$ 
		这个公式可以优雅地处理 `end2` < `end1` 的回环情况。例如，当 $end1=0, end2=M-1$ 时，长度为 $(M-1 - 0 + M) \pmod M = (2M-1) \pmod M = M-1$`，是正确的。当队列为空 `$end1 == end2$ 时，长度为0



![[2014-exam-paper-ocr.pdf#page=1&rect=74,355,500,455|2014-exam-paper-ocr, p.1]]
[[Pasted image 20250909032412.png]]
- [[线索二叉树]]  [[前驱后继，前中后序]] [[中序线索化]] 
	- **左线索**：如果一个结点的左孩子指针为空，则该指针被改造为指向其**中序前驱**的线索。
	- **右线索**：如果一个结点的右孩子指针为空，则该指针被改造为指向其**中序后继**的线索。
1. 二叉树的中序遍历
	1. 左-根-右
2.  线索二叉树
-  解题
1. 第一步：写出该二叉树的中序遍历序列 
	1.  从根结点`a`开始，先访问其左子树（以`b`为根）。
	2.  在`b`结点，先访问其左子树（以`d`为根）。
	3.  在`d`结点，它没有左子树，所以先访问根结点`d`。
	4.  然后访问`d`的右子树（结点`e`）。`e`没有左右子树，直接访问`e`
	5.  `d`的左右子树都访问完毕，`d`子树的遍历结果是 `d, e`。
	6.  回到`b`，左子树（`d`子树）已访问完。现在访问根结点`b`。
	7.  然后访问`b`的右子树（结点`x`）。`x`没有左右子树，直接访问`x`。
	8.  `b`的左右子树都访问完毕，`b`子树的遍历结果是 `d, e, b, x`。
	9.  回到`a`，左子树（`b`子树）已访问完。现在访问根结点`a`。
	10. 最后访问`a`的右子树（结点`c`）。`c`没有左右子树，直接访问`c`。
		1. 完整的中序遍历序列为： d, e, b, x, a, c
2. 第二步：在序列中找到结点x的前驱和后继
	- 在序列中，紧邻`x`**之前**的结点是 `b`。因此，`x`的**中序前驱**是`b`。
	- 在序列中，紧邻`x`**之后**的结点是 `a`。因此，`x`的**中序后继**是`a`。
3. 第三步：确定线索指向并选择答案 
	1. 根据线索二叉树的定义：
	- 结点`x`在原树中没有左孩子，所以它的左指针域是空闲的，将被用作**左线索**，指向其中序前驱`b`。
	- 结点`x`在原树中没有右孩子，所以它的右指针域是空闲的，将被用作**右线索**，指向其中序后继`a`。
D
- 在不生成完整序列的情况下寻找前驱/后继
	- 寻找中序后继
		*   若结点`p`有右子树，则其后继是其**右子树中最左边的结点**。
		*   若结点`p`没有右子树，则其后继是“第一个在`p`的右边的祖先”，即从`p`向上回溯，直到找到一个结点，`p`是这个祖先结点的左子树的一部分。这个祖先结点就是`p`的后继。
		*   *例：* 结点`x`没有右子树，向上回溯到`b`，`x`是`b`的右孩子，继续回溯到`a`，`b`是`a`的左孩子，所以`a`是`x`的后继。
	- 寻找中序前驱 
		*   若结点`p`有左子树，则其前驱是其**左子树中最右边的结点**。
        *   若结点`p`没有左子树，则其前驱是“第一个在`p`的左边的祖先”，即从`p`向上回溯，直到找到一个结点，`p`是这个祖先结点的右子树的一部分。这个祖先结点就是`p`的前驱。
        *   *例：* 结点`x`没有左子树，向上回溯到`b`，`x`是`b`的右孩子，所以`b`是`x`的前驱。
- 线索二叉树的遍历算法 
    *   考察如何在已线索化的二叉树上进行中序遍历。由于有了线索，可以不使用栈或递归，实现一个循环迭代式的遍历算法，空间复杂度为$O(1)$





![[2014-exam-paper-ocr.pdf#page=1&rect=75,303,488,353|2014-exam-paper-ocr, p.1]]
[[截屏2025-09-09 上午3.33.21.png]]
1.   [[树到二叉树的转换规则]] 
	1. 左指针指向第一个孩子，右指针指向下一个兄弟
2. 一个结点如果**没有任何孩子结点**，那么它就是叶结点 
	1. 转换规则的第一条：对于树中的任意一个结点，它在二叉树中的**左孩子**是它在原树中的**第一个孩子**
	2. 如果一个结点在森林 F 中是叶结点，意味着它没有孩子，当然也就没有“第一个孩子”。因此，在转换到二叉树 T 后，这个结点**将没有左孩子** 
	3. 换句话说，它在二叉树 T 中的**左孩子指针为空 (null)**
3. 结论
	1. 森林 F 中有多少个叶结点，转换后的二叉树 T 中就有多少个左孩子指针为空的结点。因此，F 中叶结点的个数等于 T 中左孩子指针为空的结点个数
4. C 
	1. A. T 中叶结点的个数
		1. T 中的叶结点是指既没有左孩子也没有右孩子的结点。
		    - 没有左孩子意味着在 F 中是叶结点。
		    - 没有右孩子意味着在 F 中没有右兄弟。
		    所以，T 中的叶结点对应于 F 中**既是叶结点又是其父结点的最后一个孩子**的那些结点（或者是森林中最后一棵树的根，如果它也是叶结点的话）。这个数量通常小于或等于 F 中叶结点的总数。因此 A 错误。
	2. B. T #中度 为 1 的结点个数 
		T 中度为 1 的结点是指只有一个孩子（要么只有左孩子，要么只有右孩子）。
	    - 只有左孩子：对应 F 中有孩子但没有右兄弟的结点。
	    - 只有右孩子：对应 F 中没有孩子（是叶结点）但有右兄弟的结点。
	    这两种情况的组合与 F 中叶结点的总数没有直接的等价关系。因此 B 错误。
	3. D. T 中右孩子指针为空的结点个数 [[树到二叉树的转换规则]]
		1. T 中右孩子指针为空的结点，根据规则 2，意味着这个结点在 F 中**没有下一个兄弟结点**。这通常是其父结点的**最后一个孩子**，或者是森林中**最后一棵树的根**。这和它是不是叶结点（有没有孩子）是两个独立的概念。因此 D 错误
---
- 衍生
1. 数量关系 
	*   森林中的结点总数等于转换后二叉树的结点总数。设结点数为 $n$。
    *   在有 $n$ 个结点的二叉链表中，总共有 $2n$ 个指针域。其中 $n-1$ 个用于连接结点，所以空指针域的数量总是 $2n - (n-1) = n+1$。这是一个固定的性质。
* 结构关系 
    *   森林中一棵树的根，在二叉树中可能不是根结点（除了第一棵树）。
    *   森林中结点的度（孩子数量）不等于二叉树中对应结点的度。森林中结点 $N$ 的度等于其在二叉树中对应结点 $N$ 的左子树的结点数。
- #遍历的等价性 这是非常重要的考点  [[遍历序列的基本性质]]
	*   对森林进行**先根遍历**，其遍历序列与对转换后的二叉树进行**先序遍历**得到的序列**完全相同**。
    *   对森林进行**中根遍历**，其遍历序列与对转换后的二叉树进行**中序遍历**得到的序列**完全相同**。
    *   （注意：后根遍历不具有这种直接的等价性）
- 逆向转换
	*   给定一个二叉树，如何将其还原为森林？操作是转换规则的逆过程：
        *   一个结点 $N$ 的左子树的根是它的第一个孩子。
        *   这个左孩子的右兄弟是它右子树的根，以此类推，沿着右链找到所有兄弟。
		*   二叉树的根的右链（根、根的右孩子、右孩子的右孩子...）上的所有结点，是还原后森林中各棵树的根。


![[2014-exam-paper-ocr.pdf#page=1&rect=72,255,443,306|2014-exam-paper-ocr, p.1]]
[[截屏2025-09-09 上午3.33.32.png]]
[[前缀编码]] 
- 衍生 #哈夫曼编码  [[哈夫曼编码]]  #克拉夫特不等式  [[克拉夫特不等式]] 
1. #前缀编码核心规则 在一个编码方案中，任何一个字符的编码（码字）都不能是另一个字符编码的前缀
2. A. {01, 0000, 0001, 001, 1}
	1. `1` 不是任何其他码字的前缀。
    *   `01` 不是任何其他码字的前缀。
    *   `001` 不是任何其他码字的前缀。
    *   `0001` 不是 `0000` 的前缀，反之亦然。
    *   结论：选项 A 是前缀编码。
3. B. {011, 000, 001, 010, 1}
    *   `1` 不是任何其他码字的前缀。
    *   `011`, `000`, `001`, `010` 之间互不为前缀。
    *   结论：选项 B 是前缀编码。
4. C. {000, 001, 010, 011, 100} 
    *   这是一个 #定长编码 ，所有码字的长度都是3。在定长编码中，只要所有码字不完全相同，就不可能有一个码字是另一个码字的前缀。
    *   结论：选项 C 是前缀编码。
5. D. {0, 100, 110, 1110, 1100}
	   *   `1100` 的开头部分正好是 `110`。
    *   因此，码字 `110` 是码字 `1100` 的前缀。
    *   这违反了前缀编码的定义。
    *   结论：选项 D **不是**前缀编码。
[[前缀编码与二叉树]] 



![[2014-exam-paper-ocr.pdf#page=1&rect=72,137,512,255|2014-exam-paper-ocr, p.1]]
[[截屏2025-09-09 上午3.33.41.png]]
[[拓扑排序]] D 
- #拓扑实现的算法 [[实现拓扑排序的算法]] 
 - [[Kahn算法]]  (基于入度) 
	*   这是本题所使用的方法。
	    *   **步骤**：
	        1.  计算所有顶点的入度，并将所有入度为0的顶点放入一个队列（或集合）中。
	        2.  当队列不为空时，取出一个顶点 $u$，将其加入到拓扑排序结果序列中。
	        3.  遍历 $u$ 的所有邻接点 $v$，将边 $(u, v)$ “删除”，即把 $v$ 的入度减1。
	        4.  如果 $v$ 的入度减为0，则将 $v$ 加入队列。
	        5.  重复此过程直到队列为空。
	    *   **环路检测**：如果算法结束后，结果序列中的顶点数量少于图中总顶点数，说明图中存在环
* [[广度优先搜索（BFS）和深度优先搜索（DFS）]]  
	* DFS算法 (基于深度优先搜索) 
		1.  创建一个栈（或列表）来存储排序结果。
        2.  创建一个集合来记录已访问的顶点。
        3.  对图中的每一个顶点，如果它没有被访问过，就对它进行DFS。
        4.  在DFS函数中，当一个顶点的所有邻接点都已经被访问（即递归调用已返回）后，将该顶点压入栈中。
        5.  所有顶点都访问完毕后，从栈中依次弹出的顶点序列就是拓扑排序的结果（或者说，将列表反转）。
    *   **环路检测**：在DFS过程中，可以通过维护一个“递归栈”来检测环路。如果在访问一个顶点 $u$ 的邻接点 $v$ 时，发现 $v$ 已经存在于当前的递归路径上，则说明存在环
* 衍生
	* #判断序列合法性
		*   给出一个图和一个序列，判断该序列是否是该图的一个合法拓扑序列。
			*   **解法**：遍历序列，对于序列中的每个顶点 $v$，检查它的所有前驱（指向它的顶点）是否都已经在序列中它之前的位置出现过。如果对所有顶点都满足，则序列合法
	* 拓扑排序的唯一性
		* 题目可能会问：“该图的拓扑排序是否唯一？”
	    *   **解法**：在执行Kahn算法时，检查每一步中入度为0的顶点的队列（或集合）的大小。如果在任何时候，这个队列的大小超过1，那么拓扑排序就不是唯一的。如果从始至终队列大小都最多为1，则排序是唯一的。
	* 算法实现与复杂度
		* 复杂度分析：对于一个有 $V$ 个顶点和 $E$ 条边的图， #Kahn算法和DFS算法的时间复杂度 都是$O(V+E)$。因为每个顶点和每条边都只被访问常数次
	* [[关键路径]] 
![[2014-exam-paper-ocr.pdf#page=1&rect=72,86,525,138|2014-exam-paper-ocr, p.1]]

- [[哈希冲突解决办法和堆积的概念]]  
1. A. 存储效率
	1. 存储效率通常指哈希表中空间利用率。它主要与**装填因子**有关，即表中元素的数量与表总容量的比值。堆积只是改变了元素在表中的**位置分布**，并没有改变元素的总数或表的总容量，因此不直接影响存储效率
2. B. 散列函数
	1. 散列函数是一个预先确定的映射规则，用于计算元素的初始哈希地址，堆积现象本身并不会反过来改变或影响散列函数这个算法 
3. C. [[装填因子]] 
	1. $\alpha = \frac{\text{表中填入的记录数}}{\text{哈希表的长度}}$  这个值只与记录数和表长有关
		1. 装填因子是**导致**冲突和堆积概率增加的**原因**，但不是被堆积**影响**的**结果**
4. D. #平均查找长度ASL
	1. 衡量哈希表查找性能的关键指标，指找到一个元素平均需要进行的比较（探测）次数
	 *   **没有堆积时**：如果一个元素没有冲突，查找它只需要1次比较。
        *   **发生堆积时**：以上述例子为例，现在要查找关键字32。
            1.  计算 `H(32) = 2`。
            2.  比较位置2的元素，是12，不匹配。
            3.  向后探测，比较位置3的元素，是22，不匹配。
            4.  再向后探测，比较位置4的元素，是32，匹配成功。
        *   查找32需要进行3次比较。可见，堆积区域越长，查找位于堆积区域后部的元素所需的比较次数就越多。这会显著增加**平均查找长度**，从而降低查找效率

[[Pasted image 20250909033517.png]]
[[平均查找长度 (ASL)]]  [[常用哈希函数的设计方法]] 


![[2014-exam-paper-ocr.pdf#page=1&rect=78,46,452,87|2014-exam-paper-ocr, p.1]]

[[Pasted image 20250909033523.png]]
- [[B树]]  题目的核心是：在**关键字总数固定**的情况下，如何构造一棵B树，使其**结点总数最多**
- 建立一个简单的关系式：
	$总关键字数 = \sum_{i=1}^{结点总数} (第i个结点的关键字数)$ 
	让等式左边的“总关键字数”（15）不变，而等式右边的“结点总数”最大
	我们必须让每一项，即**每个结点包含的关键字数量尽可能少**
2. 有一棵 **4 阶 B 树**，即 $m=4$ 
	1. 确定每个结点的最少关键字数 
		*   对于**根结点**，最少可以有 $1$ 个关键字。
	    *   对于**非根结点**，最少可以有 $\lceil m/2 \rceil - 1$ 个关键字。
	        *   代入 $m=4$，最少关键字数为 $\lceil 4/2 \rceil - 1 = 2 - 1 = 1$
	2. 综合来看，在这棵4阶B树中，任何一个结点（无论是根结点还是非根结点）都最少可以只包含 **1** 个关键字 [[树的种类]]
3. 计算最大结点数
    *   我们的目标是让结点数最多。
    *   策略是让每个结点都只存储最少数量的关键字，即 1 个。
    *   总关键字数是 15。
    *   如果每个结点只放 1 个关键字，那么最多可以构成多少个结点？
        $最大结点数 = \frac{总关键字数}{每个结点的最少关键字数} = \frac{15}{1} = 15$
4. 验证结构是否合法
	1. 一个包含15个结点的B树，如果每个结点只有1个关键字，那么每个结点就会有 $1+1=2$ 个分支  
	2. 这实际上构成了一棵**满二叉树**
		1. 一棵高度为4的满二叉树正好有 $2^4-1=15$ 个结点。这个结构是完全合法的，并且满足4阶B树的所有定义（因为每个结点的关键字数1在允许的范围 $[1, 3]$ 内） 
D 
- 衍生
	- 在一棵具有 15 个关键字的 4 阶 B 树中，含关键字的结点个数最少是多少？  
		- 要使结点数最少，就需要让每个结点包含的 #关键字数量 最多  
		- **计算过程：**
		    1.  根据B树定义，一个 $m$ 阶B树的结点最多可以包含 $m-1$ 个关键字。
		    2.  对于 $m=4$，每个结点最多可以有 $4-1=3$ 个关键字。
		    3.  总关键字数为 15。
		    4.  $最少结点数 = \lceil \frac{总关键字数}{每个结点的最多关键字数} \rceil = \lceil \frac{15}{3} \rceil = 5$
	- 高度与关键字/结点数的关系
		- 一棵高度为 $h$ 的 $m$ 阶B树，最少/最多有多少个关键字？
			- 最少关键字数
				-  假设树的结构最“稀疏”。根结点有1个关键字（2个孩子），其他所有结点都只有 $\lceil m/2 \rceil - 1$ 个关键字（$\lceil m/2 \rceil$ 个孩子）。然后逐层计算结点数并乘以每层的最少关键字数
				-  **最多关键字数：** 假设树的结构最“茂密”。每个结点都填满，即都有 $m-1$ 个关键字（$m$ 个孩子）。然后逐层计算结点数并乘以每层的最多关键字数


![[2014-exam-paper-ocr.pdf#page=2&rect=78,768,527,814|2014-exam-paper-ocr, p.2]]
[[排序算法]]    [[希尔排序]] 
1. B
	*   **子序列1 (下标为 1, 4, 7):** 元素为 `[9, 13, 20]`。这个子序列是升序的。
	*   **子序列2 (下标为 2, 5, 8):** 元素为 `[1, 7, 23]`。这个子序列是升序的。
	*   **子序列3 (下标为 3, 6, 9):** 元素为 `[4, 8, 15]`。这个子序列是升序的。
	*   所有按增量3划分的子序列都是有序的。因此，增量可能是3。
[[Pasted image 20250909033542.png]]
- 时间复杂度 
	- 希尔排序的时间复杂度与所选用的增量序列密切相关 
	    *   **最坏情况**：如果增量序列选择不当（例如$8, 4, 2, 1$），时间复杂度会退化到$O(n^2)$。
	    *   **较优情况**：
	        *   Knuth提出的序列 $h_k = \frac{3^k - 1}{2}$，反向使用（例如$..., 40, 13, 4, 1$），其时间复杂度为$O(n^{3/2})$。
	        *   Sedgewick提出的序列，其时间复杂度可以达到$O(n^{4/3})$甚至$O(n \log^2 n)$。
	    *   至今，最优的增量序列仍然是一个开放的数学问题。
- 空间复杂度 
	- 希尔排序是原地排序算法，只需要一个额外的临时变量用于交换，所以空间复杂度为$O(1)$ 
- 稳定性 
	- 希尔排序是**不稳定**的。在对不同子序列进行排序时，相同元素的相对位置可能会发生改变。
- 衍生 
	- 正向推导 
		- 给定一个初始无序序列和一个增量序列（如$g=\{5, 3, 1\}$），要求写出第一趟或第二趟排序后的结果。 
	- 算法性质考察
		-   **增量序列的重要性**：提问为什么增量序列最后一个必须是1？（答案：为了保证最终整个序列一定是有序的，增量为1的希尔排序等价于一次完整的插入排序）。
	- 算法比较
	    *   与**插入排序**比较：希尔排序是对插入排序的改进，为什么它通常更快？（因为它允许元素进行大跨度的移动，能更快地将元素归位到其大致正确的位置）。
	    *   与**快速排序/归并排序**比较：在什么情况下可能会选择希尔排序？（希尔排序实现简单，且对于中等规模的数据集表现良好。它的空间复杂度为$O(1)$，优于归并排序的$O(n)$）。



![[2014-exam-paper-ocr.pdf#page=2&rect=75,732,507,768|2014-exam-paper-ocr, p.2]]
- [[快速排序]]
1. 在算法题目中，通常将  #完成一次分区操作（一趟） 视为“一 #趟 排序”。因此，题目中的“第 $i$ 趟排序结果”指的是已经完成了 $i$ 次分区操作后的数组状态。 
	1. 在快速排序的第 $i$ 趟排序完成后，数组中必定有至少 $i$ 个元素已经处在它们各自最终的、排序完成后的正确位置上
	2. 为什么是“至少” $i$ 个？ 
		1. 因为一次分区操作可能会将一个已经就位的元素（例如数组的第一个或最后一个元素）再次选为基准，但这并不增加新的已就位元素的数量。但在典型的递归调用中，每一趟（即每一次分区）都会将一个新的基准值放到其最终位置。因此，经过 $i$ 趟，至少有 $i$ 个元素就位了
2. 这意味着我们要寻找那个 #已就位元素数量 小于 2  的选项   
	一个元素 `A[k]` 是否“已就位”（在最终正确位置上），需要满足以下条件：
	*   它左边的所有元素都小于或等于 `A[k]`。
	*   它右边的所有元素都大于或等于 `A[k]`。
3. C
	1. 已就位的元素只有 `9`，共 1 个。因为 $1 < 2$，所以 C **不可能是**第 2 趟排序的结果

[[Pasted image 20250909033806.png]]
-  衍生 
	- 特定基准选择下的排序过程
		- 题目可能会给定一个初始序列，并指定每次都选择**第一个元素**或**最后一个元素**作为基准，要求写出第一趟或第二趟排序后的结果 
			- 对序列 `[6, 1, 2, 7, 9, 3]` 进行快速排序，以第一个元素为基准，第一趟排序后的结果是什么？
	        *   **解答**：基准为 `6`。分区后，比 `6` 小的放左边，大的放右边。结果为 `[3, 1, 2, 6, 9, 7]`。此时 `6` 已就位。
- 快速排序的 #时间复杂度分析  
	*   **最坏情况**：当每次选取的基准都是当前待排序列的最大或最小元素时（例如，对一个已经有序或逆序的序列，每次都选第一个元素为基准），分区会极度不平衡，导致时间复杂度退化为 $O(n^2)$。
    *   **最好情况**：当每次选取的基准都能将序列平分为两个长度几乎相等的子序列时，时间复杂度为 $O(n \log n)$。
    *   **平均情况**：在随机输入下，平均时间复杂度为 $O(n \log n)$
- [[快速排序的优化]] 
-  算法特性比较 
	-    **稳定性**：快速排序是一种**不稳定**的排序算法。因为在分区过程中，与基准相等的元素的相对位置可能会发生改变。
	*   **空间复杂度**：主要取决于递归调用的深度。最好和平均情况下为 $O(\log n)$，最坏情况下为 $O(n)$。
    *   **与其他 $O(n \log n)$ 算法的比较**：
        *   **归并排序**：稳定，时间复杂度稳定在 $O(n \log n)$，但需要 $O(n)$ 的额外空间。
        *   **堆排序**：不稳定，时间复杂度稳定在 $O(n \log n)$，空间复杂度为 $O(1)$（原地排序）。



![[2014-exam-paper-ocr.pdf#page=2&rect=77,684,514,733|2014-exam-paper-ocr, p.2]]
[[计算机性能评测的四个指标]]   [[CPU主频]] 
$时间_{new} = 0.7 \times 1.2 \times (IC_{old} \times CPI_{old} \times T_{clock})$
  $时间_{new} = 16.8秒$  
  - #CPU性能基本公式  
	  - $CPU执行时间 = \frac{指令数 \times CPI}{时钟频率}$ 
	  - $CPU执行时间 = 指令数 \times CPI \times 时钟周期时间$ 
[[Pasted image 20250909033813.png]] 
- 计算性能提升比 
	- 公式：$加速比 = \frac{优化前的执行时间}{优化后的执行时间}$
    *   **例题**：在本题中，加速比为 $20 / 16.8 \approx 1.19$。这意味着编译优化后，程序的执行速度是原来的1.19倍
- #MIPS每秒执行百万条指令数 
	- $MIPS = \frac{指令数}{执行时间 \times 10^6} = \frac{时钟频率}{CPI \times 10^6}$
- #加权平均CPI的计算 
	*   实际程序中包含多种类型的指令，每种指令的CPI可能不同。总的CPI是所有指令类型的加权平均值。
    *   公式：$CPI_{avg} = \sum_{i=1}^{n} (CPI_i \times F_i)$，其中 $CPI_i$ 是第i类指令的CPI，$F_i$ 是第i类指令在程序中所占的比例。
    *   **例题**：一个程序包含40%的算术指令（CPI=1）、40%的访存指令（CPI=2）和20%的分支指令（CPI=3）。优化后，算术指令比例变为50%，访存指令变为30%，分支指令变为20%。求优化前后的平均CPI和性能变化。
* [[阿姆达尔定律]] 
	* 公式：$总加速比 = \frac{1}{(1 - F_{可改进}) + \frac{F_{可改进}}{S_{改进部分}}}$，其中 $F_{可改进}$ 是可改进部分所占的原执行时间比例，$S_{改进部分}$ 是该部分的加速比




![[2014-exam-paper-ocr.pdf#page=2&rect=75,648,513,684|2014-exam-paper-ocr, p.2]]
- [[补码]] [[补码减法]]
1. [[补码加法溢出判断]]  
	1.   溢出是指运算结果超出了机器数所能表示的范围。对于8位补码，范围是 $[-128, 127]$。
C 
[[Pasted image 20250909033820.png]]
- 溢出检测的硬件实现 
	- 在计算机组成原理中，常考如何用逻辑门（特别是异或门）来检测溢出。如前所述，当符号位的进位与最高数值位的进位不同时溢出，这可以用一个异或门 `V = Cs ⊕ C1` 来实现 


![[2014-exam-paper-ocr.pdf#page=2&rect=77,602,526,649|2014-exam-paper-ocr, p.2]]
[[IEEE754单精度浮点数格式]] 
	比较两个以 IEEE 754 单精度浮点格式表示的数的大小 
1. 一个规格化的浮点数的真实值 V 的计算公式为：
	$V = (-1)^S \times (1.M)_2 \times 2^{(E-127)}$ 
- 方法一：按部就班计算法  
1. 分析变量 x (f1 = CC90 0000H)
	1. 转换为二进制
		1. `CC90 0000H` = `1100 1100 1001 0000 0000 0000 0000 0000` 
	2. 分解 S, E, M
        *   **S**: `1` (最高位) -> 这是一个负数。
        *   **E**: `1001 1001` (接下来的8位)
        *   **M**: `001 0000 ... 0000` (剩下的23位)
	3. 计算真实值
		*   符号：负。
		*   阶码 E (十进制): $(10011001)_2 = 128 + 16 + 8 + 1 = 153$。
        *   真实指数 e: $e = E - 127 = 153 - 127 = 26$。
        *   尾数 M: `00100...`，所以有效数字是 $(1.M)_2 = (1.001)_2$。
        *   所以，$x = -1 \times (1.001)_2 \times 2^{26}$
2. 分析变量 y (f2 = B0C0 0000H)
	1. 转换为二进制 
		1. `B0C0 0000H` = `1011 0000 1100 0000 0000 0000 0000 0000`  [[进制转化]] 
	2. 分解 S, E, M 
		*   **S**: `1` (最高位) -> 这是一个负数。
        *   **E**: `0110 0001` (接下来的8位)
        *   **M**: `100 0000 ... 0000` (剩下的23位)
	3. 计算真实值
		*   符号：负。
        *   阶码 E (十进制): $(01100001)_2 = 64 + 32 + 1 = 97$。
        *   真实指数 e: $e = E - 127 = 97 - 127 = -30$。
        *   尾数 M: `10000...`，所以有效数字是 $(1.M)_2 = (1.1)_2$。
        *   所以，$y = -1 \times (1.1)_2 \times 2^{-30}$。
3.  比较 x 和 y
	*   **符号**: 两个数的符号位 S 都是 1，所以它们都是负数，符号相同。因此可以排除选项 B 和 D。
    *   **大小**:
        *   $|x| = (1.001)_2 \times 2^{26}$ 是一个非常大的数。
        *   $|y| = (1.1)_2 \times 2^{-30}$ 是一个非常小的数（接近于0）。
        *   显然，$|x| > |y|$。
	*   对于两个负数，绝对值越大的数反而越小。因为 $|x| > |y|$，所以 $x < y$。
* $x < y$ 且符号相同。所以选择 **A** 
* 方法二：快速比较法 
1. #IEEE754编码的特性 有一个非常巧妙的特性： [[IEEE754单精度浮点数格式]]  [[进制表示法]]
	*   对于**正数**，如果将其 32 位二进制码看作一个无符号整数，那么这个整数的大小关系与它所代表的浮点数的大小关系是一致的。
	*   对于**负数**，情况则相反。如果将其 32 位二进制码看作一个无符号整数，那么整数越大的，其代表的浮点数反而越小（因为绝对值更大，离0更远）。
	*   `f1 = CC90 0000H`，最高位的十六进制数是 `C` (`1100`B)，其最高位是 `1`。所以 x 是负数。
    *   `f2 = B0C0 0000H`，最高位的十六进制数是 `B` (`1011`B)，其最高位是 `1`。所以 y 是负数。
    *   两者符号相同，排除 B 和 D。
2. 判断符号
	1.  `f1 = CC90 0000H`，最高位的十六进制数是 `C` (`1100`B)，其最高位是 `1`。所以 x 是负数
	2. `f2 = B0C0 0000H`，最高位的十六进制数是 `B` (`1011`B)，其最高位是 `1`。所以 y 是负数 
	3. 两者符号相同，排除 B 和 D 
3. 比较整数大小
	*   将 `CC90 0000H` 和 `B0C0 0000H` 直接当作 32 位无符号整数来比较。
    *   显然，`CC900000H > B0C00000H`。
    * 因为都是 负数 。由于 `(f1) > (f2)`，所以 $x < y$  

[[Pasted image 20250909040125.png]]
[[Pasted image 20250909040135.png]]
1. [[IEEE 754 标准 特殊值的表示]]  
2. #双精度浮点数  [[IEEE 754 标准双精度浮点数]]
	 *   64位表示：1位符号位，11位阶码，52位尾数。
    *   阶码偏置值为 1023。
    *   真实值公式：$V = (-1)^S \times (1.M)_2 \times 2^{(E-1023)}$。 
* #浮点数的精度和范围 
	* 单精度浮点数能表示的最大正数、 #最小的规格化正数 等  
	    *   **最大正数**: $S=0$, E 最大但非全1 (即254), M 全1。约 $3.4 \times 10^{38}$。
	    *   **最小规格化正数**: $S=0$, E 最小但非全0 (即1), M 全0。约 $1.18 \times 10^{-38}$。



![[2014-exam-paper-ocr.pdf#page=2&rect=76,550,529,604|2014-exam-paper-ocr, p.2]]
- 目的是计算一个特定规格的DRAM芯片的地址引脚和数据引脚的总数   [[地址总线与存储容量的关系]]  #地址引脚数的计算 
1. 计算 #数据引脚数  #存储器的容量 
	1. 4M x 8 位即一次可以读写8个比特（bit）的数据   
		1. 因此，需要8根线来传输这8位数据
		2. 数据引脚数 = $8$ 
	2.  "4M" 表示该芯片内部有4M个存储单元 
		1.  为了能够唯一地选中这4M个单元中的任意一个，我们需要计算出所需要的地址线条数。
	    *   首先，将 "4M" 转换为以2为底的幂：
	        *   M (Mega) 在计算机中通常表示 $2^{20}$。
	        *   4 表示 $2^2$。
        *   所以，4M = $4 \times M = 2^2 \times 2^{20} = 2^{22}$。、
	* 寻址 $N$ 个单元需要 $\log_2(N)$ 根地址线
	* 因此，总的地址位数 = $\log_2(2^{22}) = 22$ 位 
2. 计算 #地址引脚数   
	1. 这是本题最关键也是最容易出错的一步。题目明确指出芯片是 **DRAM**  
	2. DRAM为了减少芯片的引脚数量、降低成本和封装尺寸，普遍采用 #地址复用技术   [[DRAM地址复用技术]]  
	3. 22位的地址会分为两部分 #行地址   #列地址 
	4. 在寻址时，先通过地址引脚发送11位的行地址，再通过**同一组地址引脚**发送11位的列地址 
	5. 物理上需要的地址引脚数是总地址位数的一半。
    *   地址引脚数 = $\frac{\text{总地址位数}}{2} = \frac{22}{2} = 11$。
总引脚数 = 地址引脚数 + 数据引脚数 = $11 + 8 = 19$ 

[[Pasted image 20250909040144.png]]
- [[存储芯片容量]]  
	-    总容量 = $4M \times 8 \text{ bits} = 32 \text{ Mbits} = 4 \text{ MBytes}$ (因为 1 Byte = 8 bits)。 
- [[系统总线结构（数据线，地址线，控制总线）]] 
	- 数据线 
		- 用于在CPU和存储器之间双向传输数据。数据线的数量决定了数据传输的位宽
	- 地址线 
		- 用于从CPU向存储器发送地址信息，以选择特定的存储单元。它是单向的。地址线的数量 $n$ 决定了可寻址的最大空间，为 $2^n$
- 衍生
	- #存储器扩展 
		- 题目中给出的 "256MB的存储器" 是一个迷惑信息，但在衍生问题中非常重要。
			**问题**: 使用 "4M x 8 位" 的DRAM芯片构成一个 "256MB" 的存储器，需要多少片这样的芯片？
			1.  计算总容量（单位统一为bit）：
			    *   目标存储器容量: $256 \text{MB} = 256 \times 1024 \times 1024 \times 8 \text{ bits} = 2^8 \times 2^{20} \times 2^3 \text{ bits} = 2^{31} \text{ bits}$。
			    *   单片芯片容量: $4\text{M} \times 8 \text{ 位} = 2^{22} \times 8 \text{ bits} = 2^{22} \times 2^3 \text{ bits} = 2^{25} \text{ bits}$。
			2.  计算所需芯片数量：
			    *   芯片数量 = $\frac{\text{总容量}}{\text{单片容量}} = \frac{2^{31}}{2^{25}} = 2^6 = 64$ 片。
	-  如果本题中的芯片是 **SRAM** (Static RAM) 而不是DRAM，那么总引脚数是多少？ 
		-   SRAM**不使用** #地址复用技术 。
		*   数据引脚数仍然是 $8$。
		*   地址引脚数等于总地址位数，即 $22$。
		*   总引脚数 = 地址引脚数 + 数据引脚数 = $22 + 8 = 30$
	- #地址译码设计  
		- 在上述由64片 "4M x 8 位" 芯片构成的256MB存储器中，CPU需要多少根地址线？这些地址线如何分配？ 
			- CPU所需地址线总数 
				*   存储器总容量为256MB，按字节编址。
			    *   $256\text{MB} = 2^8 \times 2^{20} \text{ Bytes} = 2^{28}$ Bytes。
			    *   因此，CPU需要 $28$ 根地址线（A0-A27）来寻址整个256MB空间。
			- 地址线分配
				- 片内地址
					- 每片芯片有4M个单元，需要 $22$ 根地址线（$\log_2(4M) = 22$）来选择芯片内部的地址。通常，CPU地址线的低22位（A0-A21）会连接到**所有**芯片的地址引脚上 
				- 片选地址
					- 我们需要从64片芯片中选出1片。选择64个对象需要 $\log_2(64) = 6$ 根线。因此，CPU地址线的高6位（A22-A27）会连接到一个**地址译码器**（如6-64译码器），译码器的输出信号作为各个芯片的片选信号（Chip Select, CS）

![[2014-exam-paper-ocr.pdf#page=2&rect=78,502,449,549|2014-exam-paper-ocr, p.2]]
- [[指令流水线与冲突]]  #流水线的访存操作 [[高速缓存Cache]]
	-   **IF 阶段**：需要从内存中**读取指令**。
    *   **MEM 阶段**：对于 `load` (加载) 或 `store` (存储) 指令，需要从内存中**读取或写入数据**。
- 不 #分离Cache ( #统一Cache) 的问题
	- 如果指令和数据都存放在同一个 Cache（称为统一 Cache，Unified Cache）中，并且这个 Cache 只有一个读写端口，那么问题就出现了
	- 在某个时钟周期，流水线中的指令 `i` 是一条 `load` 指令，它正处于 `MEM` 阶段，需要访问 Cache 来读取数据。同时，流水线正在为指令 `i+k` (k通常是2或3，取决于流水线深度) 执行 `IF` 阶段，需要访问 Cache 来获取指令 
- 取指令， 取/存数据
	-  这两个操作需要**在同一个时钟周期内同时访问同一个 Cache**。由于 Cache 只有一个端口，它无法同时服务两个请求。这就产生了一种冲突，称为**结构冲突 (Structural Hazard)** 或**资源冲突 (Resource Conflict)**      
	- 为了解决这个冲突，流水线必须暂停 (stall)，让其中一个操作先完成，另一个再进行。这会降低流水线的效率 
	分离 Cache 的解决方案  设计师们提出了将 Cache 分离为两个独立的部分：
    *   #指令Cache (I-Cache)：专门存放指令。
    *   #数据Cache (D-Cache)：专门存放数据。 
*  Cache 是独立的硬件单元，拥有各自的访问端口。这样一来：
    *   `IF` 阶段的取指令操作总是访问 #I-Cache指令Cache 。
    *   `MEM` 阶段的访存操作总是访问 #D-Cache数据Cache 。
	它们是两个不同的物理资源，CPU 就可以在同一个时钟周期内，**同时进行取指令和取/存数据**的操作，从而避免了资源冲突，保证了流水线的流畅运行
指令 Cache 与数据 Cache 分离的**主要和直接目的**就是为了消除因同时访问存储器而引起的指令流水线资源冲突。这与选项 D 的描述完全一致

[[Pasted image 20250909040153.png]]
- [[高速缓存Cache]] 
- [[指令流水线与冲突]] 
- 衍生
	- [[流水线性能分析]] 
		- 例如：一个程序的理想 CPI 为 1，但由于使用了统一 Cache，20% 的指令是访存指令，并且其中 50% 的情况会与取指操作发生冲突，导致流水线暂停 1 个周期。问实际 CPI 是多少？
		- $CPI_{actual} = CPI_{ideal} + Stalls\_per\_instruction = 1 + 0.2 \times 0.5 \times 1 = 1.1$
 - 对比不同 Cache 架构的 AMAT
	 -  给出统一 Cache 和分离 Cache 的参数（总大小、命中率、命中时间等），要求计算并比较它们的 #平均访存时间AMAT
		 -   例如：一个 32KB 的统一 Cache 命中率为 97%。如果将其分为 16KB 的 I-Cache (命中率 98%) 和 16KB 的 D-Cache (命中率 95%)，假设访存指令占所有指令的 30%。计算两种方案的全局平均命中率或 AMAT
			 -  全局命中率 (分离) = $P_{I-Cache\_hit} \times (1 - P_{data\_access}) + P_{D-Cache\_hit} \times P_{data\_access}$
			 - $P_{global\_hit} = 0.98 \times (1 - 0.3) + 0.95 \times 0.3 = 0.686 + 0.285 = 0.971$ 
			 - 例子中，分离后的全局命中率略高于统一 Cache，但实际情况不一定如此
- 识别其他类型的[[指令流水线与冲突]]  
	- 给出一小段汇编代码，要求找出其中存在的数据冲突（RAW, WAR, WAW）或控制冲突，并说明解决方法（如转发/旁路、流水线暂停、分支预测等） #较复杂 




![[2014-exam-paper-ocr.pdf#page=2&rect=74,438,531,502|2014-exam-paper-ocr, p.2]]
- 核心是理解计算机指令是如何在有限的位数（32位）内编码所有必要信息的，包括操作码、寻址方式、寄存器编号和立即数（偏移量） 
1.  分析指令总体结构 [[指令集体系结构]] 
	1.  指令是**32位定长**的
	2.  操作码字段（Opcode）占 **8位**。这个字段告诉CPU要执行什么操作（比如 Store、Add、Load 等），并且题目说明它也包含了[[常见的寻址方式]] 的信息 
	3.   剩下的位数用于指定操作数。可用于操作数地址的位数 = 总位数 - 操作码位数。
        $32 - 8 = 24$ 位。
2. 分析 #源操作数
	1.   寻址方式：**寄存器直接寻址**。这意味着操作数本身就在一个寄存器里
		1. 计算机有 **16个通用寄存器**。为了从16个寄存器中唯一地选择一个，我们需要足够的位数来表示从0到15的编号
		2.   所需位数 $n$ 可以通过公式 $2^n \ge M$ 计算，其中 $M$ 是寄存器数量。这里 $M=16$
		3. $\log_2{16} = 4$ 位
		4. 指令中需要 **4位** 来指定源操作数所在的寄存器
3. 分析 #目的操作数 
    *   寻址方式：**基址寻址**。在这种方式下，最终的内存地址由一个基址寄存器的内容加上一个偏移量（Displacement）得到。
        *   `有效地址 = (基址寄存器内容) + 偏移量`
    *   题目指出，基址寄存器可以是**任一通用寄存器**。因此，和源操作数一样，我们也需要 **4位** 来指定16个通用寄存器中的哪一个作为基址寄存器。
4. 计算 #偏移量 的位数  [[基址寻址偏移量]]
	1. 总共有24位可用于编码两个操作数
	2.   源操作数用掉了4位（用于指定寄存器）
	3. 目的操作数用掉了4位（用于指定基址寄存器） 
	4. 那么，剩下的位数就全部留给了基址寻址中的**偏移量** 
		1. 偏移量的位数 = $24 - 4 - 4 = 16$ 位。
5. 确定 #偏移量的取值范围
   题目明确指出，偏移量用 #补码 (Two's Complement)  表示。
    *   对于一个 $n$ 位的补码整数，其表示的数值范围是 $[-2^{n-1}, 2^{n-1}-1]$。
    *   在这里，$n=16$，所以取值范围是：
        $[-2^{16-1}, 2^{16-1}-1]$
        $[-2^{15}, 2^{15}-1]$
        $[-32768, +32767]$ 
[[Pasted image 20250909040204.png]]

- [[指令格式]]  [[指令寻址方式]]  [[补码]] [[原码，反码的运算和溢出判断]]
- 衍生 
	- 改变寄存器数量
		- 如果题目改为“有32个通用寄存器”，那么指定一个寄存器就需要 $\log_2{32}=5$ 位。偏移量的位数就会减少为 $24 - 5 - 5 = 14$ 位，范围变为 $[-2^{13}, 2^{13}-1]$，即 $[-8192, +8191]$
	- 改变偏移量表示法
		*   如果题目改为“偏移量用**无符号数**表示”，那么16位偏移量的范围将是 $[0, 2^{16}-1]$，即 $[0, 65535]$。
	    *   如果题目改为“偏移量用 #原码表示”，那么16位偏移量的范围将是 $[-(2^{15}-1), 2^{15}-1]$，即 $[-32767, +32767]$
	* 改变寻址方式 
		* 如果目的操作数采用**直接寻址**（地址码直接是内存地址），那么整个24位都将作为内存地址，此时就没有偏移量的概念了。这种情况下，可寻址的内存空间为 $2^{24}$ 个单元
		* 如果指令是**三地址指令**，例如 `ADD R1, R2, D(R3)`（将 R2 的内容与 R3+D 地址处的内容相加，结果存入 R1），那么24位需要分配给三个操作数。比如 R1, R2, R3 各需4位，则偏移量D只剩下 $24 - 4 - 4 - 4 = 12$ 位 
	* #寻址范围计算 [[补码的表示范围]]  [[寻址范围，内存范围]] 
		* 可能会问“该指令能访问的最大内存范围是多少？” 这取决于基址寄存器的位数和偏移量的范围。如果 #基址寄存器 是32位的，那么理论上它可以指向整个 $2^{32}$ 的地址空间。 


![[2014-exam-paper-ocr.pdf#page=2&rect=79,376,521,443|2014-exam-paper-ocr, p.2]]
- 核心是计算 #微程序控制器 中， #控制存储器（控存）的地址空间大小 ，从而确定微指令中“ #下地址字段”所需的位数 
1. 计算执行阶段的微指令总数 
	1. 计算机系统有32条机器指令（或称指令）



[[Pasted image 20250909040410.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=73,317,528,381|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040417.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=75,266,531,319|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040424.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=80,194,373,267|2014-exam-paper-ocr, p.2]]
![[截屏2025-09-09 上午4.09.22.png]]


![[2014-exam-paper-ocr.pdf#page=2&rect=75,130,520,192|2014-exam-paper-ocr, p.2]]
![[截屏2025-09-09 上午4.09.29.png]]
![[截屏2025-09-09 上午4.09.41.png]]

![[2014-exam-paper-ocr.pdf#page=2&rect=81,73,420,130|2014-exam-paper-ocr, p.2]]
![[Pasted image 20250909040948.png]]

#死锁 ![[2014-exam-paper-ocr.pdf#page=2&rect=72,27,529,74|2014-exam-paper-ocr, p.2]]![[截屏2025-09-09 上午4.10.00.png]]



![[2014-exam-paper-ocr.pdf#page=3&rect=72,779,501,825|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041014.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=73,729,458,783|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041027.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=71,671,527,736|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041036.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=76,622,492,670|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041049.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=73,571,515,625|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041056.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=78,497,521,574|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041104.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=76,420,371,501|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041111.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,373,469,420|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041117.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,338,473,372|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041125.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,181,525,335|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041132.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=75,148,504,184|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041144.png]]


![[2014-exam-paper-ocr.pdf#page=3&rect=73,64,519,148|2014-exam-paper-ocr, p.3]]
![[Pasted image 20250909041209.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=77,754,530,820|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041217.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=77,678,525,754|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041228.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=76,630,487,682|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041355.png]]


![[2014-exam-paper-ocr.pdf#page=4&rect=81,590,474,631|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041402.png]]

![[2014-exam-paper-ocr.pdf#page=4&rect=80,476,531,594|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909041414.png]]
![[Pasted image 20250909042005.png]]

![[2014-exam-paper-ocr.pdf#page=4&rect=76,41,537,481|2014-exam-paper-ocr, p.4]]
![[Pasted image 20250909042018.png]]
![[Pasted image 20250909042026.png]]
![[Pasted image 20250909042038.png]]
![[2014-exam-paper-ocr.pdf#page=5&rect=68,696,531,824|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042112.png]]


![[2014-exam-paper-ocr.pdf#page=5&rect=67,357,539,695|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042201.png]]
![[Pasted image 20250909042138.png]]





![[2014-exam-paper-ocr.pdf#page=5&rect=74,225,534,360|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042353.png]]
![[Pasted image 20250909042400.png]]

![[2014-exam-paper-ocr.pdf#page=5&rect=70,107,535,229|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042411.png]]


![[2014-exam-paper-ocr.pdf#page=5&rect=70,32,523,112|2014-exam-paper-ocr, p.5]]
![[Pasted image 20250909042419.png]]
![[Pasted image 20250909042427.png]]