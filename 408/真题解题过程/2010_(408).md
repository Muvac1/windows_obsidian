![[2010-exam-paper-ocr.pdf#page=1&rect=75,651,515,708|2010-exam-paper-ocr, p.1]]
#栈 #进退栈 
D


![[2010-exam-paper-ocr.pdf#page=1&rect=75,600,525,651|2010-exam-paper-ocr, p.1]]
#出入队  #队列 
C


![[2010-exam-paper-ocr.pdf#page=1&rect=75,445,529,600|2010-exam-paper-ocr, p.1]]
#线索树  [[线索二叉树]]  [[前驱后继，前中后序]]
![[Pasted image 20250805012535.png]]
D


![[2010-exam-paper-ocr.pdf#page=1&rect=75,351,556,445|2010-exam-paper-ocr, p.1]]
#平衡二叉树 #平衡因子 #平衡旋转 [[平衡因子]] , [[平衡旋转]] #最小失衡指数 RL LR LL RR 
[[Pasted image 20250805013927.png]]
 C
![[2010-exam-paper-ocr.pdf#page=1&rect=72,309,541,372|2010-exam-paper-ocr, p.1]]
#度 #树 #节点结点 [[结点总数与度]] 
[[Pasted image 20250805035654.png]]
B


![[2010-exam-paper-ocr.pdf#page=1&rect=72,218,553,310|2010-exam-paper-ocr, p.1]]
#哈夫曼树  [[哈夫曼树]] [[树的种类]] 
![[Pasted image 20250805043140.png]]

A
![[2010-exam-paper-ocr.pdf#page=1&rect=72,166,571,219|2010-exam-paper-ocr, p.1]]
#无向图 [[无向图]]  #图 [[图的种类]] #保证无向图联通 
就是只要有16条必定会连通，不搞边怎么安排。  
任意变动图中的边，就那是移边的意思。  
删去一条果断只有15条了，那还谈什么至少，按你这么想，两个点都永远都不能连通。
[[Pasted image 20250805043632.png]]

C
![[2010-exam-paper-ocr.pdf#page=1&rect=76,42,521,168|2010-exam-paper-ocr, p.1]]

 ![[Pasted image 20250805061654.png]]
#Kahn算法 #拓扑排序 #有向无环图DAG [[Kahn算法]] [[拓扑排序]]

[[Pasted image 20250805043622.png]]

B

![[2010-exam-paper-ocr.pdf#page=2&rect=70,754,539,824|2010-exam-paper-ocr, p.2]]
#顺序表 #顺序表查找 #折半查找法（二分查找） #查找 [[顺序表查找方法]] [[顺序表]]

[[Pasted image 20250806053702.png]]
B

![[2010-exam-paper-ocr.pdf#page=2&rect=69,677,499,755|2010-exam-paper-ocr, p.2]]
#递归 #顺序表排序 #顺序表 #快速排序 [[排序算法]] 

- 处理顺序虽然不影响总次数，但影响“ #递归深度”！[[递归深度]] [[递归深度和递归次数的区别]]
[[Pasted image 20250806055344.png]]
[[快速排序]]
D
![[2010-exam-paper-ocr.pdf#page=2&rect=71,589,482,677|2010-exam-paper-ocr, p.2]]
[[Pasted image 20250807044126.png]] [[排序算法]]
A

![[2010-exam-paper-ocr.pdf#page=2&rect=75,541,497,592|2010-exam-paper-ocr, p.2]]
[[Pasted image 20250807045059.png]]
D 
$
![[2010-exam-paper-ocr.pdf#page=2&rect=73,491,529,541|2010-exam-paper-ocr, p.2]]
#补码  #补码的表示范围 #算术溢出 [[补码]]  #Hexadecimal（十六进制） [[进制表示法]]
- [[进制转化]],[[Pasted image 20250807051605.png]] 
- 这个 **H** 是 **Hexadecimal**（十六进制）的缩写。它是一个后缀，用来明确指出它前面的数字是一个**十六进制数**，而不是我们日常使用的十进制数。
- [[补码的表示范围]] 
[[Pasted image 20250807045037.png]]

B
![[2010-exam-paper-ocr.pdf#page=2&rect=72,403,541,492|2010-exam-paper-ocr, p.2]]
#补码  #单精度浮点数 #双精度浮点数  [[浮点数]] 
- [[数据类型转换]] 
- [[浮点数运算规则]] [[Pasted image 20250807055032.png]]
答案解析：[[Pasted image 20250807053931.png]]
B

![[2010-exam-paper-ocr.pdf#page=2&rect=71,351,544,402|2010-exam-paper-ocr, p.2]]
#Hexadecimal（十六进制） #存储器的容量 #芯片规格 [[存储器扩展]] #进制转化  [[进制转化]]
#地址分配 
[[Pasted image 20250807055505.png]]
D

![[2010-exam-paper-ocr.pdf#page=2&rect=77,265,517,353|2010-exam-paper-ocr, p.2]]
 [[RAM和ROM的区别]]
 
 [[Pasted image 20250807061603.png]]

A
![[2010-exam-paper-ocr.pdf#page=2&rect=76,212,500,268|2010-exam-paper-ocr, p.2]]
#计算机体系结构 #CPU访存操作 #TLB快表 #Cache高速缓存 #Page页面/主存 
[[TLB，Cache，Page的协同工作关系和逻辑依赖]]
[[Pasted image 20250807062412.png]]

D

![[2010-exam-paper-ocr.pdf#page=2&rect=74,164,469,213|2010-exam-paper-ocr, p.2]]
#内部工作寄存器 #汇编语言程序 [[CPU寄存器]] #指令周期 [[指令周期]] #计算机组成原理 

[[Pasted image 20250807063807.png]]
B

![[2010-exam-paper-ocr.pdf#page=2&rect=76,124,495,167|2010-exam-paper-ocr, p.2]]
![[截屏2025-08-15 上午11.24.49.png]]
[[指令流水线与冲突]] #流水线冲突（阻塞） #指令流水线 


A
![[2010-exam-paper-ocr.pdf#page=2&rect=75,74,473,126|2010-exam-paper-ocr, p.2]]
![[截屏2025-08-15 上午11.24.59.png]]
#英文缩写辨认 [[常见的总线标准]] [[总线的定义]] 
D
![[2010-exam-paper-ocr.pdf#page=3&rect=75,743,479,826|2010-exam-paper-ocr, p.3]]
[[中断处理机制]] #中断服务程序  
[[单级中断处理流程]]  #单级中断处理流程 
![[截屏2025-08-15 上午11.25.08.png]]
A


![[2010-exam-paper-ocr.pdf#page=3&rect=75,692,529,743|2010-exam-paper-ocr, p.3]]
[[总线带宽计算]],  [[显示系统对显存带宽的需求]] #计算题  
D
[[截屏2025-08-15 上午11.25.32.png]]
![[2010-exam-paper-ocr.pdf#page=3&rect=74,654,472,695|2010-exam-paper-ocr, p.3]]
#操作系统与应用程序的交互 #原语  [[原语]]  [[操作系统与应用程序的交互]] #操作系统与应用程序核心关系链 #库函数 

A
[[截屏2025-08-15 上午11.25.45.png]]


![[2010-exam-paper-ocr.pdf#page=3&rect=75,606,502,657|2010-exam-paper-ocr, p.3]]
#进程创建 [[进程的创建]] #进程的定义
[[设备分配的定义]] 
[[截屏2025-08-15 上午11.26.03.png]]
衍生知识 [[进程的状态与切换]]， [[进程控制块]] ，[[进程创建的具体步骤]] ，[[进程与线程的区别]] ，[[僵尸进程与孤儿进程]]  [[进程管理核心概念]]
C
![[2010-exam-paper-ocr.pdf#page=3&rect=75,557,531,609|2010-exam-paper-ocr, p.3]]
#信号量 [[信号量]]  #信号量的值 

[[截屏2025-08-15 下午12.04.35.png]]

B
![[2010-exam-paper-ocr.pdf#page=3&rect=70,509,485,561|2010-exam-paper-ocr, p.3]]
#动态优先级调度  [[动态优先级调度]]
[[CPU密集型 vs. IO密集型进程]]  [[常见调度算法与优先级关系]]
[[截屏2025-08-15 下午12.04.47.png]]
A
![[2010-exam-paper-ocr.pdf#page=3&rect=69,230,536,509|2010-exam-paper-ocr, p.3]]
*   `boolean`: 这是数组中每个元素的**数据类型**。`boolean` 意味着每个元素的值只能是 `TRUE` (真) 或 `FALSE` (假)。
*   `flag`: 这是这个数组的**名字**。
*   `[2]`: 这是最关键的部分。它表示这个数组的**大小 (Size)** 是 2
[[进程同步-临界区问题-皮特森算法]]
 [[截屏2025-08-15 下午12.05.00.png]]

D

![[2010-exam-paper-ocr.pdf#page=3&rect=72,168,536,231|2010-exam-paper-ocr, p.3]]

#存储器的容量  #动态分区存储管理 [[动态分区存储管理（动态分区分配算法）]] #最佳适配（BestFit）算法[[内存碎片]] ，[[内存回收与合并]] ，[[内存紧凑]]  [[对比动态分区和分页（分段）管理的优缺点]] [[内存考点]]

[[截屏2025-08-15 下午12.05.12.png]]
B
![[2010-exam-paper-ocr.pdf#page=3&rect=67,69,534,170|2010-exam-paper-ocr, p.3]]
#分页储存管理 #二级页表的内存管理机制 #逻辑地址结构 
[[页目录表的表型个数]]   [[二级页表]] #不熟悉 #较复杂 [[逻辑地址结构]]
衍生考点： #多级页表 [[计算页表所占内存]]， [[逻辑地址到物理地址的转换]] [[TLB(快表)的结合]]
[[截屏2025-08-15 下午12.05.22.png]]

B
![[2010-exam-paper-ocr.pdf#page=4&rect=70,751,542,823|2010-exam-paper-ocr, p.4]]

[[索引文件的储存结构]]  #计算题 
1. 计算一个索引块能存放多少个地址项$N = \frac{\text{索引块大小}}{\text{地址项大小}} = \frac{256\text{B}}{4\text{B}} = 64$ 个地址项，它表示每一级“间接”可以引出多少个下一级的指针
2. 计算直接地址项指向的数据大小 $S_{\text{direct}} = 4 \times 256\text{B} = 1024\text{B}$
3. 计算一级间接地址项指向的数据大小$S_{\text{single}} = 2 \times (\text{每个索引块的地址项数}) \times (\text{数据块大小}) = 32768\text{B}$
4. 计算二级间接地址项指向的数据大小
$S_{\text{double}} = 1 \times (\text{一级索引块地址数}) \times (\text{二级索引块地址数}) \times (\text{数据块大小})$
$=1048576\text{B}$
5. 计算文件最大总长度 ，转化为KB 
$1057\text{KB}$
[[截屏2025-08-15 下午12.05.33.png]]
C

![[2010-exam-paper-ocr.pdf#page=4&rect=72,704,465,753|2010-exam-paper-ocr, p.4]]

#当前工作目录  [[当前工作目录]]

[[截屏2025-08-15 下午12.05.41.png]]

C
![[2010-exam-paper-ocr.pdf#page=4&rect=79,661,425,702|2010-exam-paper-ocr, p.4]]
[[截屏2025-08-15 下午12.05.47.png]]
#I/O控制方式 [[IO控制方式]]

B
![[2010-exam-paper-ocr.pdf#page=4&rect=75,609,428,661|2010-exam-paper-ocr, p.4]]
[[截屏2025-08-15 下午12.05.56.png]]
内部细节 厂商做的
C
![[2010-exam-paper-ocr.pdf#page=4&rect=72,499,531,612|2010-exam-paper-ocr, p.4]]

#分组头 一千个分组 [[数据传输时间计算（分组交换网络-存储转发方式）]]
[[截屏2025-08-15 下午12.06.10.png]]

C
![[2010-exam-paper-ocr.pdf#page=4&rect=78,437,518,505|2010-exam-paper-ocr, p.4]]

#RIP协议 [[RIP协议]]
[[截屏2025-08-15 下午12.06.21.png]]

D
![[2010-exam-paper-ocr.pdf#page=4&rect=77,389,522,441|2010-exam-paper-ocr, p.4]]

[[ICMP（互联网控制报文协议）]] 

[[截屏2025-08-15 下午12.06.29.png]]

C
![[2010-exam-paper-ocr.pdf#page=4&rect=75,342,520,391|2010-exam-paper-ocr, p.4]]

#IP地址 #CIDR无类域间路由 #子网掩码 #子网划分 
[[子网划分核心概念]] [[进制转化]] 
-  确定子网位和主机位
- 计算最大子网数
- 计算每个子网最大的可分配主机数

[[截屏2025-08-15 下午12.06.52.png]]

B
![[2010-exam-paper-ocr.pdf#page=4&rect=78,291,468,344|2010-exam-paper-ocr, p.4]]

#广播风暴  #冲突域 #广播域 #OSI参考模型 [[冲突域与广播域]]

[[截屏2025-08-15 下午12.06.58.png]]

D
![[2010-exam-paper-ocr.pdf#page=4&rect=77,218,530,296|2010-exam-paper-ocr, p.4]]
#有效发送窗口 [[TCP的两个窗口机制]]

[[截屏2025-08-15 下午12.07.05.png]]

A
![[2010-exam-paper-ocr.pdf#page=4&rect=78,167,523,220|2010-exam-paper-ocr, p.4]]
#DNS域名系统  #DNS查询 [[DNS查询方式]] [[DNS解析流程（无缓存）]]
[[DNS域名系统]]

[[截屏2025-08-15 下午12.07.13.png]]

A
![[2010-exam-paper-ocr.pdf#page=4&rect=72,88,523,169|2010-exam-paper-ocr, p.4]]
#哈希表 [[哈希表]]  [[哈希函数]]  [[哈希冲突解决办法]]  [[装填因子]]  [[平均查找长度]] #散列表 
2） 
![[截屏2025-08-15 下午12.07.30.png]]


![[2010-exam-paper-ocr.pdf#page=5&rect=67,728,521,828|2010-exam-paper-ocr, p.5]]

#三步翻转法 
[[截屏2025-08-15 下午12.07.42.png]]

![[2010-exam-paper-ocr.pdf#page=5&rect=66,423,533,728|2010-exam-paper-ocr, p.5]]
[[指令格式]] [[寻址方式的定义]]  [[内存与寄存器]] #指令格式 [[指令集体系结构]] #计算机体系结构   
1. 系统参数分析 [[最多有多少条指令]] [[最多有多少个通用寄存器]] [[MAR和MDR至少需要多少位]]
2.  #转移指令的目标地址范围   [[转移指令]] #计算机字长    [[进制表示法]]
	1.    一个16位的地址可以表示的范围是从全0到全1。
    *   最小值: $0000\ 0000\ 0000\ 0000_2 = 0000H$
    *   最大值: $1111\ 1111\ 1111\ 1111_2 = FFFFH$
*   因此，转移指令的目标地址范围是 $0000H$ 到 $FFFFH$，也就是 $0$ 到 $2^{16}-1$。
（3）   [[进制表示法]] 
1. add (R4), (R5)+ 
	*   **操作码**: `add` (加法)
	*   **源操作数**: `(R4)` (逗号前为源)`R4` 的编号为 `100B`。所以 `Rs = 100B` 
	*   **目的操作数**: `(R5)+` (逗号后为目的) `R5` 的编号为 `101B`。所以 `Rd = 101B`
	* `OP | Ms | Rs | Md | Rd` 
	* `0010 | 001 | 100 | 010 | 101`
2. 编译成机器码 
	1.  **2315H**
	2. 初始状态:
	*   `(R4) = 1234H`
	*   `(R5) = 5678H`
	*   内存 `(1234H) = 5678H`
	*   内存 `(5678H) = 1234H`
3. 模拟指令执行
	1. **取源操作数的值
		1. 源操作数的值是 `5678H`
	2. 取目的操作数的值
		1. 目的操作数值为 `1234H`
	3. 执行加法
		1.   `5678H + 1234H = 68ACH` 
	4. 写回结果
		1. 内存 `(5678H)` 的内容变为 `68ACH`
	5. 执行自增
		*   目的操作数的寻址方式带有自增 `+`
	    *   将寄存器 R5 的内容加1。
	    *   `(R5)` 从 `5678H` 变为 `5678H + 1 = 5679H`。
4. 总结内容变化
	*   **寄存器 R5** 的内容从 `5678H` 变为 **`5679H`**。
	*   **内存单元 5678H** 的内容从 `1234H` 变为 **`68ACH`**。
	*   寄存器 R4 和内存单元 1234H 的内容保持不变。
[[截屏2025-08-15 下午12.07.59.png]]


![[2010-exam-paper-ocr.pdf#page=5&rect=61,134,529,428|2010-exam-paper-ocr, p.5]]

#计算机体系结构  [[逻辑地址到物理地址的转换]] [[内存地址结构]]   [[地址映射]]  [[程序运行时系统做了什么]]
1. 系统参数
	*   主存大小: 256MB = $2^8 \times 2^{20}$ B = $2^{28}$ B $\implies$ 物理地址总位数为 **28** 位。
	*   Cache行数: **8** 行 = $2^3$ 行。
	*   块大小 (Block Size): **64** B = $2^6$ B。
	*   映射方式: **直接映射**。
	*   数组 `a` 基地址: **320** (十进制)。
	*   `int` 类型大小: 32位 = **4** B。
	1.    **块内偏移 (Offset)**: 块大小为 $64 = 2^6$ B，所以需要 **6** 位。
		*   **Cache行号 (Index)**: Cache有 $8 = 2^3$ 行，所以需要 **3** 位。
		*   **标记 (Tag)**: 剩余的位数 = $28 - 6 - 3 = 19$ 位。
2.  #Cache高速缓存  #Cache总容量  计算 #Cache总容量  
	1. #数据存储容量:
	    每个Cache行存储一个数据块，大小为64B。共有8行。
	    $数据容量 = 8 \times 64B = 512B$
	2. #开销容量 
	    每一行都需要存储标记位和1个有效位。
	    *   标记位: 19位
	    *   有效位: 1位
	    *   每行总开销 = $19 + 1 = 20$ 位。
	    *   8行总开销 = $8 \times 20$ 位 = $160$ 位。
3. #计算Cache行号 计算这元素在主存中的物理地址，然后根据地址确定其所在的Cache行
	1. `a[i][j]`的 #地址计算公式 为： 
		$地址(a[i][j]) = 基地址 + (i \times 列数 + j) \times sizeof(int)$
	2. 
		*   **计算 `a[0][31]` 的地址:**
		    $地址(a[0][31]) = 320 + (0 \times 256 + 31) \times 4 = 320 + 31 \times 4 = 320 + 124 = 444$
		*   **计算 `a[1][1]` 的地址:**
		    $地址(a[1][1]) = 320 + (1 \times 256 + 1) \times 4 = 320 + 257 \times 4 = 320 + 1028 = 1348$
	3. $Cache行号 = \lfloor \frac{物理地址}{块大小} \rfloor \pmod{Cache总行数}$ 
		1.   **`a[0][31]` (地址 444) 的Cache行号:**
			*   主存块号 = $\lfloor \frac{444}{64} \rfloor = \lfloor 6.9375 \rfloor = 6$
			*   Cache行号 = $6 \pmod 8 = 6$
		2.  `a[1][1]` (地址 1348) 的 #Cache行号:
		    *   #主存块号 = $\lfloor \frac{1348}{64} \rfloor = \lfloor 21.0625 \rfloor = 21$
		    *   Cache行号 = $21 \pmod 8 = 5$
4. 计算程序 A 和 B 的命中率，并比较执行时间
	1. #空间局部性 #Cache命中率计算 
	2. 分析程序 A ( #行优先访问)
		1. 访问 `a[0][0]` 时，发生 #强制性缺失 系统将包含 `a[0][0]` 到 `a[0][15]` 的整个64B数据块调入Cache  
		2. $命中率_A = \frac{命中次数}{总访问次数} = \frac{15}{16} = 93.75\%$
	3. 分析程序 B ( #列优先访问)
		1. `a[0][0], a[1][0], a[2][0], ...`。这些元素在内存中是**不连续** 
		2. $地址间隔 = (i \times 256 \times 4 + 256 \times 4 + j \times 4) - (i \times 256 \times 4 + j \times 4) = 256 \times 4 = 1024$ 
		3.   $主存块号间隔 = \frac{地址间隔}{块大小} = \frac{1024}{64} = 16$ 个块。 
		    现在看Cache行号的变化：
		    *   `a[i][j]` 所在的Cache行 = $(\text{块号}_i) \pmod 8$
		    *   `a[i+1][j]` 所在的Cache行 = $(\text{块号}_i + 16) \pmod 8$
		    因为 $16 \pmod 8 = 0$，所以 $(\text{块号}_i + 16) \pmod 8 = (\text{块号}_i) \pmod 8$。
		    这意味着，`a[0][0]`, `a[1][0]`, `a[2][0]`, ... **所有这些元素都映射到同一个Cache行！**
	4. 0%
	
所以，`a[0][31]` 映射到 **Cache行6**，`a[1][1]` 映射到 **Cache行5**
[[截屏2025-08-15 下午12.08.25.png]]
[[截屏2025-08-15 下午12.08.39.png]]
![[2010-exam-paper-ocr.pdf#page=6&rect=72,550,547,820|2010-exam-paper-ocr, p.6]]



[[磁盘调度算法补充]] [[磁盘空闲空间管理]] 
1. #位图法 [[位图法]] 
2. #磁盘访问时间构成 $T_a = T_{seek} + T_{rotation} + T_{transfer}$
	1. 根据 #CSCAN算法 #确定服务顺序 #单向电梯算法 
		*   **确定顺序：**
		    1.  从 100 号磁道开始，向磁道号增大的方向移动。遇到的第一个请求是 **120**。
		    2.  处理完 120 后，磁道号增大的方向上没有其他请求了。根据 CSCAN 规则，磁头需要“跳”回起始磁道（通常是 0 号磁道），然后继续向磁道号增大的方向扫描。
		    3.  从起始位置开始扫描，依次会遇到 **30**、**50**、**90**。
			    因此，最终的服务顺序是：**120, 30, 50, 90**。
			4. 从 120 “跳”回，然后移动到 30 (这里计算的是从上一个服务的磁道到下一个服务的磁道的距离，即从120到30)：$|30 - 120| = 90$ 个磁道 (注：这里的计算方式是解题的标准范式，即计算服务序列中相邻请求间的距离总和)
			5. **总移动磁道数** = $20 + 90 + 20 + 40 = 170$ 个磁道。
	2. #总寻道时间 = $170 \text{ 磁道} \times 1 \text{ ms/磁道} = 170 \text{ ms}$
	3. #总旋转延迟 ($T_{rotation}$ )
		1. *   **转速：** 6000 rpm (revolutions per minute，转/分钟)。
			*   **每秒转数：** $6000 / 60 = 100$ rps (revolutions per second，转/秒)。
			*   **转一圈的时间：** $1 / 100 \text{ s} = 0.01 \text{ s} = 10 \text{ ms}$。
			*   **平均旋转延迟：** 通常取转半圈的时间，因为平均情况下，目标扇区在半圈内的任意位置。
			    $$ \text{平均旋转延迟} = \frac{10 \text{ ms}}{2} = 5 \text{ ms} $$
			*   总共有 4 个读请求，每个请求都需要一次旋转定位。
			    **总旋转延迟** = $4 \times 5 \text{ ms} = 20 \text{ ms}$。
	4. #总传输时间  
		1. *   **传输时间** 是读取一个扇区数据所花费的时间。
			*   每个磁道有 100 个扇区，转一圈需要 10 ms。
			*   **读取一个扇区的时间** = $\frac{\text{转一圈的时间}}{\text{每磁道扇区数}} = \frac{10 \text{ ms}}{100} = 0.1 \text{ ms}$。
			*   总共有 4 个读请求，每个请求读取一个扇区。
			    **总传输时间** = $4 \times 0.1 \text{ ms} = 0.4 \text{ ms}$。
	5.  $\text{总时间} = 170 \text{ ms} + 20 \text{ ms} + 0.4 \text{ ms} = 190.4 \text{ ms}$ 
3. [[磁盘调度算法补充]]   #SSD为何比HDD快？ 
	1. 对于 SSD，由于没有寻道时间和旋转延迟需要优化，复杂的磁盘调度算法（如 SCAN, CSCAN, SSTF 等）就失去了其设计的意义，反而会因为算法本身的计算开销而带来不必要的延迟。最简单、最公平且最高效的策略就是按照请求到达的顺序进行服务，即 #先来先服务（FCFS）
[[Pasted image 20250815120922.png]]

![[2010-exam-paper-ocr.pdf#page=6&rect=66,218,564,552|2010-exam-paper-ocr, p.6]]
1. 初始条件
	1.  **系统配置**：
	    *   逻辑地址空间 = 物理地址空间 = $64 \text{KB}$。
	    *   页面大小 = $1 \text{KB}$。
	    *   系统为该进程分配了 4 个页框 (Page Frame)。
	2.  **事件**：
	    *   在时刻 260，进程需要访问逻辑地址为 `17CAH` 的数据。
	3.  **状态**：
	    *   在时刻 260 前，内存中已经装入了 4 个页面，状态如下表所示：
2. [[逻辑地址结构]] 
	1. 计算地址总位数
		1. 地址空间$64 \text{KB} = 64 \times 1024 \text{ B} = 2^6 \times 2^{10} \text{ B} = 2^{16} \text{ B}$   ， 16 位
	2.  计算页内偏移量位数
		1. 页面大小为 $1 \text{KB}$   $1 \text{KB} = 1024 \text{ B} = 2^{10} \text{ B}$  10 位
	3. 计算页号位数
		1. 页号位数 = 地址总位数 - 页内偏移量位数 = $16 - 10 = 6$ 位
	4. 解析逻辑地址 `17CAH`  #进制转化  
		1. `17CAH` = `0001 0111 1100 1010` B 
	5. 提取页号和偏移量
		1. **页号**：取前 6 位，即 `000101`B  转换为十进制：$0 \cdot 2^5 + 0 \cdot 2^4 + 0 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 4 + 1 = 5$
		2. **页内偏移量**：取后 10 位，即 `11 1100 1010`B
3.   #判断是否缺页   无 页 5 #缺页中断 
	1. FIFO (First-In, First-Out) 算法选择**最早进入内存的页面**作为牺牲页（victim page），页 0 的装入时刻 130 最早。因此，页 0 被置换出去
	2. 页面置换
		1. 页 0 原本存放在 **7 号页框**中。现在，将新的页 5 装入到 7 号页框中 
	3. #计算物理地址 
		1. 物理地址的结构与逻辑地址类似：**页框号** + **页内偏移量**
			*   **页框号 (Frame Number)**：页 5 被装入了 7 号页框。7 的 6 位二进制表示为 `000111`B。
		    *   **页内偏移量 (Offset)**：与逻辑地址的偏移量相同，为 `11 1100 1010`B。
		    * 拼接得到 16 位的物理地址：`000111 1111001010`B
		2. 转换为十六进制  `1FCAH`
4. [[页面置换算法]]
	1. #CLOCK算法 
		*   当一个页面被访问时，其访问位被置为 1。
		*   当需要置换页面时，从一个循环队列的指针（时钟指针）当前位置开始检查：
	    *   如果当前页框的访问位为 1，则将其置为 0，指针移到下一个页框。这相当于给了该页面“第二次机会”。
	    *   如果当前页框的访问位为 0，则该页框被选中作为牺牲者，新页面装入，指针移到下一个位置。
		1. 初始状态 
			*   发生缺页，需要置换一个页面。
		    *   时钟指针指向 **2 号页框**。
		    *   所有在内存中的页面 (0, 1, 2, 3) 的访问位都为 1。
		    *   页框的检查顺序（根据题中图示顺时针）：2 -> 4 -> 7 -> 9。
		2. 执行 CLOCK 算法 #时钟算法Clock   
			*   **第 1 步**: 检查指针指向的 **2 号页框**。其访问位为 1。将其置为 0，指针移动到下一个页框（4 号）。
		    *   **第 2 步**: 检查 **4 号页框**。其访问位为 1。将其置为 0，指针移动到下一个页框（7 号）。
		    *   **第 3 步**: 检查 **7 号页框**。其访问位为 1。将其置为 0，指针移动到下一个页框（9 号）。
		    *   **第 4 步**: 检查 **9 号页框**。其访问位为 1。将其置为 0，指针移动到下一个页框（回到 2 号）。
		    *   **第 5 步**: 再次检查 **2 号页框**。此时它的访问位已经是 0。因此，2 号页框被选中，它所对应的页 2 被置换。
		3. #页面置换 
			1. 页 5 装入到 **2 号页框**中。同时，将这个新页面的访问位置为 1
		4. #计算物理地址
			*   **页框号 (Frame Number)**：页 5 被装入了 2 号页框。2 的 6 位二进制表示为 `000010`B。
		    *   **页内偏移量 (Offset)**：仍然是 `11 1100 1010`B。
		5. #进制转化 
			1. `0BCAH`
[[截屏2025-08-15 下午12.09.37.png]]

![[2010-exam-paper-ocr.pdf#page=6&rect=63,85,535,220|2010-exam-paper-ocr, p.6]]
1. 物理题  #CSMA/CD协议中，碰撞是如何发生和被检测到  [[CSMA-CD协议的工作原理]]  [[数据链路层的信道利用率（有效数据传输速率）]]
	1. 最短 同时发送 `1 km / 200,000 km/s = 0.005 ms` `0.005 ms + 0.005 ms = 0.01 ms`
	2. 最长 甲快到乙才发 `T(b) = 2km / 200000km/s × 2 = 0.02ms`
2. #最长以太网数据帧 
	1. 计算完整周期的时间 
		1.  **甲发送数据帧的时间 (t₁)**: 这叫 #发送时延 ，取决于帧大小和带宽
			*   `t₁ = 帧大小 / 数据传输速率 = (1518 Bytes × 8 bits/Byte) / (10 Mbps) = 12144 bits / (10 × 10^6 bps) = 0.0012144 s = 1.2144 ms`
		2. **数据帧在路上的传播时间**  `tₚ = 0.01 ms` 
		3. **乙发送确认帧的时间 (t₂)**
			*   `t₂ = 确认帧大小 / 数据传输速率 = (64 Bytes × 8 bits/Byte) / (10 Mbps) = 512 bits / (10 × 10^6 bps) = 0.0000512 s = 0.0512 ms`
		4.   **确认帧在路上的传播时间**: 也是 `tₚ = 0.01 ms`
	`T = t₁ + t₂ + 2tₚ = 1.2144ms + 0.0512ms + 2 × 0.01ms = 1.2856 ms`
	2. #计算有效数据量 
		*   一个以太网帧 1518B 包括：6B目的MAC + 6B源MAC + 2B类型 + 1500B数据 + 4B校验(FCS)。题目没有特别说明，我们按标准来，**有效数据**就是指数据净荷 (Payload) 部分。 
		*   **有效数据量**: 1500 Bytes = `1500 × 8 bits = 12000 bits`
	3. #计算有效数据传输速率 
		*   **有效速率 = 有效数据量 / 总周期时间**
		*   `有效速率 = 12000 bits / 1.2856 ms = 12000 bits / 0.0012856 s ≈ 9,334,162 bps ≈ 9.33 Mbps`
[[截屏2025-08-15 下午12.09.48.png]]


