![[2015-exam-paper-ocr.pdf#page=1&rect=80,598,541,704|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.38.47.png]]
	A [[栈]]  #函数调用栈 
	在递归调用最深的时候（第3步），调用栈从底到顶的顺序是 `main()`，然后是 `S(1)`，最后是 `S(0)`。
 - 衍生
	 -  #栈溢出   [[栈溢出]] 
		 - 问：如果调用 `S(1000000)` 会发生什么？ 答：很可能发生栈溢出。
		    *   问：如何修改一个无限递归的函数（ #缺少基准情况 ）来避免错误？ 答：添加一个能最终被满足的基准情况。
	* 递归的时间与空间复杂度分析 [[递归的时间与空间复杂度分析]] 
	* #尾递归优化 
		* 如果一个函数中的递归调用是整个函数最后执行的操作，那么这个递归就称为**尾递归**。
		*   **题目中的函数是尾递归吗？**
		    *   不是。在 `return S(n-1) + n;` 中，递归调用 `S(n-1)` 之后，还必须执行 `+ n` 这个操作。所以它不是尾递归。
		[[尾递归]] **题目中的函数是尾递归吗？**
	    *   不是。在 `return S(n-1) + n;` 中，递归调用 `S(n-1)` 之后，还必须执行 `+ n` 这个操作。所以它不是尾递归。 
![[2015-exam-paper-ocr.pdf#page=1&rect=78,561,453,599|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.38.55.png]]
[[二叉树的性质]]
#先序序列 
1. [[遍历与栈操作的等价性]]
	1. 因此，原问题 “先序序列为 `a, b, c, d` 的不同二叉树有多少个？” 就等价于 “一个栈的入栈顺序为 `a, b, c, d`，那么所有可能的、合法的出栈序列有多少个？”
2. #卡特兰数  
	- #组合计数
		- 询问 $n$ 个 #不同结点可以构成多少种不同的二叉树形态 。答案是 #卡特兰数   
			- $C_n = \frac{1}{n+1}\binom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$  [[组合]] 
	 **计算过程**：
	    在本题中，序列 `a, b, c, d` 含有 4 个元素，所以 $n=4$。我们将 $n=4$ 代入卡特兰数公式：
	    $C_4 = \frac{1}{4+1}C_{2 \times 4}^{4} = \frac{1}{5}C_{8}^{4}$
	    我们先计算组合数 $C_{8}^{4}$：
	    $C_{8}^{4} = \frac{8!}{4!(8-4)!} = \frac{8!}{4!4!} = \frac{8 \times 7 \times 6 \times 5}{4 \times 3 \times 2 \times 1} = \frac{1680}{24} = 70$
	    然后代入原式：
	    $C_4 = \frac{1}{5} \times 70 = 14$	
	    所以，共有 14 种不同的出栈序列，也就对应着 14 棵不同的二叉树
- [[卡特兰数常见的应用场景]]  
- #根据遍历序列重建二叉树 
	- 这是非常高频的面试题。通常会给出先序和中序序列，或者后序和中序序列，要求你构建出这棵二叉树。
	    *   **先序+中序**：先序序列的第一个元素是根，在中序序列中找到这个根，其左边是左子树，右边是右子树。然后递归构建。
	    *   **后序+中序**：后序序列的最后一个元素是根，同样在中序序列中找到根来划分左右子树，然后递归构建。
- 判断出栈序列的合法性 
	-     给定一个入栈序列和一个出栈序列，判断该出栈序列是否合法。这可以通过模拟栈的操作来解决。



![[2015-exam-paper-ocr.pdf#page=1&rect=76,501,496,562|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.39.01.png]]

- [[哈夫曼树]]  [[m叉哈夫曼树的构造规则]]  
1.   哈夫曼树中，任何一个非叶子结点（即父结点）的权值都等于其左、右两个孩子结点的权值之和。
	用公式表示为：
	$W_{parent} = W_{left\_child} + W_{right\_child}$
- C. 24, 10, 10 和 24, 14, 11
	*   **路径分析**：我们首先看路径 `24 -> 10 -> 10`。这表示一个权值为 `10` 的父结点，其下有一个权值为 `10` 的叶子结点。根据 #哈夫曼树的性质 ，$W_{parent} = W_{child1} + W_{child2}$，即 $10 = 10 + W_{child2}$。这要求另一个孩子的权值 $W_{child2}$ 必须为 `0`。在标准的哈夫曼树构造中，所有原始权值都是正数，因此这种情况是不可能的。
	*   **性质检验（另一种角度）**：我们也可以像分析 B 一样，检查根结点。根结点 `24` 的两个孩子权值分别为 `10` 和 `14`。它们的和为 $10 + 14 = 24$。根结点这一层是满足条件的。但是，如上所述，`10 -> 10` 这个子路径不满足条件。
	*   **结论**：由于存在不满足性质的子路径，选项 C 错误。
 - D. 24, 10, 5 和 24, 14, 6
	**路径分析**：这两条路径 `24 -> 10 -> 5` 和 `24 -> 14 -> 6` 描述了如下的局部树结构：
	    1.  根结点 `24` 有两个孩子，权值分别为 `10` 和 `14`。
	    2.  权值为 `10` 的结点有一个孩子是权值为 `5` 的叶子结点。
	    3.  权值为 `14` 的结点有一个孩子是权值为 `6` 的叶子结点。
	*   **性质检验**：
	    1.  **检验根结点**：其两个孩子的权值和为 $10 + 14 = 24$。这与根结点的权值 `24` 相符。
	    2.  **检验结点 10**：它有一个孩子是 `5`。根据性质，它必须还有另一个孩子。设另一个孩子的权值为 $x$，则 $10 = 5 + x$，解得 $x=5$。这是完全可能的，即结点 `10` 的两个孩子权值都是 `5`。
	    3.  **检验结点 14**：它有一个孩子是 `6`。设另一个孩子的权值为 $y$，则 $14 = 6 + y$，解得 $y=8$。这也是完全可能的。
	*   **结论**：所有路径描述的局部结构都能满足哈夫曼树的性质，我们可以构建出一个合法的哈夫曼树局部结构。因此，选项 D 正确。
- 衍生
	- #构造哈夫曼树 
		-  **问题**：给定一组权值（例如，字符的出现频率），要求画出完整的哈夫曼树。
		    *   **解法**：遵循“贪心”策略：每次从森林中选取权值最小的两棵树，合并成一棵新树（新树的根结点权值为两棵子树根结点权值之和），然后将新树放回森林。重复此过程，直到只剩下一棵树为止。
	- #带权路径长度  
		-   **问题**：计算给定哈夫曼树的 WPL (Weighted Path Length)。WPL 是衡量编码效率的指标，其值越小越好
		-    **公式**：$WPL = \sum_{i=1}^{n} w_i l_i$，其中 $w_i$ 是第 $i$ 个叶子结点的权值， $l_i$ 是该叶子结点的深度（根结点深度为0）。
	    *   **一个有用的结论**：哈夫曼树的 WPL 等于所有非叶子结点的权值之和。这个结论可以用来快速验算。
	* [[哈夫曼编码]] 
		*   **问题**：为一组字符（及其频率）设计哈夫曼编码。 


![[2015-exam-paper-ocr.pdf#page=1&rect=82,435,519,501|2015-exam-paper-ocr, p.1]]
[[Pasted image 20250930033912.png]]
- [[AVL树的高度与结点数关系]]  [[平衡二叉树]] 
- [[前驱后继，前中后序]] #中序遍历 
-  “对其进行中序遍历可得到一个**降序序列**”。
    *   对于一棵**标准**的二叉搜索树，其中任意结点的值都大于其左子树中所有结点的值，且小于其右子树中所有结点的值。对它进行中序遍历 (LNR)，会得到一个**升序序列**。
    *   而本题得到的是一个**降序序列**。这意味着这棵树的结构是“反过来”的。对于树中的任意一个结点，其值必须**小于**其左子树中所有结点的值，且**大于**其右子树中所有结点的值。我们可以称之为“ #降序二叉搜索树”。
    *   **结论：对于树中任意结点 `N`，其关键字满足 `key(LeftSubtree) > key(N) > key(RightSubtree)`。**
1. A. 根结点的度一定为2
	1. #结点的度 是指该结点的子树个数。度为2意味着结点既有左子树又有右子树。这个说法是错误的。
	*   **反例**: 我们可以构造一个只有两个结点的AVL树，例如包含关键字 {10, 5}。根据我们推导的“降序”规则，如果根是10，那么5比10小，应该在10的右子树。
    ```
      10
       \
        5
    ```
    这棵树是平衡的（根结点的平衡因子为 $0 - 1 = -1$），满足所有条件。但根结点10的度为1，而不是2。因此，A错误。
- B. 树中 #最小元素 一定是 #叶结点
	1. 要找到最小的元素，我们必须从根结点开始，一直向右走到底。这个最右侧的结点就是值最小的元素
		1. 最右侧的结点一定是叶结点吗？不一定。
			1. 一个结点是叶结点意味着它没有子结点（度为0）。但这个最小元素结点虽然没有右子树（因为已经是最右了），但它**可能有一个左子树**。
	2. #反例 
		构造一棵包含 {10, 5, 7} 的AVL树。
		    1.  插入10。
		    2.  插入5 (比10小，放右边)。
		    3.  插入7 (比10小，往右走；比5大，放5的左边)。
		    树的结构如下：
		    ```
		      10
		       \
		        5
		       /
		      7
		    ```
		    这棵树是平衡的（结点5的BF=1，结点10的BF=-1）。其中最小的元素是5，但它不是叶结点，因为它有一个左孩子7。因此，B错误。
- C. 最后插入的元素一定是叶结点  
	- 关于AVL树插入操作的一个常见误解。虽然新元素总是作为叶结点被**初步插入**到树中，但为了维持AVL树的平衡特性，插入后可能会触发一次或多次 #旋转 操作
- D. 树中最大元素一定是无左子树
	-  在我们这棵“降序二叉搜索树”中，最大的元素在哪里？根据规则 `key(LeftSubtree) > key(N)`，要找到最大的元素，我们必须从根结点开始，一直向左走到底。这个最左侧的结点就是值最大的元素。
	- 根据“降序二叉搜索树”的定义，任何结点的左孩子的值都必须比该结点自身的值要大。假设最大元素（最左侧的结点）`M` 有一个左子树，那么其左子树的根结点`L`的值必须满足 `key(L) > key(M)`。但这与`M`是树中最大元素的前提相矛盾。
	*   所以，树中的最大元素（最左侧的结点）**一定不能有左子树**。它可能有右子树，也可能没有，但它一定没有左子树。因此，D正确。
- 衍生
	- [[平衡旋转]] 
		- 给定一棵二叉树，判断它是否为AVL树，并计算特定结点的 #平衡因子
		- #四种旋转操作 深入考察LL、RR、LR、RL四种失衡情况以及对应的旋转调整方法 
		- #AVL树的性能 插入、删除、查找操作的时间复杂度为什么是$O(\log n)$ 
		- #AVL树的高度 AVL树的高度与结点数之间的关系，最坏情况下（最“瘦高”的AVL树）的高度约为$1.44 \log_2 n$ 
		- [[平衡二叉树对比]]  与红黑树（Red-Black Tree）的比较 


![[2015-exam-paper-ocr.pdf#page=1&rect=76,392,525,439|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.39.20.png]]
![[截屏2025-09-30 下午1.09.43.png]]
- #有向图  #深度优先遍历（先序遍历） #深度优先搜索DFS   [[有向图]]   [[深度优先遍历实现步骤（有向图）]]  
- 序列: **`<v_0, v_1, v_3, v_2>`**。所有顶点均已访问，遍历结束。
	 序列: **`<v_0, v_2, v_1, v_3>`**
		序列: **`<v_0, v_2, v_3, v_1>`**
		序列: **`<v_0, v_3, v_1, v_2>`**
		序列: **`<v_0, v_3, v_2, v_1>`**
**5** 种可能的序列 
- #广度优先搜索BFS  
	-  **考点**: 可能会问同一个图从 $v_0$ 开始进行BFS，有多少种可能的序列。
		-   **解析**: BFS是 #按层级遍历 。从 $v_0$ 开始，第一层是 $v_0$。第二层是 $v_0$ 的所有邻接点 $v_1, v_2, v_3$。BFS会先访问完所有第二层的节点，再进入下一层。访问第二层节点的顺序是不确定的。因此，可能的序列是 $v_0$ 后面跟着 $v_1, v_2, v_3$ 的任意排列。排列数是 $3! = 3 \times 2 \times 1 = 6$ 种。所以此图的BFS序列有6种。
	- [[邻接矩阵，邻接表 ，稀疏图，稠密图]] 
		- #邻接表与邻接矩阵的区别与选择 
			- **邻接矩阵**: 用一个二维数组 `adj[i][j] = 1` 表示存在从 $i$ 到 $j$ 的边。空间复杂度为 $O(|V|^2)$。对于本题，遍历 $v_0$ 的邻接点时，相当于按 $j$ 从 0 到 3 的顺序扫描矩阵的第0行，这会产生一个固定的遍历顺序。
		    *   **邻接表**: 为每个顶点维护一个链表或动态数组，存储其所有邻接点。空间复杂度为 $O(|V|+|E|)$。邻接表中节点的存储顺序是不确定的，这直接导致了DFS/BFS遍历序列的多样性。本题默认是基于邻接表的逻辑。
		-  [[拓扑排序]]
			- 判断一个有向图是否存在环（Cycle），并给出其拓扑序列






![[2015-exam-paper-ocr.pdf#page=1&rect=74,263,538,395|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.39.31.png]]
[[截屏2025-09-30 上午3.39.38.png]]
[[最小生成树]]
- #Kruskal算法  核心思想是**按边的权重从小到大**依次考察，如果当前考察的边不会与已选择的边构成回路（环），就将其加入到最小生成树中，直到加入了 $n-1$ 条边为止（其中 $n$ 是顶点数） 
1.  **将所有边按权重升序排列：**
    *   $(V_1, V_4)$: 权重 5
    *   $(V_1, V_3)$: 权重 8
    *   $(V_2, V_3)$: 权重 8
    *   $(V_3, V_4)$: 权重 8
    *   $(V_1, V_2)$: 权重 10
    *   $(V_2, V_4)$: 权重 11
	1. 第1次选择 选择权重最小的边 $(V_1, V_4)$，权重为5。这条边不会形成环
	2. Kruskal算法第2次可能选中的边是 $(V_1, V_3)$, $(V_2, V_3)$, 或 $(V_3, V_4)$。
 2. 第二步：执行 Prim 算法
	1.  选择权重最小的边 $(V_4, V_1)$。
	    *   更新集合 $U = \{V_1, V_4\}$。
	2. 第2次选择
	    寻找连接 $U=\{V_1, V_4\}$ 中顶点与 $V-U=\{V_2, V_3\}$ 中顶点的权重最小的边。
	    *   **从 $V_1$ 出发的边：** $(V_1, V_3)$ 权重8，$(V_1, V_2)$ 权重10。
	    *   **从 $V_4$ 出发的边：** $(V_4, V_3)$ 权重8，$(V_4, V_2)$ 权重11。
	    *   所有候选边为：$(V_1, V_3)$, $(V_1, V_2)$, $(V_4, V_3)$, $(V_4, V_2)$。
	    *   其中权重最小的是 $(V_1, V_3)$ 和 $(V_4, V_3)$，权重均为8。
		1.   因此，Prim算法第2次选择的边**必定是 $(V_1, V_3)$ 或 $(V_3, V_4)$ 
	答案：C. $(V_2, V_3)$**
- 衍生 
	- #最小生成树MST的唯一性    **考点：** 判断一个图的最小生成树是否唯一。
		- **结论：** 如果一个连通图的所有边的权重都**互不相同**，那么它的最小生成树是**唯一**的。如果存在相同权重的边（如此题），最小生成树可能**不唯一**。 
	- #Prim和Kruskal的算法复杂度（稀疏图vs稠密图）   [[最小生成树]]
		*   **Kruskal:** 时间复杂度主要取决于对边的排序，为 $O(E \log E)$，其中 $E$ 是边数。它更适合**稀疏图**（边数 $E$ 远小于 $V^2$）。Q
	    *   **Prim:**
	        *   使用邻接矩阵实现：$O(V^2)$。
	        *   使用优先队列（最小堆）优化：$O(E \log V)$。
	        *   Prim算法的 $O(V^2)$ 版本适合**稠密图**（边数 $E$ 接近 $V^2$）。
		- [[次小生成树]] **考点：** 求解一个图的权重第二小的生成树。这是一个更深入的考点。 


![[2015-exam-paper-ocr.pdf#page=1&rect=70,228,512,268|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.39.50.png]]
[[二分查找]]  #二分查找  #画图 
  1. **选项 A: 500, 200, 450, 180**
    1.  `500` -> `200`：因为 $200 < 500$，我们进入了500的左子树。**规则：之后所有比较值都必须 < 500**。
    2.  `200` -> `450`：因为 $450 > 200$，我们进入了200的右子树。**规则：之后所有比较值都必须 > 200**。
    3.  `450` -> `180`：下一个比较值是 `180`。
    4.  **矛盾出现**：根据第2步，后续比较值必须大于 `200`。但 `180` 却小于 `200`。这违反了折半查找的原则。在确定了查找区间为 `(200, 500)` 之后，不可能再回头去比较一个小于 `200` 的值。因此，这个序列不合法。
    *   **图解分析**：
        *   `500` (根)
        *   `200` (500的左孩子)
        *   `450` (200的右孩子)
        *   `180` (试图成为450的孩子)。但是，`180` 比它的“爷”节点 `200` 还要小，它本应该在 `200` 的左子树，而不是右子树的后代。这破坏了BST的结构。

- 衍生 
	- 根据有序序列构建折半查找判定树
		-    **考点：** 给定一个有序数组，如 `[2, 8, 15, 22, 31, 40, 45]`，要求画出其 #折半查找判定树 。
		    *   **解法：** 递归地取中间元素作为根节点。
		        *   根：`22` (索引 `(0+6)/2=3`)
		        *   左子树（`[2, 8, 15]`）的根：`8`
		        *   右子树（`[31, 40, 45]`）的根：`40`
		        *   依此类推，直到所有元素都成为节点。
		- [[平均查找长度 (ASL)]]
		[[查找算法的比较]]  #哈希查找 [[顺序表查找方法]]



![[2015-exam-paper-ocr.pdf#page=1&rect=74,179,520,231|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.40.04.png]]
#KMP算法  [[KMP算法]] 
KMP 算法的匹配过程遵循以下规则：
*   如果 `s[i] == t[j]`，则 `i` 和 `j` 都加 1，继续比较下一对字符。
*   如果 `s[i] != t[j]`（发生失配），则：
    *   主串的指针 `i` **保持不变**。
    *   模式串的指针 `j` 更新为 `j = next[j]`。
    * 因此，下一次开始匹配时，`i` 和 `j` 的值分别是 5 和 2。这对应于选项 **C**。
- 衍生 
	- #如何手动计算next数组
		*   `j=0`: 按定义，`next[0] = -1`。
		*   `j=1`: 子串为 "a"。没有真前缀和后缀，最长公共前后缀长度为 0。`next[1] = 0`。
		*   `j=2`: 子串为 "ab"。前缀为 {"a"}，后缀为 {"b"}。没有公共部分。`next[2] = 0`。
		*   `j=3`: 子串为 "aba"。前缀为 {"a", "ab"}，后缀为 {"a", "ba"}。最长公共部分是 "a"，长度为 1。`next[3] = 1`。
		*   `j=4`: 子串为 "abaa"。前缀为 {"a", "ab", "aba"}，后缀为 {"a", "aa", "baa"}。最长公共部分是 "a"，长度为 1。`next[4] = 1`。
		*   `j=5`: 子串为 "abaab"。前缀为 {"a", "ab", "aba", "abaa"}，后缀为 {"b", "ab", "aab", "baab"}。最长公共部分是 "ab"，长度为 2。`next[5] = 2`。


![[2015-exam-paper-ocr.pdf#page=1&rect=79,147,471,185|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.40.16.png]]
[[排序算法]]
1.  A. 直接插入排序 
	1. 算法将数组分为“已排序”和“未排序”两部分。每次从未排序部分取出一个元素，通过比较，将其插入到已排序部分的正确位置
	2. 元素的移动次数与初始次序**高度相关**。
	    *   **最好情况：** 如果数组基本有序或完全有序，那么每次插入的元素只需要很少的比较和移动（甚至不移动）就能找到自己的位置。此时移动次数最少。
2. B. 起泡排序
	1.  重复地遍历要排序的数列，一次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来
3. C. 基数排序 
	1. 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。它需要借助一个“桶”的结构。
	2.  **与初始次序的关系：** 元素的移动次数与初始次序**无关**
4. D. 快速排序
	1. **工作原理：** 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。
	2. **与初始次序的关系：** 元素的移动（交换）次数与初始次序**相关**


- 衍生 
	- #时间复杂度  #空间复杂度  #稳定性 #比较次数 



![[2015-exam-paper-ocr.pdf#page=1&rect=81,98,521,146|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.40.27.png]]

```
      8
     / \
    15  10
   / \  / \
  21 34 16 12
```

删除堆顶元素（即最小值8）的标准流程如下：
[[大根堆]] #最小堆  
步骤二：执行删除根节点（最小值）的操作
1.  **替换**：将堆中最后一个元素（这里是`12`）移动到根节点的位置，替换被删除的元素`8`。
2.  **调整**：此时堆的结构变为如下，但堆序性可能被破坏。我们需要从根节点开始进行“向下调整”（Sift-down 或 Heapify-down）操作，以恢复小根堆的性质。

3. 删除`8`并用`12`替换后，堆的结构如下（对应题目解析中第二幅图）：

```
      12  <-- 堆序性可能被破坏
     / \
    15  10
   / \  /
  21 34 16
```
**交换**：将 `12` 和 `10` 交换位置。
 步骤三： 向下调整（Sift-down）并计数比较次数

**第1轮调整（从根节点开始）：**

*   当前节点为 `12`，其子节点为 `15` 和 `10`。
*   **第1次比较**：为了找到子节点中的最小值，需要比较 `15` 和 `10`。显然，$10 < 15$。
*   **第2次比较**：将当前节点 `12` 与其较小的子节点 `10` 进行比较。因为 $12 > 10$，不满足小根堆性质。
*   **交换**：将 `12` 和 `10` 交换位置。
交换后，堆的结构变为（对应题目解析中第三幅图）：

```
      10
     / \
    15  12  <-- 12移动到了新位置
   / \  /
  21 34 16
```

**第2轮调整（从 `12` 的新位置开始）：**

*   `12` 移动到了新的位置，我们需要继续检查它是否满足堆序性。
*   当前节点为 `12`，它的子节点是 `16`（它只有一个左子节点，因为原先`10`的右子节点是`12`，现在`12`是父节点了）。
*   **第3次比较**：将当前节点 `12` 与其子节点 `16` 进行比较。因为 $12 < 16$，满足小根堆性质。
*   **停止**：调整过程结束。

#### 步骤四：统计总比较次数

在整个重建堆的过程中，我们总共进行了3次比较：
1.  `15` 与 `10` 比较
2.  `12` 与 `10` 比较
3.  `12` 与 `16` 比较

因此，总的比较次数是 **3** 次。答案选 **C**。

- 衍生 
	- #堆堆插入操作 
		-    **过程**：将新元素添加到堆的末尾（即完全二叉树的下一个可用位置），然后执行“向上调整”（Sift-up）操作。将新节点与其父节点比较，如果它比父节点小，则交换，并继续向上比较，直到根节点或满足堆序性为止。
	    *   **考点**：可能会问插入一个元素后的堆形态，或者插入过程中的比较/交换次数。
	- #堆堆构建（初始化）     
		*   **过程**：给定一个无序数组，如何构建一个堆？最高效的方法（时间复杂度为$O(n)$）是从最后一个非叶子节点开始，向前逐个节点执行“向下调整”（Sift-down）操作，直到根节点。
	    *   **考点**：给定一个数组，要求构建成大根堆或小根堆，并写出最终的数组序列。
	-  #堆排序     
		*   **过程**：这是一个经典排序算法。首先将无序序列构建成一个大根堆（Max-Heap）。然后，重复执行以下步骤：将堆顶元素（当前最大值）与堆末尾元素交换，然后将堆的大小减一，并对新的根节点执行“向下调整”操作。
	    *   **考点**：堆排序的时间复杂度（始终为$O(n\log n)$）、空间复杂度（$O(1)$）、以及其稳定性（不稳定排序）。
	- #大根堆     与小根堆性质相反，大根堆中任意节点的值都**大于或等于**其子节点的值。根节点是最大值。所有操作（插入、删除）的逻辑与小根堆类似，只是比较的逻辑相反。
	- #堆堆应用-TOP-K问题  
		- 从海量数据中找出最大（或最小）的 K 个元素
	    *   **解法**：
	        *   找最大的K个元素：维护一个大小为K的小根堆。遍历数据，如果当前元素比堆顶元素大，则删除堆顶，插入当前元素。
	        *   找最小的K个元素：维护一个大小为K的大根堆。
	
![[2015-exam-paper-ocr.pdf#page=1&rect=81,60,475,98|2015-exam-paper-ocr, p.1]]
[[截屏2025-09-30 上午3.40.36.png]]

[[希尔排序]] 
A. 直接插入排序
希尔排序通过分组和逐步缩小增量的方式，让元素可以一次性地跳跃很长的距离，从而快速地使整个数组趋于有序，最后再通过一次高效的直接插入排序完成最终排序

![[2015-exam-paper-ocr.pdf#page=2&rect=79,771,469,818|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.40.44.png]]
 - I: 机器语言程序
	 -  计算机硬件能够直接执行 #机器语言程序 
	 - 执行过程 
		 - CPU的控制单元从内存中取出一条机器指令，解码它，然后命令算术逻辑单元（ALU）等部件执行相应的操作。这个过程是硬件层面的，没有任何软件翻译。

-  II: 汇编语言程序
	 需要“汇编”这个翻译步骤，所以汇编语言程序不能被硬件**直接**执行。因此，选项 II 是错误的。
-  III: 硬件描述语言程序
	- #硬件描述语言程序 根本不是由计算机硬件执行的程序，而是用来设计硬件的。因此，选项 III 是错误的。
- [[编译器和解释器的区别]] 
- [[程序到可执行文件（程序的生命周期）]]
- [[指令集体系结构]] 
	-  **考点**: 可能会问为什么机器语言不通用。答案是因为不同类型的CPU（如Intel x86, ARM, MIPS）有不同的ISA，它们的机器语言互不兼容。

![[2015-exam-paper-ocr.pdf#page=2&rect=78,731,473,772|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.40.51.png]]
[[截屏2025-09-30 上午3.40.56.png]]
[[补码的表示范围]]   
#补码  [[补码]] 
1. 确定符号位
	1. 要想表示的整数最小，这个数必须是负数。根据补码规则，负数的符号位（最高位）必须是 **1**。
	    所以，这个 8 位数的格式必定是 `1xxxxxxx`
2. 最小化数值
	我们使用 #按权展开求和 的公式来分析如何让数值最小。
	    $V = -1 \times 2^7 + (b_6 \times 2^6 + b_5 \times 2^5 + ... + b_0 \times 2^0)$
	    $V = -128 + (\text{后面7位数值位的加权和})$
	    我们必须让括号里的“后面7位数值位的加权和”尽可能**小**
	1.  2 个“1”和 5 个“0”可以用来填充这 7 个位置。为了使加权和最小，我们应该把“1”放在权重最低的位置上
		*   $b_1 = 1$
		*   $b_0 = 1$
3. **构建最终的补码：**
    将符号位和数值位组合起来，我们得到的 8 位二进制补码是：
    `10000011`
4.  **计算真值：**
    我们用公式来计算这个补码的十进制值：
    $V = -1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 0 \times 2^4 + 0 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0$
    $V = -128 + 0 + 0 + 0 + 0 + 0 + 2 + 1$
    $V = -128 + 3$
    $V = -125$
 - 衍生 
	 - 求最大整数
		*   **思路：** 最大数必然是正数，符号位为 **0**。
	    *   **构建：** `0xxxxxxx`。剩下 3 个“1”和 4 个“0”。为了使数值最大，应将 3 个“1”放在权重最高的数值位上。
	    *   **补码：** `01110000`
	    *   **真值：** $0 \times 2^6 + 1 \times 2^6 + 1 \times 2^5 + 1 \times 2^4 + 0... = 64 + 32 + 16 = 112$。
	- 求最接近零的负数
		*   **思路：** 仍然是负数，符号位为 **1**。
	    *   **构建：** `1xxxxxxx`。剩下 2 个“1”和 5 个“0”。为了让负数的值最大（绝对值最小），应将 2 个“1”放在权重最高的数值位上。
	    *   **补码：** `11100000`
	    *   **真值：** $-128 + 1 \times 2^6 + 1 \times 2^5 = -128 + 64 + 32 = -32$。（这对应了选项 C）
	- [[编码方式]]  #不同编码方式 
		- 题目可能会将“补码”换成“**原码 (Sign-Magnitude)**”或“**反码 (One's Complement)**”。
	    *   **原码：** `10000011` 表示 -3。在原码中，要使负数最小（绝对值最大），应将“1”放在数值位的最高位。`11100000` 表示 $-(64+32)=-96$。
	    *   **反码：** 规则又有所不同，负数的反码是其原码数值位按位取反。
	- #特殊值的补码     
		*   最小负数：-128 的补码是 `10000000`。
	    *   最大正数：127 的补码是 `01111111`。
	    *   -1 的补码：`11111111`。
	    这些特殊值经常作为考点出现。


![[2015-exam-paper-ocr.pdf#page=2&rect=77,674,490,735|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.04.png]]

[[浮点数运算规则]] 
   - I. 对阶操作不会引起阶码上溢或下溢。
	  **知识点**：对阶操作的规则。
	*   **详细分析**：对阶的目的是让两个浮点数的阶码相同，以便它们的尾数可以直接相加减。规则是“小阶向大阶看齐”。也就是说，将阶码较小的数的阶码增加，同时将其尾数相应地右移（每右移一位，阶码加1），直到两个数的阶码相等。
	*   **推导**：在这个过程中，最终的阶码等于两个原始阶码中较大的那个。既然两个原始浮点数都是合法的、可表示的数，它们的阶码（无论是较大的还是较小的）本身就没有溢出。因此，对阶后得到的公共阶码也必然在可表示的范围内，既不会上溢（超过最大阶码），也不会下溢（低于最小阶码）。
	*   **结论**：叙述 I 是**正确**的
- II. 右规和尾数舍入都可能引起 #阶码上溢 
	-  **知识点**：规格化（右规）与舍入操作。
	*   **详细分析**：
	    *   **右规 (Right Normalization)**：当尾数加减运算的结果发生溢出时（例如，两个正的规格化尾数相加，结果的整数部分为1，如 $0.1... + 0.1... = 1.0...$），需要进行右规。右规操作将尾数右移一位，并使阶码加1。如果此时的阶码已经是其能表示的最大值，再加1就会导致**阶码上溢**。
	    *   **尾数舍入 (Mantissa Rounding)**：在对阶或右规过程中，尾数可能会因为右移而丢失低位。为了保证精度，需要进行舍入操作（如“0舍1入”法）。如果舍入时发生进位，这个进位可能会一直传递，导致整个尾数溢出（例如，`0.111...1` + 进位 = `1.000...0`）。这种情况与尾数运算溢出类似，同样需要通过右规来处理，即尾数右移一位，阶码加1。因此，舍入操作也可能间接导致阶码加1，从而引发**阶码上溢**。
	*   **结论**：叙述 II 是**正确**的。
- III. 左规时可能引起 #阶码下溢
	*   **知识点**：规格化（左规）。
	*   **详细分析**：
	    *   **左规 (Left Normalization)**：当两个相近的数相减，或者一正一负的数相加时，结果的尾数可能会变得非常小，即小数点后出现多个0（例如，$0.000...1...$）。为了满足规格化要求（通常要求尾数最高位为有效数字），需要进行左规。左规操作将尾数左移一位，并使阶码减1，重复此过程直到尾数规格化。如果此时的阶码已经是其能表示的最小值，再减1就会导致**阶码下溢**。
	*   **结论**：叙述 III 是**正确**的。
-  IV. 尾数溢出时，结果不一定溢出
	*   **知识点**：尾数溢出与最终结果溢出的关系。
	*   **详细分析**：在第二步“尾数加减”中，可能会出现尾数溢出（也称为“假溢出”）。如前所述，尾数溢出（例如，结果为 $1.xxxx...$）是运算过程中的一个中间状态。计算机会通过**右规**操作来修正它：将尾数右移一位（变为 $0.1xxxx...$），同时将阶码加1。
	*   **推导**：
	    *   如果阶码加1后，新的阶码仍在可表示范围内，那么整个浮点数的结果就是有效的，**没有溢出**。
	    *   只有当阶码加1后，新的阶码超出了最大表示范围（即发生阶码上溢），整个浮点数的结果才被判断为**溢出**。
	*   **结论**：因此，尾数溢出只是一个中间步骤，它本身不代表最终结果溢出。最终结果是否溢出取决于右规后阶码的情况。叙述 IV 是**正确**的。

- 衍生 
	- [[IEEE 754 标准]] 
	- #浮点数运算的实例计算 
		-   给出两个具体的二进制或十六进制浮点数，要求手动完成加减运算的全过程，包括对阶、尾数运算、规格化、舍入和溢出判断。
	    *   例如：计算 $1.011 \times 2^3 + 1.101 \times 2^2$。
	- #舍入误差 
		-     对阶过程中，小阶码数的尾数右移会丢失最低有效位，这是浮点运算产生误差的主要来源之一。
	    *   常见的舍入策略：向0舍入、向 $+\infty$ 舍入、向 $-\infty$ 舍入、向最近偶数舍入（IEEE 754默认）。
	- #浮点数运算的性质 
		*   浮点数加法不满足结合律：$(a+b)+c$ 不一定等于 $a+(b+c)$，因为每次运算都可能引入舍入误差。
	    *   这是并行计算和编译器优化中需要特别注意的问题。
	

![[2015-exam-paper-ocr.pdf#page=2&rect=77,607,521,673|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.13.png]]

[[写策略]]  
 1. 分析地址结构 #直接映射   [[地址映射]] 

| 标记 (Tag) | Cache 行号 (Index) | 块内地址 (Offset) |
| :--- | :--- | :--- |

1. **计算块内地址 (Offset) 的位数：**
    *   题目说明主存是**按字节编址 (Byte-addressable)**。
    *   块大小为 4 个字 (word)，每个字为 32 位。
    *   因此，一个 Cache 块的大小 (Block Size) 为：
        $Block Size = 4 \text{ words} \times 32 \text{ bits/word} = 128 \text{ bits}$
    *   换算成字节：
        $Block Size = 128 \text{ bits} / 8 \text{ bits/byte} = 16 \text{ Bytes}$
    *   为了能寻址块内的每一个字节，需要的地址位数是：
        $Offset Bits = \log_2(16) = \log_2(2^4) = 4 \text{ 位}$

*   **计算 Cache 行号 (Index) 的位数：**
    *   Index 用于确定主存块应该映射到 Cache 的哪一行。因此，Index 的位数由 Cache 的总行数决定。
    *   题目给出 Cache 能存放 4K 字的数据。
        $Cache Data Capacity = 4\text{K words}$
    *   每个 Cache 行（块）存放 4 个字的数据。
    *   因此，Cache 的总行数 (Number of Lines) 为：
        $Number of Lines = \frac{\text{Total words in Cache}}{\text{Words per line}} = \frac{4\text{K words}}{4 \text{ words/line}} = 1\text{K lines}$
    *   $1\text{K} = 1024 = 2^{10}$。所以，为了索引这 1024 行，需要的地址位数是：
        $Index Bits = \log_2(1024) = \log_2(2^{10}) = 10 \text{ 位}$

*   **计算标记 (Tag) 的位数：**
    *   主存地址总共 32 位，减去 Index 和 Offset 的位数，剩下的就是 Tag 的位数。
    *   $Tag Bits = \text{Total Address Bits} - \text{Index Bits} - \text{Offset Bits}$
    *   $Tag Bits = 32 - 10 - 4 = 18 \text{ 位}$
- 32 位地址的划分：18 位标记 (Tag)，10 位行号 (Index)，4 位块内地址 (Offset)。 
1. 计算 #Cache总容量  
	
	*   **计算数据存储容量 (Data Storage Capacity)：**
	    *   题目直接给出 Cache 能存放 4K 字的数据，每字 32 位。
	    *   $Data Capacity = 4\text{K words} \times 32 \text{ bits/word}$
	    *   $Data Capacity = 4 \times 1024 \times 32 = 131072 \text{ bits}$
	    *   为了方便与选项比较，我们换算成 K 位（注意，这里的 K 是 1024）：
	        $Data Capacity = \frac{131072}{1024} = 128\text{K bits}$
	
	*   **计算标记阵列容量 (Tag Array Capacity)：**
	    *   标记阵列为 Cache 的**每一行**都存储一些管理信息。这些信息通常包括：
	        1.  **有效位 (Valid Bit):** 1 位。用于表示该 Cache 行中的数据是否有效。
	        2.  **标记位 (Tag Bit):** 我们已经计算出为 18 位。
	        3.  **脏位 (Dirty Bit):** 1 位。由于题目明确采用**回写 (Write Back)** 方式，所以需要一个脏位。当 Cache 中的数据被修改后，脏位被置为 1，表示该数据与主存不一致，在被替换出去时需要写回主存。
	        4.  **替换算法控制位 (Replacement Bits):** 对于直接映射，一个主存块只能映射到唯一一个 Cache 行，不存在替换选择问题，因此不需要替换算法控制位。
	    *   因此，每个 Cache 行需要存储的额外信息位数为：
	        $Overhead per Line = \text{Tag Bits} + \text{Valid Bit} + \text{Dirty Bit}$
	        $Overhead per Line = 18 + 1 + 1 = 20 \text{ bits}$
	    *   Cache 共有 1K ($2^{10}$) 行，所以标记阵列的总容量为：
	        $Tag Array Capacity = \text{Number of Lines} \times \text{Overhead per Line}$
	        $Tag Array Capacity = 1\text{K} \times 20 \text{ bits} = 1024 \times 20 = 20480 \text{ bits}$
	    *   同样，换算成 K 位：
	        $Tag Array Capacity = \frac{20480}{1024} = 20\text{K bits}$
	
	*   **计算总容量 (Total Capacity)：**
	    *   $Total Capacity = \text{Data Capacity} + \text{Tag Array Capacity}$
	    *   $Total Capacity = 128\text{K bits} + 20\text{K bits} = 148\text{K bits}$
	
	所以，最终答案是 **148K**，选择 **C**。
- 衍生      
	- 改变映射方式
		- #全相联映射
			- 地址划分只有 **Tag** 和 **Offset**。Offset 仍为 4 位，则 Tag 为 $32-4=28$ 位。此外，全相联映射必须有替换算法（如 LRU），因此每行还需要额外的替换算法控制位。例如，对于 LRU 算法，1K 行 Cache 大约需要 $\lceil\log_2(1024!)\rceil$ 位，或者简化为 $\log_2(1024)=10$ 位来近似。计算会变得复杂
		- #组相连映射  
			- 例如，如果是 **4路组相联 (4-way set-associative)**，地址划分为 **Tag | 组号 (Set Index) | Offset**。
		        *   Cache 总行数为 1K，4 行为一组，则总组数 = $1\text{K} / 4 = 256 = 2^8$ 组。
		        *   组号 (Set Index) 需要 8 位。
		        *   Offset 仍然是 4 位。
		        *   Tag 位数 = $32 - 8 - 4 = 20$ 位。
		        *   每组内需要替换算法，例如用 2 位 LRU 控制位来管理 4 行。
		        *   此时每行开销 = $20 (\text{Tag}) + 1 (\text{Valid}) + 1 (\text{Dirty}) + 2 (\text{LRU}) = 24$ 位。
		        *   标记阵列容量 = $1\text{K} \times 24 \text{ bits} = 24\text{K bits}$。
		        *   总容量 = $128\text{K} + 24\text{K} = 152\text{K bits}$。
		- 改变[[写策略]] 
			-   如果题目改为 #写直通 ，那么 Cache 和主存的数据总是保持一致，就不再需要 #脏位
			    *   此时每行开销 = $18 (\text{Tag}) + 1 (\text{Valid}) = 19$ 位。
			    *   标记阵列容量 = $1\text{K} \times 19 \text{ bits} = 19\text{K bits}$。
			    *   总容量 = $128\text{K} + 19\text{K} = 147\text{K bits}$ (即选项 B)
		- 改变编码方式[[编码方式]] 
			- 如果题目改为**按字编址 (Word-addressable)**，那么地址的最小单位是字。
			    *   块大小为 4 个字，寻址块内的字需要 $\log_2(4)=2$ 位。
			    *   Offset 位数变为 2 位。
			    *   Index 仍为 10 位 (因为 Cache 总容量和块大小的单位都是“字”，计算行数不受影响)。
			    *   Tag 位数 = $32 - 10 - 2 = 20$ 位。
			    *   每行开销 = $20 (\text{Tag}) + 1 (\text{Valid}) + 1 (\text{Dirty}) = 22$ 位。
			    *   标记阵列容量 = $1\text{K} \times 22 \text{ bits} = 22\text{K bits}$。
			    *   总容量 = $128\text{K} + 22\text{K} = 150\text{K bits}$。



![[2015-exam-paper-ocr.pdf#page=2&rect=80,547,525,610|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.24.png]]
[[主存访问]] [[1.主存]] 
#主存访问次数 [[总线与主存技术]]  [[指令周期]]  [[指令流水线与冲突]]
1. 读取 `x` 的值 
	1.  地址翻译 
		1. CPU发出 `x` 的虚拟地址 `xaddr`。为了得到物理地址，系统首先查找TLB。
		    *   **最理想情况**: **TLB命中 (TLB Hit)**。这意味着 `xaddr` 所在的页的页表项（Page Table Entry）已经在TLB中，因此**无需访问主存中的页表**来获取物理地址。
	2. **数据获取**: 获得物理地址后，CPU会先在Cache中查找该地址的数据。
	    *   **最理想情况**: **Cache命中 (Cache Hit)**。这意味着 `x` 的值已经在Cache中，CPU可以直接从Cache中读取，**无需访问主存**。
	3. **结论**: 在读取阶段，最理想的情况下（TLB命中 + Cache命中），访问主存的次数是 **0**。
2.  写入 `x` 的新值 
	1. **地址翻译**: 与读取操作一样，我们假设是**TLB命中**，因此地址翻译过程不需要访问主存。
	
	2. **数据写入**: CPU将计算出的新值写入 `xaddr`。此时，写策略起作用。
	    *   题目明确指出采用 #直写 (Write-Through)  策略。  [[写策略]]
	    *   根据直写策略的定义，每次写操作，数据不仅会更新到Cache中（如果该地址在Cache中），还**必须**被写入到主存中，以保证主存和Cache的数据一致性。
	    *   因此，无论Cache是否命中，这个写操作**必定会引发一次对主存的访问**。
	 **结论**: 在写入阶段，由于采用了直写策略，访问主存的次数**至少**是 **1**
- 知识点
	- [[页式存储管理]] 
		- #地址翻译 : CPU发出的虚拟地址 `VA` 分为虚拟页号 `VPN` 和页内偏移 `offset`。通过 `VPN` 在页表中查找对应的物理页框号 `PFN`，然后组合成物理地址 `PA = PFN + offset`
	- [[快表TLB]]
	- [[高速缓存Cache]]
- 衍生 
	- #最大访问次数 
		-   **读取 `x`**: TLB未命中 (访问主存1次查页表) + Cache未命中 (访问主存1次取数据) = **2次**。
	        *   **写入 `x`**: 由于地址在读取时已经翻译过，TLB此时应该命中了。但写操作因为是直写，必须访问主存1次。所以写入阶段是 **1次**。
	        *   总计最多访问次数 = $2 + 1 = 3$ 次。所以选项D是一个强干扰项。
	* 改变Cache写策略
		*   如果题目将策略改为**写回 (Write-Back)**，问最少访问次数：
	        *   **读取 `x`**: 最理想情况（TLB命中+Cache命中），访问主存 **0次**。
	        *   **写入 `x`**: 在写回策略下，写操作只更新Cache，不立即写入主存。因此，最理想情况下，访问主存 **0次**。
	        *   总计最少访问次数 = $0 + 0 = 0$ 次。答案会变成A
	- 考虑 #缺页中断  [[缺页中断]]  
		- 这是最极端的情况。如果在访问 `xaddr` 时发生缺页（即该页不在主存中），系统会触发缺页中断。处理过程包括：
	        1.  访问磁盘，将需要的页调入主存。
	        2.  更新页表（这本身可能是一次主存写操作）。
	        3.  重新执行指令。
	    *   这个过程涉及多次主存访问和极慢的磁盘I/O，通常在计算访问次数时会特别说明是否考虑缺页。
	- #平均访存时间AMAT  [[访存时间计算]]  
		-  这是一个综合性考点，会给出TLB命中率、Cache命中率、各级存储的访问时间，要求计算AMAT。
		- $AMAT = T_{TLB} + (1 - H_{TLB}) \times T_{Mem} + T_{Cache} + (1 - H_{Cache}) \times T_{Mem}$
			$H_{TLB}$ 是TLB命中率，$H_{Cache}$ 是Cache命中率，$T_{TLB}$、$T_{Cache}$、$T_{Mem}$ 分别是访问TLB、Cache和主存的时间。这个公式可以根据具体情况简化或复杂化 
![[2015-exam-paper-ocr.pdf#page=2&rect=82,510,466,550|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.31.png]]
[[RAM和ROM的区别]]
[[Flash Memory 闪存的分类]] 
[[存储器的分类及其工作原理]] 

- 衍生  
	- [[SRAM与DRAM对比]]  比较维度： 存储原理、是否需要刷新、速度、集成度、成本、功耗、主要用途
	- [[存储器的层次结构]]      
		*   考察不同存储器在计算机系统中的位置。 
			* 从上到下依次是：**CPU寄存器 -> Cache (SRAM) -> 主存 (DRAM) -> 外部存储 (SSD/FLASH, 硬盘)**
		- [[DRAM刷新方式]]   可能会问及具体的刷新方式


![[2015-exam-paper-ocr.pdf#page=2&rect=81,466,519,512|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.38.png]]
4体交叉编址存储器 #四体低位交叉存储  #交叉存储 [[总线与主存技术]]
- [[访存冲突]]  [[指令流水线与冲突]]  **在本题中的判断**：题目给出了一个连续的访存地址序列。要判断是否发生冲突，我们只需要检查在这个序列中，**两个连续的访问请求**是否指向了同一个存储模块。
1. 第一步：确定参数 
	*   交叉模块数 $N=4$。
	*   访存地址序列 A = {8005, 8006, 8007, 8008, 8001, 8002, 8003, 8004, 8000}。
2. 第二步：计算每个地址对应的模块序号 
	1. 使用公式 $M = A \pmod 4$ 来计算序列中每个地址对应的模块号。
		*   $8005 \pmod 4 = 1$
		*   $8006 \pmod 4 = 2$
		*   $8007 \pmod 4 = 3$
		*   $8008 \pmod 4 = 0$
		*   $8001 \pmod 4 = 1$
		*   $8002 \pmod 4 = 2$
		*   $8003 \pmod 4 = 3$
		*   $8004 \pmod 4 = 0$
		*   $8000 \pmod 4 = 0$
		观察计算出的模块序号序列：{1, 2, 3, 0, 1, 2, 3, **0, 0**}
	- 在这个序列的末尾，我们发现有两个连续的`0`。这对应着对地址 `8004` 和 `8000` 的访问。因为这两个**连续的访问**都请求了**同一个模块（模块0）**，所以它们之间会发生访存冲突。 
- 衍生   
	- [[高位交叉编址vs低位交叉编址]] 
		- **考法**：题目可能会明确指出是高位还是低位交叉，或者让你根据地址分配模式判断是哪一种，并分析其优缺点。
- [[存储器带宽计算]] 
- #冲突对性能的影响 
	- **考法**：给出一个访存地址序列，要求计算完成所有访问所需的总时间。你需要先计算出每个地址的模块号，找出冲突点。每发生一次冲突，就需要增加一个等待时间（通常是一个存储周期 $T$ 减去总线周期 $\tau$）。
[[总线带宽计算]]


![[2015-exam-paper-ocr.pdf#page=2&rect=80,387,349,462|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.46.png]]
- [[总线定时]] 
- 
- [[异步通信]]    
	-   **A. 异步通信方式中，全互锁协议最慢**：正确。全互锁协议的握手过程最复杂，包含四步，因此耗时最长。
	- **B. 异步通信方式中，非互锁协议的可靠性最差**：正确。非互锁协议没有应答机制，完全依赖于时间假设，容易出错。
- [[同步通信]]  **C. 同步通信方式中，同步时钟信号可由各设备提供**：**错误**。同步通信的基石就是一个统一的、全局的时钟信号，由中心时钟源提供
- [[半同步通信]]  **D. 半同步通信方式中，握手信号的采样由同步时钟控制**：正确。主设备在时钟信号的边沿对`WAIT`/`READY`等握手信号进行采样，以决定是否需要插入等待周期
- 衍生  
	- [[总线带宽计算]]  - $总线带宽 = 总线时钟频率 \times \frac{总线宽度(bit)}{8} \div 每个数据传输所需的时钟周期数$   
	- [[总线仲裁]]
	- [[同步通信与异步通信的优缺点对比]] 
	- #实际总线标准举例   可能会要求你判断某个具体的总线标准（如ISA, PCI, PCIe, USB, I²C）属于哪种通信方式。 
		- 例如：PCI总线是典型的同步总线；RS-232是典型的 #异步串行通信 ；I²C总线则是一种半同步通信方式。


![[2015-exam-paper-ocr.pdf#page=2&rect=78,337,526,388|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.41.54.png]]
- [[磁盘存储时间的计算（磁盘访问时间的计算）]]  
	-    总存取时间 $T_a$ = 寻道时间 $T_s$ + 旋转延迟时间 $T_r$ + 数据传输时间 $T_t$ + 控制器延迟
1. 第一步：计算平均旋转延迟时间
	1. 将转速单位从 rpm (转/分钟) 转换成 rps (转/秒):
		1. $7200 \text{ rpm} = \frac{7200 \text{ 转}}{60 \text{ 秒}} = 120 \text{ rps}$
	2. 计算旋转一圈所需的时间（秒）
		1. 时间 = $\frac{1}{\text{转速(rps)}} = \frac{1}{120}$ 秒
	3. 将时间单位转换为毫秒 (ms):
		1. $\frac{1}{120} \text{ 秒} \times 1000 \frac{\text{ms}}{\text{秒}} \approx 8.33 \text{ ms}$
	4. 计算平均旋转延迟时间（半圈时间）
		$T_{latency} = \frac{1}{2} \times \text{旋转一圈的时间} = \frac{1}{2} \times 8.33 \text{ ms} \approx 4.167 \text{ ms}$
	    题目解析中保留了两位小数，记为 $4.17 \text{ ms}$。
	其计算公式为：
	$T_{latency} = \frac{1}{2} \times \frac{60 \times 1000}{RPM} = \frac{1}{2} \times \frac{60000}{7200} \approx 4.17\text{ms}$
2. $T_{access} = T_{seek} + T_{latency} + T_{transfer}$
	$T_{access} = 8\text{ms} + 4.17\text{ms} + 0.01\text{ms} = 12.18\text{ms}$
- 衍生 
	- #读取连续的多个扇区 
	- #读取随机的多个扇区 
		-  **问题场景**：如果要读取分布在不同磁道、不同位置的 **N** 个扇区，总时间是多少？
		    *   **分析**：由于每个扇区的位置都是随机的，因此读取每一个扇区都需要完整地经历一次“寻道 + 延迟 + 传输”的过程。
		    *   **公式**：$T_{total\_N\_random} = N \times (T_{seek} + T_{latency} + T_{transfer}) = N \times T_{access}$
		    *   **本题示例**：若要随机读取10个扇区，总时间约为 $10 \times 12.2 = 122\text{ms}$
	-  [[磁盘调度算法]] 
		-    **背景**：当有多个 I/O 请求等待访问磁盘时，操作系统需要决定处理这些请求的顺序，以最小化总的寻道时间。








![[2015-exam-paper-ocr.pdf#page=2&rect=78,289,532,339|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.42.03.png]]
1. [[IO控制方式]]  
- 衍生 
	- [[单级中断处理流程]]
		-  中断响应的条件是什么？（例如，中断允许位置`EINT=1`）
	    *   中断处理的具体步骤：关中断 -> 保存现场（程序计数器PC、寄存器等） -> 识别中断源 -> 执行中断服务程序 -> 恢复现场 -> 开中断 -> 中断返回
	- [[DMA工作流程]] 
	- 场景应用题
		-    问题可能会描述一个具体的应用场景（如“从磁盘读取一个10MB的文件”），然后问哪种I/O方式最合适。答案显然是DMA，因为它是高速设备和块数据传输。
		- 对于“响应用户键盘输入”，中断方式最合适，因为它能及时响应，且数据量小，CPU开销可以接受


![[2015-exam-paper-ocr.pdf#page=2&rect=79,200,524,292|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.42.10.png]]

[[中断、异常和系统调用的区别与联系]]
[[缺页中断（缺页异常）的处理流程]]
[[区分中断、异常和系统调用]]
1. B. #内部异常的检测 由 CPU 内部逻辑实现  
	1. 这种检测异常的工作肯定是由 CPU（包括控制器和运算器）实现的”。CPU内部有专门的硬件逻辑电路来检测指令执行过程中的各种状态，比如检查除法运算的除数是否为零、检查内存访问地址是否越界、检查指令操作码是否合法等 
2. C. 内部异常的响应发生在指令执行过程中
	1. 分析： 解析中指出，“内中断不能被屏蔽，一旦出现应立即处理”。这意味着当CPU的内部逻辑在执行一条指令的过程中检测到异常时，它会立即暂停当前的指令流，转而去执行异常处理程序。这个响应动作就发生在指令的执行周期内。
3. D. 内部异常处理后返回到发生异常的指令继续执行
	1. 分析：“考虑到特殊情况，如除数为零和自行中断（INT）都会自动跳过中断指令，所以不会返回到发生异常的指令继续执行”。
	    *   对于**故障 (Fault)** 类型的异常，比如“缺页中断”，操作系统处理完（把需要的页调入内存）之后，会返回到**引起缺页的指令**，让它**重新执行**一次，这一次就能成功访问内存了。
        *   但对于**陷阱 (Trap)**（如系统调用）和**终止 (Abort)**（如除零错误）类型的异常，处理完后通常不会重新执行原指令。陷阱执行完后会返回到**下一条指令**继续执行。而终止类型的错误往往是致命的，程序可能会被直接终止。
- [[异常的分类]]  
- 衍生 
	- [[缺页中断（缺页异常）的处理流程]]
	- [[中断向量与中断向量表]]   **作用：** 存储了不同中断号对应的中断服务程序的入口地址。当中断发生时，CPU根据中断号查询此表，以确定跳转到哪里去执行
	- [[用户态与内核态]]


![[2015-exam-paper-ocr.pdf#page=2&rect=78,149,427,203|2015-exam-paper-ocr, p.2]]
[[截屏2025-09-30 上午3.42.26.png]]
- 核心是区分在中断处理过程中，**硬件自动完成**的工作和**操作系统（软件）需要完成**的工作 
[[中断处理机制]]
*   **A. 程序计数器 (PC) 的内容**: 如上所述，PC（断点）是由硬件在中断响应阶段通过“中断隐指令”自动保存的。因此，这不是操作系统的工作。
*   **B. 通用寄存器的内容**: 操作系统编写的中断服务程序在开始执行时，必须先将当前所有可能被用到的通用寄存器的值压入栈中保存起来，在处理完中断准备返回前，再从栈中弹出这些值，恢复到寄存器中。这是操作系统的任务。因此，B是正确的。
*   **C. 块表 (TLB) 中的内容**: TLB (Translation Lookaside Buffer) 是用于加速虚拟地址到物理地址转换的硬件缓存。它的内容由MMU（ #内存管理单元 ）硬件管理。在发生进程切换时（中断可能导致进程切换），TLB可能会被刷新（清空），但操作系统不会“保存”和“恢复”它的内容。
*   **D. Cache 中的内容**: Cache是CPU的高速缓存，用于存储主存中常用数据的副本，由硬件自动管理。操作系统一般不直接干预Cache内容的保存与恢复。Cache中的数据通过地址与进程关联，只要地址空间不变，其内容就是有效的。

- 衍生 
	- #中断向量表 (IVT) 
		-   **作用**: 存储中断服务程序入口地址的表。每个中断类型都有一个唯一的编号（中断向量号），CPU通过这个编号在IVT中查找对应的ISR地址 
		- **考点**: IVT的地址存放在哪里？（通常在内存的固定低地址区域，由一个专门的寄存器指向）。如何计算ISR地址？通常是 $ISR_{地址} = IVT_{基地址} + 中断向量号 \times 表项大小$ 
	- #用户态与核心态的状态切换  
		*   **如何切换**: 这个切换过程也是由中断隐指令自动完成的，通常通过修改PSW中的特权级标志位来实现。中断返回时再切换回用户态。
	- [[中断嵌套]]  
		- **处理**: 如果系统允许中断嵌套，那么在ISR执行前，除了关中断，还需要设置一个更高的中断屏蔽级别。当更高优先级的中断到来时，CPU会再次暂停当前的ISR，去处理新的中断，形成嵌套。处理完后逐层返回。这就要求现场保护必须使用**栈**结构来保存上下文，以支持后进先出的返回顺序。

![[2015-exam-paper-ocr.pdf#page=2&rect=77,54,519,151|2015-exam-paper-ocr, p.2]]
[[Pasted image 20250930034311.png]]
 [[用户态与核心态的状态切换]] 
- **总结：** 任何导致 **中断** 或 **异常** 发生的指令，都会引发 CPU 从用户态切换到内核态。 
1. A. DIV R0, R1 
	1. **操作**：执行除法运算，将寄存器 R0 的内容除以寄存器 R1 的内容，结果存回 R0。数学表示为 $(R0) / (R1) \rightarrow R0$ 
	2.    **分析**：如果此时寄存器 R1 中的值为 0，执行该指令将引发一个“**除零异常 (Divide-by-zero Exception)**”。这是一个典型的异常事件，CPU 会立即停止当前程序的执行，切换到内核态，并调用相应的异常处理程序。
	    *   **结论**：**可能**导致状态切换。
2. B. INT n 
	1. **操作**：产生一个软件中断 (Software Interrupt)。 [[特权指令类型]]
	    *   **分析**：`INT` 指令是专门设计用来触发中断的，是实现**系统调用**的经典方式。执行这条指令会**主动地**、**确定地**使 CPU 从用户态切换到内核态，去执行中断向量表中第 `n` 号中断服务程序。
	    *   **结论**：**必然**导致状态切换。
- 衍生 
	- #特权指令与非特权指令 
		*   **特权指令**：只能在内核态下执行的指令，如启动 I/O、修改程序状态字 (PSW)、设置时钟、清空内存等。如果在用户态下尝试执行，会引发“非法指令”异常。
	    *   **非特权指令**：在用户态和内核态下都可以执行的指令，如算术运算、逻辑运算、大部分的访存指令等。`NOT R0` 就是一个典型的非特权指令。
	- [[单级中断处理流程]] **考点**：中断处理过程的排序、中断屏蔽、中断嵌套等 
	- [[异常的分类]]
		- 考点：区分不同类型的异常及其处理后的返回行为
	- 系统调用的实现机制 [[系统调用的过程]]  **考点**： #系统调用的参数传递方式 、 #用户态和内核态堆栈的切换 



![[2015-exam-paper-ocr.pdf#page=2&rect=74,20,535,63|2015-exam-paper-ocr, p.2]]
[[Pasted image 20250930034317.png]]
- [[进程状态模型]] 
	*   **就绪态 (Ready):** 万事俱备，只欠CPU。
    *   **阻塞态 (Blocked):** 缺少CPU以外的某种资源或等待某个事件，即使给了CPU也无法运行。
1.  选项A、B、C都是因为进程需要等待CPU以外的资源或事件而主动放弃CPU，进入阻塞态。只有选项D是进程在依然可以运行的情况下，被动地被操作系统剥夺了CPU使用权，回到了就绪态。因此，D是正确答案。
- 衍生
	- 其他 #状态转换原因  考试可能会问导致其他状态转换的事件。例如：
		*   什么事件导致进程从**阻塞态**变为**就绪态**？（答案：等待的I/O操作完成、申请的资源得到满足等）。
	    *   什么事件导致进程从**就绪态**变为**执行态**？（答案：被进程调度程序选中）。
	    *   在分时系统中，什么事件会导致进程从**执行态**变为**就绪态**？（答案：时间片用完）。
	- [[七状态模型]] 
		- 考点可能涉及：
		    *   从**就绪态**到**静止就绪态**的转换原因是什么？（答案：内存被换出到外存）。
		    *   一个被挂起的阻塞进程，在它等待的I/O事件完成后，会进入什么状态？（答案：静止就绪态）。
	- [[进程同步的经典问题]] 
		$P/V$操作是解决进程同步问题的工具。考试可能会出一些经典问题，要求用$P/V$操作来解决。
		*   生产者-消费者问题
		*   读者-写者问题
		*   哲学家就餐问题
	
		


![[2015-exam-paper-ocr.pdf#page=3&rect=78,741,499,817|2015-exam-paper-ocr, p.3]]
[[Pasted image 20250930034331.png]]

[[死锁预防 vs 死锁避免vs 死锁检测与解除]] 
1. I. S1 会限制用户申请资源的顺序，而 S2 不会
	1. “限制用户申请资源的顺序”（例如，要求所有进程必须按资源编号递增的顺序申请资源）是一种**死锁预防**的手段，其目的是破坏“循环等待”条件
	*   **S1 (死锁避免)**：它不限制申请顺序，而是通过银行家算法等手段动态检查每次分配的安全性。
	*   **S2 (死锁检测)**：它更不会限制申请顺序，它允许死锁发生。
2. II. S1 需要进程运行所需资源总量信息，而 S2 不需要
	*   **S1 (死锁避免)**：其核心算法（如银行家算法）的运行基础就是必须预先知道每个进程对各类资源的**最大需求量 (Max)**，以便计算出每个进程未来还**需要 (Need)** 的资源量，从而判断系统的安全性。
	*   **S2 (死锁检测)**：它只关心**当前**的资源分配状态和进程的等待请求，通过分析资源分配图或类似的等待关系来查找是否存在循环等待。它完全不需要知道进程未来的最大需求。
3. III. S1 不会给可能导致死锁的进程分配资源，而 S2 会 
	1.   **结论**：这个叙述也准确地描述了两种策略的行为模式。**叙述 III 正确**。
- 衍生  
	- [[银行家算法核心思想与数据结构]]








![[2015-exam-paper-ocr.pdf#page=3&rect=78,692,532,747|2015-exam-paper-ocr, p.3]]
[[Pasted image 20250930034341.png]]

[[页式存储管理]]  #LRU [[页面置换算法]]
	- [[高速缓存Cache]] 
- 便捷法（逆向查找法）
	- 跳过重复的4 ，扫描到 **2**，找到第4个不同的页号。当前找到集合：`{5, 4, 8, 2}`。
		- 确定淘汰页：我们已经找到了4个不同的页号，这4个页号 `{5, 4, 8, 2}` 就是在访问页面`7`之前，驻留在内存中的4个页面。我们找到它们的顺序 `5, 4, 8, 2`
		- 淘汰这个最近最久未使用的页面`2`
- 衍生 
	- [[页面置换算法]] 



![[2015-exam-paper-ocr.pdf#page=3&rect=76,642,409,694|2015-exam-paper-ocr, p.3]]
[[Pasted image 20250930034348.png]]

[[缓冲技术]]  
- 衍生  
	- [[写策略]]
		- 数据同时写入缓存和磁盘。
	    *   **优点**：数据一致性好，可靠性高。
	    *   **缺点**：写操作的速度受限于较慢的磁盘，性能提升有限。
	* [[磁盘存储时间的计算（磁盘访问时间的计算）]] 
		* $T_a = T_s + T_r + T_t$
			* **示例**：假设一个磁盘转速为6000 RPM，平均寻道时间为8ms，每磁道有600个扇区，每扇区512字节。读取一个包含1200个扇区的文件的总时间是多少（假设文件数据连续存放）？




![[2015-exam-paper-ocr.pdf#page=3&rect=75,583,527,644|2015-exam-paper-ocr, p.3]]
[[Pasted image 20250930034354.png]]
[[Pasted image 20250930034401.png]]

[[索引文件的储存结构]]  [[多级索引]]  [[文件分配方式（文件物理结构）]]   [[索引分配]]
- **重要前提**: 文件的索引结点**已在内存中**。这意味着我们获取任何一个直接或间接指针的地址时，不需要访问磁盘。第一次访问磁盘是为了读取索引指针所指向的**索引块**或**数据块** 
1. 计算各级索引能表示的文件大小范围
	1. 在计算访问次数之前，我们首先要确定每个 #偏移量 （byte offset）属于哪个索引范围 
		1. 直接索引
		    *   有10个直接指针，每个指针指向一个数据块。
		    *   可寻址的数据大小为：$10 \times 1\text{KB} = 10\text{KB}$。
		    *   对应的字节偏移范围是 $[0, 10\text{KB} - 1]$，即 $[0, 10239]$。
		2. #一级索引 一级索引可寻址的数据大小为：$256 \times 1\text{KB} = 256\text{KB}$
		3. #二级索引 它覆盖的范围是在一级索引之后，字节偏移范围是 $[10\text{KB} + 256\text{KB}, 10\text{KB} + 256\text{KB} + 64\text{MB} - 1]$，即 $[272384, \dots]$。
 2. 分析具体偏移量的访问次数
	1.  **情况一：偏移量为 1234**
	    1.  **定位范围**: 因为 $1234 < 10240$，所以这个偏移量位于**直接索引**的范围内。
	    2.  **访问过程**:
	        *   由于索引结点已在内存中，系统直接从内存里的索引结点中找到对应的直接指针。（**0次磁盘访问**）
	        *   通过这个指针，系统获得了目标数据块在磁盘上的地址。
	        *   访问磁盘，读取该数据块。 （**1次磁盘访问**）
	    3.  **结论**: 总共需要 **1** 次磁盘访问。
	2.   **情况二：偏移量为 307400**
	    1.  **定位范围**:
	        *   直接索引范围：$[0, 10239]$
	        *   一级索引范围：$[10240, 272383]$
	        *   因为 $307400 > 272383$，所以这个偏移量位于**二级索引**的范围内。
	    2.  **访问过程**:
	        *   索引结点已在内存中，系统从中获取二级索引指针的地址。（**0次磁盘访问**）
	        *   该指针指向一级索引块。访问磁盘，读取这个**一级索引块**。（**第1次磁盘访问**）
	        *   现在一级索引块在内存中了。系统根据偏移量计算出需要用到该块中的哪个指针，这个指针指向二级索引块。
	        *   访问磁盘，读取这个**二级索引块**。（**第2次磁盘访问**）
	        *   现在二级索引块也在内存中了。系统再次根据偏移量计算出需要用到该块中的哪个指针，这个指针最终指向目标数据块。
	        *   访问磁盘，读取这个**数据块**。（**第3次磁盘访问**）
	    3.  **结论**: 总共需要 **3** 次磁盘访问。
两个偏移量所需的磁盘访问次数分别是 **1** 和 **3**。因此，正确答案是 **B**
- 衍生 
	- #索引结点不在内存中  
		- 这是最常见的变种。如果题目没有“索引结点已在内存中”这个前提，那么在所有计算之前，都需要**额外增加1次磁盘访问**来读取索引结点本身。在这种情况下，本题的答案就会变成 **2** 和 **4**。
	- #计算最大文件大小  #最大文件大小计算 
		- 题目可能会问，在这样的索引结构下，一个文件最大可以有多大？
		    *   最大文件大小 = 直接索引大小 + 一级索引大小 + 二级索引大小
		    *   $Size_{max} = (10 \times 1\text{KB}) + (256 \times 1\text{KB}) + (256 \times 256 \times 1\text{KB})$
		    *   $Size_{max} = 10\text{KB} + 256\text{KB} + 64\text{MB}$
	- 包含三级索引
		-  题目可能会增加一个三级索引指针（Triple indirect pointer）。其计算方式与二级索引类似，只是多了一层间接访问。
		- 三级索引可寻址大小 = $256 \times 256 \times 256 \times 1\text{KB} = 16\text{GB}$。
    *   访问三级索引范围内的数据（且索引结点在内存）需要4次磁盘访问（3次读索引块 + 1次读数据块）
- 反向计算
	- 给出文件大小，让你分析最后一个数据块是通过哪种索引方式访问的。例如，一个大小为300KB的文件，其最后一个块肯定是通过二级索引访问的，因为 $10\text{KB} + 256\text{KB} = 266\text{KB} < 300\text{KB}$。



![[2015-exam-paper-ocr.pdf#page=3&rect=79,532,452,584|2015-exam-paper-ocr, p.3]]
[[Pasted image 20250930034409.png]]
[[页面分配策略]] 
 [[页面置换策略]]    
1.  逻辑关系分析 
	1.   **A. 可变分配，全局置换**：
	    *   这种组合是**可行且常见**的。全局置换本身就隐含了“可变分配”的思想。因为当进程A从进程B那里“抢”来一个页框时，进程A的页框数增加了，进程B的减少了。这自然导致了每个进程的页框数是动态变化的。
	2.  **B. 可变分配，局部置换**：
	    *   这种组合也是**可行**的。虽然页面置换的范围是局部的（只能在自己的页框里换），但操作系统仍然可以根据监控到的进程行为（如缺页率）来主动增加或减少分配给该进程的页框总数。例如，当一个进程的缺页率过高，系统可以从空闲页框池中分配一个新的页框给它，这并不违反局部置换的原则。
	3. **C. 固定分配，全局置换**：
	    *   这种组合存在**根本性的逻辑矛盾**。
	    *   **固定分配**的核心要求是：每个进程的页框数量**恒定不变**。
	    *   **全局置换**的核心机制是：一个进程可以从**其他进程**那里获取页框。
	    *   **矛盾点**：如果允许全局置换，那么当进程A从进程B那里置换一个页面时，进程A的页框数就会+1，而进程B的页框数就会-1（在某个时间点上）。这就直接破坏了“固定分配”中每个进程页框数不变的基本前提。
	    *   因此，**固定分配和全局置换是互斥的，不能组合使用**。
	4. **D. 固定分配，局部置换**：
	    *   这种组合是**可行且最简单**的。系统给每个进程固定数量的页框，当进程缺页时，它就在自己的这几个页框里进行置换。进程之间互不干扰，实现简单。
	**结论：** 根据以上分析，选项C是不能组合使用的策略。题目解析中“对各进程进行固定分配时页面数不变，不可能出现全局置换”正是点明了这个核心矛盾。
- 衍生 
	- [[颠簸抖动]] 
		- #抖动/颠簸与策略的关系 
	        *   **局部置换**可以将抖动限制在单个进程内部，不会影响其他进程。
	        *   **全局置换**可能导致“抖动传播”，一个频繁缺页的进程可能会不断抢占其他进程的页面，导致整个系统都陷入抖动状态。
	        *   **可变分配**（特别是基于工作集的分配策略）是解决抖动的主要方法。
	* [[工作集模型]]
		*  **考点**：这是一种典型的**可变分配**策略
	- [[缺页率控制法]] 




![[2015-exam-paper-ocr.pdf#page=3&rect=80,471,514,535|2015-exam-paper-ocr, p.3]]
[[Pasted image 20250930034417.png]]
#文件管理系统 
	[[位图法]]  
-  题目解析 
	1. 第 1 步：计算一个位图盘块能表示多少个磁盘块


[[指令周期]]




![[2015-exam-paper-ocr.pdf#page=3&rect=79,408,531,472|2015-exam-paper-ocr, p.3]]









[[Pasted image 20250930034425.png]]

![[2015-exam-paper-ocr.pdf#page=3&rect=81,359,445,409|2015-exam-paper-ocr, p.3]]
![[Pasted image 20250930034432.png]]

![[2015-exam-paper-ocr.pdf#page=3&rect=80,201,491,357|2015-exam-paper-ocr, p.3]]
![[Pasted image 20250930034439.png]]

![[2015-exam-paper-ocr.pdf#page=3&rect=77,141,515,201|2015-exam-paper-ocr, p.3]]
![[Pasted image 20250930034447.png]]

![[2015-exam-paper-ocr.pdf#page=3&rect=78,58,356,140|2015-exam-paper-ocr, p.3]]
![[Pasted image 20250930034455.png]]


![[2015-exam-paper-ocr.pdf#page=4&rect=75,745,356,820|2015-exam-paper-ocr, p.4]]
![[Pasted image 20250930034503.png]]


![[2015-exam-paper-ocr.pdf#page=4&rect=78,622,507,742|2015-exam-paper-ocr, p.4]]
![[Pasted image 20250930034508.png]]


![[2015-exam-paper-ocr.pdf#page=4&rect=80,544,530,618|2015-exam-paper-ocr, p.4]]
![[Pasted image 20250930034516.png]]

![[2015-exam-paper-ocr.pdf#page=4&rect=75,424,494,544|2015-exam-paper-ocr, p.4]]
![[Pasted image 20250930034522.png]]

![[2015-exam-paper-ocr.pdf#page=4&rect=75,199,536,427|2015-exam-paper-ocr, p.4]]
![[Pasted image 20250930034541.png]]

![[2015-exam-paper-ocr.pdf#page=4&rect=79,35,548,197|2015-exam-paper-ocr, p.4]]
![[Pasted image 20250930034556.png]]
![[Pasted image 20250930034605.png]]
![[2015-exam-paper-ocr.pdf#page=5&rect=68,410,562,823|2015-exam-paper-ocr, p.5]]
![[Pasted image 20250930034616.png]]

![[2015-exam-paper-ocr.pdf#page=6&rect=73,330,562,822|2015-exam-paper-ocr, p.6]]
![[Pasted image 20250930034627.png]]

![[2015-exam-paper-ocr.pdf#page=6&rect=75,110,541,339|2015-exam-paper-ocr, p.6]]
![[Pasted image 20250930034635.png]]
![[Pasted image 20250930034643.png]]

![[截屏2025-09-30 上午3.47.03.png]]![[截屏2025-09-30 上午3.47.39.png]]







![[截屏2025-09-30 上午3.47.10.png]]
![[截屏2025-09-30 上午3.47.54.png]]


