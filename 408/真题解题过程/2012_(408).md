![[2012-exam-paper-ocr.pdf#page=1&rect=78,615,536,705|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250819181626.png]]
B
- [[时间复杂度分析]]  [[时间复杂度等价]]  
	- 要求我们分析一个递归函数的**时间复杂度** 
	- 对于递归算法，我们通常使用 #递推关系式 
	这个函数计算的并不是标准的阶乘。标准的阶乘是 `n * fact(n-1)`。这个函数计算的是 `n * (n-10) * (n-20) * ...` 直到参数小于等于1。
- **基本情况 (Base Case)**: 当`n <= 1`时，递归停止，函数返回1。这是递归的出口。
- **递归步骤 (Recursive Step)**: 当`n > 1`时，函数执行一次乘法，并调用自身，但输入的参数是`n-10`。
1. 设$T(n)$为函数`fact(n)`的执行时间
	- 当$n \le 1$时，函数只执行一次判断和一次返回，时间是一个常量，我们记为$O(1)$。
	- 当$n > 1$时，函数执行了一次判断、一次乘法和一次函数调用。这些操作（除递归调用外）的时间是常数，也记为$O(1)$。递归调用的时间是$T(n-10)$。
	- 因此，我们可以得到$T(n)$的递推关系式：
		$T(n) = \begin{cases} O(1) & \text{if } n \le 1 \\ T(n-10) + O(1) & \text{if } n > 1 \end{cases}$
	- 为了方便计算，我们通常将$O(1)$记为一个具体的常数$c$。
		$T(n) = T(n-10) + c$
2. 求解递推关系式（展开法/迭代法） 
	我们可以通过不断地将$T(n-10)$展开来求解：
	$T(n) = T(n-10) + c$
	$T(n) = (T(n-20) + c) + c = T(n-20) + 2c$
	$T(n) = (T(n-30) + c) + 2c = T(n-30) + 3c$
	经过$k$次展开后，我们可以得到一个通用模式：
	$T(n) = T(n-10k) + kc$
3. 当函数的参数$n-10k \le 1$时结束
	1. $k \ge \frac{n-1}{10}$
	2. 递归大约会进行$k = \lceil \frac{n-1}{10} \rceil$次。为了进行大O表示法的分析，我们只需要知道$k$的增长趋势，即$k$与$n$成正比  。我们可以近似地认为$k \approx \frac{n}{10}$
	$T(n) = O(n)$
- 衍生
	- #不同的递归递减/递增方式 [[不同的递归递减-递增方式]] 
		- 减常数（本题类型）
			-  $T(n) = T(n-c) + O(1)$ 
			- 除常数
				- $T(n) = T(n/b) + O(1)$
				  - 例子：二分查找。每次将问题规模缩小一半。
				  - 解法：递归深度为$k$时，问题规模为$n/b^k$。当$n/b^k=1$时递归结束，即$n=b^k$, $k=\log_b n$。总时间复杂度为$O(\log n)$。
			  - 减变量 $T(n) = T(n-\sqrt{n}) + O(1)$
	- [[分治法与主定理]] ``

![[2012-exam-paper-ocr.pdf#page=1&rect=76,547,530,612|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250819181649.png]]
[[Pasted image 20250827143201.png]]
A
1. [[表达式转换（前中后缀）]] 
- 算法规则
	1.  初始化一个操作符栈（通常会预先压入一个最低优先级的哨兵符号，如`#`，以方便处理边界情况）和一个后缀表达式列表。
	2.  从左到右扫描中缀表达式。
	3.  遇到**操作数**（如`a`, `b`, `c`）：直接输出到后缀表达式。
	4.  遇到**操作符**（如`+`, `-`, `*`, `/`）：
	    *   如果栈为空或栈顶是左括号`(`，直接将该操作符压栈。
	    *   否则，比较该操作符与栈顶操作符的优先级。
	    *   如果该操作符优先级**高于**栈顶操作符，压栈。
	    *   如果该操作符优先级**小于或等于**栈顶操作符，则将栈顶操作符弹出并输出到后缀表达式，重复此过程，直到该操作符优先级高于栈顶操作符或栈为空，然后将该操作符压栈。
	5.  遇到**左括号`(`**：直接压栈。
	6.  遇到**右括号`)`**：将栈顶的操作符依次弹出并输出，直到遇到左括号`(`。将左括号`(`弹出，但不输出。
	7.  中缀表达式扫描完毕后，将栈中剩余的所有操作符依次弹出并输出。
- 其最大值出现在处理字符`+`（在`c`和`d`之间）和`d`时，栈的内容为 `[`-`, `*`, `(`, `(`, `+`]`, **共5个操作符** 
- A. 5 
- 衍生
	- 中缀表达式转前缀表达式 
		-  算法与转后缀类似，但有两点关键不同：
	        *   从**右到左**扫描中缀表达式。
	        *   遇到右括号`)`压栈，遇到左括号`(`时弹出操作符。
	    *   最后将生成的结果字符串**反转**即可得到前缀表达式。 [[表达式转换（前中后缀）]]
	- 后缀表达式求值 
		- 这是另一个经典的栈应用。从左到右扫描后缀表达式，遇到操作数则压入一个**操作数栈**，遇到操作符则从栈中弹出两个操作数进行运算，并将结果压回栈中。表达式扫描完毕后，栈中唯一剩下的数就是结果。
	    *   **例题:** 求后缀表达式 $6\;5\;2\;3\;+\;8\;*\;+\;3\;+\;*$ 的值。[[后缀表达式求值]] 
	- [[表达式树]] 	
	- [[递归实现表达式求值]] 



![[2012-exam-paper-ocr.pdf#page=1&rect=73,500,532,548|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827143212.png]]
A [[前驱后继，前中后序]]
- [[遍历序列的基本性质]]
1. 步骤 1: 确定整棵树的根结点
	1. 整棵树的根结点是 `a`
2. 步骤 2: 确定根结点的直接子结点
	*   在确定根是 `a` 之后，我们来看剩下的结点 `{e, b, d, c}`，这些都是 `a` 的子孙结点。
	*   在前序遍历 `a, e, b, d, c` 中，紧跟在根结点 `a` 后面的 `e`，是 `a` 的**第一个**被访问的子树的根。这意味着 `e` 必然是 `a` 的一个**直接孩子**（要么是左孩子，要么是唯一的孩子，要么是只有右孩子情况下的右孩子）。
	*   在后序遍历 `b, c, d, e, a` 中，紧挨在根结点 `a` 前面的 `e`，是 `a` 的**最后一个**被访问的子树的根。这也意味着 `e` 必然是 `a` 的一个**直接孩子**
	综合以上两点，我们可以**百分之百确定 `e` 是根结点 `a` 的一个孩子结点**
3. 步骤 3: 判断是否存在其他直接子结点
	`b` 或 `c` 是否也可能是 `a` 的直接孩子？ 
- 如果在前序遍历中结点 $X$ 出现在结点 $Y$ 之前（`...X...Y...`），而在后序遍历中结点 $X$ 出现在结点 $Y$ 之后（`...Y...X...`），那么 $X$ 一定是 $Y$ 的祖先 
	- e 和 b 的关系
	    *   前序: `...e, b...` ($e$ 在 $b$ 之前)
	    *   后序: `...b, ...e...` ($e$ 在 $b$ 之后)
	    *   根据推论，**`e` 是 `b` 的祖先**。既然 `e` 是 `b` 的祖先，`b` 就不可能是 `a` 的直接孩子（否则 `b` 和 `e` 是兄弟关系，而不是祖先-后代关系）。
	-  **e 和 d 的关系:**
	    *   前序: `...e, ...d...` ($e$ 在 $d$ 之前)
	    *   后序: `...d, ...e...` ($e$ 在 $d$ 之后)
	    *   根据推论，**`e` 是 `d` 的祖先**。
	-   **e 和 c 的关系:**
	    *   前序: `...e, ...c` ($e$ 在 $c$ 之前)
	    *   后序: `...c, ...e...` ($e$ 在 $c$ 之后)
	    *   根据推论，**`e` 是 `c` 的祖先**。
通过以上分析，我们得出结论：结点 `{b, d, c}` 都是结点 `e` 的后代，它们都属于以 `e` 为根的子树。因此，它们不可能是根结点 `a` 的直接孩子。

根结点 `a` 的唯一直接孩子结点是 `e`。所以选择 **A**



**形态一 (如图c):** `a` 只有左孩子 `e`，`e` 有左孩子 `b` 和右孩子 `d`，`d` 有左孩子 `c`。

```
      a
     /
    e
   / \
  b   d
     /
    c
```
*   **前序遍历:** a -> e -> b -> d -> c (符合)
*   **后序遍历:** b -> c -> d -> e -> a (符合)

**形态二 (如图d):** `a` 只有左孩子 `e`，`e` 有左孩子 `b` 和右孩子 `d`，`d` 有右孩子 `c`。

```
      a
     /
    e
   / \
  b   d
       \
        c
```
*   **前序遍历:** a -> e -> b -> d -> c (符合)
*   **后序遍历:** b -> c -> d -> e -> a (符合)

- 衍生
	- 层序遍历
		- 结合层序遍历进行考察，例如，给出层序遍历和中序遍历，要求重建二叉树或求出其前/后序遍历。
	- #组合计数
		- 询问 $n$ 个 #不同结点可以构成多少种不同的二叉树形态 。答案是 #卡特兰数   
			- $C_n = \frac{1}{n+1}\binom{2n}{n} = \frac{(2n)!}{(n+1)!n!}$  [[组合]] 

![[2012-exam-paper-ocr.pdf#page=1&rect=73,454,531,501|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827144652.png]]
B
- [[平衡因子]] #叶子节点  #叶节点 [[平衡二叉树]] 
1. 所有非叶结点的平衡因子均为1
	1. 树中的每一个内部结点（非叶结点），其左子树的高度都比右子树的高度恰好多1
		1. 这种情况恰好是平衡二叉树为了维持“平衡”这个性质所能达到的“最不平衡”的状态。因此，这种结构的树是在给定高度下，拥有**最少结点**的平衡二叉树
2. 目标是构造一棵高度为 $h$ 且结点数最少的AVL树，我们将其结点数记为 $C_h$ 
	1. 我们可以得到一个递推关系：
		一棵高度为 $h$ 的最少结点AVL树 = (一个根结点) + (一棵高度为 $h-1$ 的最少结点AVL树) + (一棵高度为 $h-2$ 的最少结点AVL树)
3. 用公式表示就是：
	$C_h = C_{h-1} + C_{h-2} + 1$
4. 我们需要确定初始条件（Base Case）：
	*   **高度为1 (h=1)**: 树只有一个根结点。所以 $C_1=1$。
	*   **高度为2 (h=2)**: 树有一个根结点和一个子结点（左或右）。所以 $C_2=2$。
	    *   我们用递推公式验证一下：$C_2 = C_1 + C_0 + 1$。这里需要定义 $C_0$（高度为0的树，即空树）的结点数为0。那么 $C_2 = 1 + 0 + 1 = 2$，符合。
	1. 根据这个递推公式计算高度为6时的结点数 $C_6$：
		*   $C_1 = 1$
		*   $C_2 = 2$
		*   $C_3 = C_2 + C_1 + 1 = 2 + 1 + 1 = 4$
		*   $C_4 = C_3 + C_2 + 1 = 4 + 2 + 1 = 7$
		*   $C_5 = C_4 + C_3 + 1 = 7 + 4 + 1 = 12$
		*   $C_6 = C_5 + C_4 + 1 = 12 + 7 + 1 = 20$
- 衍生
	 - [[平衡二叉树]]  
	- [[平衡二叉树的旋转]]
	- 反向问题
		- 给定 $N$ 个结点的AVL树，其最大可能的高度是多少？
			- 我们需要找到一个高度 $h$，使得最少结点数 $C_h$ 刚好小于或等于 $N$。即解不等式 $C_h \le N$。这通常涉及对数估算，高度 $h$ 的数量级为 $O(\log N)$
	- [[平衡二叉树与普通二叉树比较与红黑树比较]] 

![[2012-exam-paper-ocr.pdf#page=1&rect=76,416,522,456|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827144706.png]]
C
- [[邻接矩阵，邻接表 ，稀疏图，稠密图]]   
- [[广度优先搜索（BFS）和深度优先搜索（DFS）]]
	-  顶点相关的操作
		*   在整个 BFS 过程中，每个顶点最多被访问一次。
	    *   当一个顶点首次被发现时，它会被标记为“已访问”并**入队 (enqueue)** 一次。
	    *   之后，它会从队列中**出队 (dequeue)** 一次。
	    *   假设入队和出队操作的时间复杂度都是 $O(1)$，那么处理所有 $n$ 个顶点的这部分操作总时间复杂度就是 $O(n)$。这包括了初始化 `visited` 数组的时间。
	- 边相关的操作 
		- BFS 的核心步骤是：当一个顶点 `u` 从队列中出队时，算法需要遍历所有从 `u` 出发的边，以找到所有与 `u` 相邻且尚未被访问的顶点
		*   在**邻接表**表示法中，找到顶点 `u` 的所有邻接点，意味着需要遍历 `u` 的邻接链表。
	    *   在整个算法的生命周期中，每个顶点的邻接链表都会被完整地遍历**一次**（且仅一次），即在该顶点出队时。
	    *   对于一个有向图，所有顶点的邻接链表的长度之和等于图的总边数 $e$。因为每条边 $(u, v)$ 都只在顶点 `u` 的邻接链表中出现一次。
	    *   因此，遍历所有邻接链表的总时间开销与边的数量成正比，即 $O(e)$。
	*   **总时间复杂度：**
	    *   算法的总时间由上述两部分组成：处理所有顶点的时间和处理所有边的时间。
	    *   总时间复杂度 = (顶点操作总时间) + (边操作总时间) = $O(n) + O(e)$。
	    *   因此，最终的时间复杂度为 $O(n+e)$。
	1.  $O(n)$ 来自于对每个顶点的入队、出队等基本操作，$O(e)$ 来自于对每条边的遍历。两者共同构成了算法的整体时间复杂度 
- 衍生
1. 不同存储结构下的复杂度对比
	1. 邻接矩阵：如果图用 #邻接矩阵 存储，情况就不同了。邻接矩阵是一个 $n \times n$ 的二维数组
		1. 在 BFS 中，当一个顶点 `u` 出队时，为了找到它的所有邻接点，你必须**扫描矩阵的第 `u` 行的全部 $n$ 个元素
		2. 由于每个顶点都会出队一次，所以这个扫描操作会执行 $n$ 次
		3. 因此，使用邻接矩阵进行 BFS 的时间复杂度是 $O(n^2)$
		*   **考点对比：**
	        *   **邻接表：** $O(n+e)$，适用于**稀疏图** (边的数量 $e$ 远小于 $n^2$)。
	        *   **邻接矩阵：** $O(n^2)$，适用于**稠密图** (边的数量 $e$ 接近 $n^2$)。
	2. 深度优先遍历 (DFS) 的时间复杂度
		1.   DFS 的遍历逻辑与 BFS 不同（使用栈或递归），但其访问模式是相似的：每个顶点被访问一次，每条边被探索一次。
		- 因此，DFS 的时间复杂度与 BFS 完全相同：
	        *   使用**邻接表**存储时，DFS 的时间复杂度是 $O(n+e)$。
	        *   使用**邻接矩阵**存储时，DFS 的时间复杂度是 $O(n^2)$。
	3. [[握手定理（有无向图）]] 
		1. 对于无向图，分析基本一致。在邻接表中，一条边 $(u, v)$ 会被存储两次：一次在 `u` 的邻接链表中，一次在 `v` 的邻接链表中
		2. 在遍历时，每条边实际上会被访问两次。总的访问次数是 $2e$
		3.  根据大O表示法，常数因子可以忽略，所以无向图的 BFS/DFS 时间复杂度仍然是 $O(n+e)$ 
	4. #空间复杂度分析 
		1. BFS 的空间复杂度
			1. 主要开销来自队列和 `visited` 数组。`visited` 数组大小为 $n$。在最坏情况下（例如，一个顶点连接到所有其他顶点），队列中可能需要存储近 $n-1$ 个顶点。因此，空间复杂度为 $O(n)$
		2. DFS 的空间复杂度 
			1. 主要开销来自递归调用栈（或手动实现的栈）和 `visited` 数组。在最坏情况下（例如，一条链状的图），递归深度可能达到 $n$。因此，空间复杂度也为 $O(n)$
	5. #非连通图的遍历 
		1. 如果图不是连通的，为了遍历所有顶点，需要一个循环来检查所有顶点，如果某个顶点尚未被访问，就从它开始进行一次新的 BFS 或 DFS 
		2.  这个外层循环确保了即使图有多个连通分量，所有顶点最终都会被访问到。$O(n)$ 的部分正体现了对所有顶点的检查，而 $O(e)$ 体现了对所有边的探索。因此，$O(n+e)$ 这个复杂度对于非连通图的完整遍历同样适用




![[2012-exam-paper-ocr.pdf#page=1&rect=74,367,526,416|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827144745.png]]
C
- 核心条件是，一个有向图用邻接矩阵存储，并且矩阵中主对角线以下的元素均为零
1. [[拓扑排序]]  #邻接矩阵的含义 拓扑序列是否存在？
	1. 设邻接矩阵为$A$，顶点集合为$\{v_1, v_2, \dots, v_n\}$。矩阵元素$A[i][j] = 1$表示存在一条从顶点$v_i$到顶点$v_j$的有向边，而$A[i][j] = 0$表示不存在 
	2. 条件转换 
		1. 主对角线以下的元素均为零，用数学语言描述就是：对于所有的$i > j$，都有$A[i][j] = 0$。这意味着图中不存在从编号大的顶点指向编号小的顶点的边。也就是说，任何一条边$(v_i, v_j)$都必须满足$i < j$ 
		2. 判断是否存在环
			1. 一个有向图存在拓扑序列的**充要条件**是该图是一个**有向无环图 (DAG)**。我们来判断这个图是否有环
			假设图中存在一个环：$v_{i_1} \to v_{i_2} \to \dots \to v_{i_k} \to v_{i_1}$。根据我们从邻接矩阵得出的结论，边的存在要求起点编号小于终点编号，因此我们必然有：
		    $i_1 < i_2 < \dots < i_k$
		    但是，为了形成环，必须有一条从$v_{i_k}$回到$v_{i_1}$的边，这就要求$i_k < i_1$。这与$i_1 < i_k$（因为$k>1$）相矛盾。
		    因此，图中不可能存在环。
		3.  **结论**：既然该图一定是有向无环图（DAG），那么它**一定存在**拓扑序列。这排除了选项 D
2. 拓扑序列是否唯一？
	1. 唯一性条件 [[拓扑排序]]
		1. 一个有向图的拓扑序列是唯一的，当且仅当在拓扑排序的每一步，队列中（或可选的入度为0的顶点集合中）都只有一个顶点。这等价于说，该有向无环图存在唯一的 #哈密顿路径 （即一条经过所有顶点的路径）
	2. 举出反例
		1. 我们只需要找到一个满足题目条件（邻接矩阵为上三角矩阵）但拓扑序列不唯一的例子，就可以证明唯一性不成立
		2. 考虑解析中给出的例子，一个3个顶点的图，其邻接矩阵为：
		    $A = \begin{pmatrix} 0 & 1 & 1 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{pmatrix}$
		    这个矩阵满足主对角线以下元素全为0的条件。
		    对应的图结构是：
		    *   存在边 $v_1 \to v_2$
		    *   存在边 $v_1 \to v_3$
		3. 进行拓扑排序
		4.  开始时，顶点$v_1$的入度为0，而$v_2$和$v_3$的入度都为1。所以第一个顶点只能是$v_1$。
		    1.  将$v_1$从图中移除，并移除其出边（$v_1 \to v_2$ 和 $v_1 \to v_3$）。此时，顶点$v_2$和$v_3$的入度都变为0。
		    2.  现在我们有两个入度为0的顶点可以选择：$v_2$和$v_3$。
		        *   如果选择$v_2$，下一个顶点就是$v_2$，最后是$v_3$。得到拓扑序列：$(v_1, v_2, v_3)$。
		        *   如果选择$v_3$，下一个顶点就是$v_3$，最后是$v_2$。得到拓扑序列：$(v_1, v_3, v_2)$。
		*   **结论**：由于存在多个拓扑序列，所以拓扑序列**不一定唯一**。这排除了选项 A（且唯一）和 B（且不唯一，这个说法太绝对，因为也可能存在唯一的情况，例如一个简单的链$v_1 \to v_2 \to v_3$）
	* 综合以上两点，结论是拓扑序列**存在，但可能不唯一**。故选 C
		- [[邻接矩阵，邻接表 ，稀疏图，稠密图]]
[[拓扑排序的应用与算法]]
- 衍生
	-  反向问题
		- 如果一个有向图存在拓扑序列，那么是否可以通过重新编号顶点，使其邻接矩阵变为一个上三角矩阵？
			- 答案是肯定的
				- 拓扑序列本身就提供了一种合法的编号方式。如果我们将拓扑序列中的顶点依次编号为$v_1, v_2, \dots, v_n$，那么对于任何边$(u, v)$，$u$在序列中都先于$v$，所以$u$的新编号一定小于$v$的新编号。这样构造出的邻接矩阵一定是 #上三角矩阵
	- 手写Kahn算法或基于DFS的拓扑排序算法，并分析其时间复杂度（对于邻接矩阵和邻接表，复杂度不同）。
	    *   对于$V$个顶点和$E$条边，Kahn算法和DFS算法的时间复杂度都是$O(V+E)$（使用邻接表）或$O(V^2)$（使用邻接矩阵）。
	- #环路检测 
		- 如何利用拓扑排序的思想来检测一个有向图是否有环？
		    *   使用Kahn算法，如果排序结束后，加入拓扑序列的顶点数量小于图中总顶点数，则说明图中存在环。
		    *   使用DFS，如果在遍历过程中遇到一个正在访问（状态为visiting）的节点，则说明遇到了一个“返祖边”，即存在环。
	- #关键路径 [[AOE网]]
		- 在实际计算每个节点（事件）的“最早开始时间”和“最晚开始时间”时，我们使用动态规划的思想。比如，要计算“烤肉”的最早开始时间，你需要先知道它所有前置任务（“腌肉完成”和“烤炉预热完成”）的最早完成时间，然后取其中最晚的那个。这是一个自底向上、利用子问题解来求解当前问题的过程，是典型的动态规划。
	- [[邻接矩阵的性质]] 



![[2012-exam-paper-ocr.pdf#page=1&rect=74,279,516,370|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827144754.png]]
C
- [[Dijkstra 算法]]
	-   一种经典的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。其核心思想是**贪心算法**
- 逐步求解过程
	- 就是去哪简单 就是  在前面 fde 
	1. 初始状态 (第0遍)
		*   集合 $S = \{a\}$
		*   距离数组 `dist`:
		    *   $dist[a] = 0$
		    *   $dist[b] = 2$ (路径 a -> b)
		    *   $dist[c] = 5$ (路径 a -> c)
		    *   $dist[d] = \infty$
		    *   $dist[e] = \infty$
		    *   $dist[f] = \infty$
	2. **第1遍:** 
		1.  **选择顶点**: 在未加入 $S$ 的顶点 {b, c, d, e, f} 中，`b` 的 `dist` 值最小 ($dist[b]=2$)
		2. **加入集合**: 将 `b` 加入 $S$。现在 $S = \{a, b\}$。**第一个目标顶点是 b**，与题干相符
		3. #松弛操作 : 更新 `b` 的邻居 `c` 和 `d` 的 `dist` 值。  
		    *   对于 `c`: 原路径 a->c 长度为 5。新路径 a->b->c 长度为 $dist[b] + w(b, c) = 2 + 1 = 3$。因为 $3 < 5$，所以更新 $dist[c] = 3$。
		    *   对于 `d`: 原距离为 $\infty$。新路径 a->b->d 长度为 $dist[b] + w(b, d) = 2 + 3 = 5$。更新 $dist[d] = 5$
		4. **当前状态**: $S = \{a, b\}$, `dist` = {a:0, b:2, c:3, d:5, e:$\infty$, f:$\infty$}  
	3. **第2遍:**
		1.  **选择顶点**: 在未加入 $S$ 的顶点 {c, d, e, f} 中，`c` 的 `dist` 值最小 ($dist[c]=3$)。
		2.  **加入集合**: 将 `c` 加入 $S$。现在 $S = \{a, b, c\}$。**第二个目标顶点是 c**，与题干相符。
		3.  **松弛操作**: 更新 `c` 的邻居 `d` 和 `e` 的 `dist` 值。
		    *   对于 `d`: 原路径 a->b->d 长度为 5。新路径 a->b->c->d 长度为 $dist[c] + w(c, d) = 3 + 3 = 6$。因为 $6 > 5$，所以**不更新** $dist[d]$。
		    *   对于 `e`: 原距离为 $\infty$。新路径 a->b->c->e 长度为 $dist[c] + w(c, e) = 3 + 4 = 7$。更新 $dist[e] = 7$。
		*   **当前状态**: $S = \{a, b, c\}$, `dist` = {a:0, b:2, c:3, d:5, e:7, f:$\infty$}
	4. **第3遍:**  
		1.  **选择顶点**: 在未加入 $S$ 的顶点 {d, e, f} 中，`d` 的 `dist` 值最小 ($dist[d]=5$)。
		2.  **加入集合**: 将 `d` 加入 $S$。现在 $S = \{a, b, c, d\}$。**第三个目标顶点是 d**。
		3.  **松弛操作**: 更新 `d` 的邻居 `e` 和 `f` 的 `dist` 值。
		    *   对于 `e`: 原路径 a->b->c->e 长度为 7。新路径 a->b->d->e 长度为 $dist[d] + w(d, e) = 5 + 1 = 6$。因为 $6 < 7$，所以更新 $dist[e] = 6$。
		    *   对于 `f`: 原距离为 $\infty$。新路径 a->b->d->f 长度为 $dist[d] + w(d, f) = 5 + 4 = 9$。更新 $dist[f] = 9$。
		*   **当前状态**: $S = \{a, b, c, d\}$, `dist` = {a:0, b:2, c:3, d:5, e:6, f:9}
	5. **第4遍:**
		1.  **选择顶点**: 在未加入 $S$ 的顶点 {e, f} 中，`e` 的 `dist` 值最小 ($dist[e]=6$)。
		2.  **加入集合**: 将 `e` 加入 $S$。现在 $S = \{a, b, c, d, e\}$。**第四个目标顶点是 e**。
		3.  **松弛操作**: 更新 `e` 的邻居 `f` 的 `dist` 值。
		    *   对于 `f`: 原路径 a->b->d->f 长度为 9。新路径 a->b->d->e->f 长度为 $dist[e] + w(e, f) = 6 + 1 = 7$。因为 $7 < 9$，所以更新 $dist[f] = 7$。
		*   **当前状态**: $S = \{a, b, c, d, e\}$, `dist` = {a:0, b:2, c:3, d:5, e:6, f:7}
	6. **第5遍:**
		1.  **选择顶点**: 在未加入 $S$ 的顶点 {f} 中，只有 `f`。
		2.  **加入集合**: 将 `f` 加入 $S$。现在 $S = \{a, b, c, d, e, f\}$。**第五个目标顶点是 f**。
**结论:**
根据我们对图中信息的严格推导，继 `b` 和 `c` 之后，加入集合 $S$ 的顶点顺序是 **d, e, f**。

![[2012-exam-paper-ocr.pdf#page=1&rect=70,187,469,281|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827144802.png]]
A
#最小生成树 [[树的种类]]  [[最小生成树MST]] 
- 考察的是关于 #最小生成树的基本性质 以及两种经典生成算法—— #普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法的特点 
1.  I. 最小生成树的代价唯一
	1. 对于一个给定的连通加权无向图，其最小生成树的**代价（所有边的权值之和）是唯一的
	2. 证明思路（反证法）
		假设存在两个不同的最小生成树 $T_1$ 和 $T_2$，它们的代价不同，且 $cost(T_1) < cost(T_2)$。
	    1.  由于 $T_1$ 和 $T_2$ 是不同的树，必然存在一条边 $e$ 在 $T_1$ 中但不在 $T_2$ 中。
	    2.  将边 $e$ 加入到 $T_2$ 中，会形成一个环（cycle）。
	    3.  在这个环中，必然存在另一条边 $e'$，它在 $T_2$ 中但不在 $T_1$ 中。
		4. 根据最小生成树的**环路性质（Cycle Property）**，环中权值最大的边一定不属于任何最小生成树。或者从另一个角度，根据**切割性质（Cut Property）**，我们可以证明 $weight(e) \ge weight(e')$。如果 $weight(e) > weight(e')$，那么用 $e'$ 替换 $e$ 可以得到一个代价更小的生成树，这与 $T_1$ 是最小生成树矛盾。如果 $weight(e) = weight(e')$，我们可以通过不断替换边，将 $T_2$ 变换成 $T_1$ 而总代价不变
	- 通过一系列严谨的推导，可以证明所有最小生成树的代价必然是相等的 
2. II. 所有权值最小的边一定会出现在所有的最小生成树中
	1. 如果图中权值最小的边只有一条，那么它确实会出现在所有最小生成树中（根据切割性质）。但是，如果存在多条权值最小的边，情况就不同了
3.  III. 使用普里姆(Prim)算法从不同顶点开始得到的最小生成树一定相同 
	1. 这与第一点中“树的结构不一定唯一”有关。如果图的最小生成树不唯一，那么从不同的顶点出发，Prim算法可能会因为在选择权值相同的边时顺序不同，而最终生成不同的最小生成树 
4. IV.  使用普里姆算法和克鲁斯卡尔算法得到的最小生成树总不相同  
	1. "总不相同" 这个说法太绝对了 
- 衍生
	- #最小生成树MST的唯一性  
		- 一个充分条件是：图中所有边的权值都互不相同
			- 一个充要条件是：对于图的任意一个割（Cut），连接割两边的权值最小的边是唯一的
	- 横跨该割的所有边中权值最小的那条边，一定属于某一个（或所有）最小生成树。这是两个算法正确性的基础
[[生成树]] 



![[2012-exam-paper-ocr.pdf#page=1&rect=70,65,523,193|2012-exam-paper-ocr, p.1]]
[[Pasted image 20250827144811.png]]
D
[[B树（B-树）]] #B树的删除操作   
1. 判断下溢 （叶子节点） 
	1.    **b) 删除后下溢**：如果删除后结点发生下溢，则需要再平衡，此时又有两种子情况：
        *   **兄弟够借（旋转）**：如本题所示，如果相邻兄弟结点有多余的关键字，通过父结点进行旋转，从兄弟借一个关键字过来。
        *   **兄弟不够借（合并）**：如果相邻兄弟结点也都只有最少的关键字，则将下溢结点、父结点中的一个分隔关键字、以及一个兄弟结点合并。这个合并操作可能会导致父结点下溢，问题会向上传播，最坏情况下可能导致树的高度减1。
	*    根据B-树的定义，对于一个阶为`m`的B-树，除了根结点外，任何一个结点至少有 $ceil(m/2) - 1$ 个关键字。
    *   本题是3阶B-树，所以 $m=3$。每个非根结点至少需要有 $ceil(3/2) - 1 = 2 - 1 = 1$ 个关键字。
    *   删除`78`后，该结点有0个关键字，小于最少要求的1个，因此发生了**下溢**，需要进行再平衡操作。
2. 选择再平衡策略 
	  当一个结点发生下溢时，有两种策略：
	*   **策略一：向兄弟结点借（Borrowing/Rotation）**：如果其相邻的左兄弟或右兄弟结点中的关键字数量大于最小值（即有多余的关键字），则可以从兄弟结点“借”一个关键字。
	*   **策略二：与兄弟结点合并（Merging）**：如果相邻的兄弟结点都只有最少数量的关键字，无法出借，则需要将下溢结点、父结点中的一个关键字以及其中一个兄弟结点合并成一个新结点。
	我们观察下溢结点 `[]` 的情况。它没有右兄弟，但有一个左兄弟结点 `[60, 62]`。
    *   左兄弟结点 `[60, 62]` 包含2个关键字。对于3阶B-树，结点的最大关键字数是 $m-1=2$，最小是1。因为 $2 > 1$，所以左兄弟是“富余”的，可以执行“借位”操作。
3. 执行“兄弟够借”操作（旋转）
	1. 下溢结点 `[]` 需要从其左兄弟 `[60, 62]` 借一个关键字
	2. 这个过程需要通过它们的共同父结点 `[55, 65]` 来完成。分隔这两个兄弟结点的父关键字是 `65`
		1. 操作规则如下（向左兄弟借）：
        a. 将左兄弟结点中**最大**的关键字（`62`）移动到父结点中，替换掉原来的分隔关键字（`65`）。
        b. 将父结点中原来的分隔关键字（`65`）移动到下溢的结点中
	3.   **变化过程**：
        *   **父结点**：`[55, 65]` 变为 `[55, 62]`。
        *   **左兄弟结点**：`[60, 62]` 变为 `[60]`。
        *   **原下溢结点**：`[]` 变为 `[65]`。
	4.  **得出结论**
	    *   经过上述旋转操作后，B-树恢复了平衡。
	    *   此时，最右侧的叶子结点中的关键字是 `65`。
	    *   因此，正确答案是 **D. 65**。
- 衍生
	- #B树与B➕树的对比 [[B树和B+树的区别]]
	- 不同阶数B-树的操作
		- 如果本题是**4阶B-树** ($m=4$)，情况会如何？
	        *   最小关键字数：$ceil(4/2) - 1 = 1$。
	        *   最大关键字数：$4-1=3$。
	        *   删除78后，结点为空，依然下溢。左兄弟 `[60, 62]` 有2个关键字，大于最小的1个，所以仍然可以借。操作过程完全相同。
		*   如果本题是**5阶B-树** ($m=5$)，情况又会如何？
			*   最小关键字数：$ceil(5/2) - 1 = 3 - 1 = 2$。
			*   左兄弟 `[60, 62]` 只有2个关键字，等于最小值，是“兄弟不够借”的情况。此时就需要执行**合并**操作了。


![[2012-exam-paper-ocr.pdf#page=2&rect=74,737,527,820|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144822.png]]
A [[排序算法]]
- II. 希尔排序 
	-  希尔排序是插入排序的改进版。它通过一个增量序列gap，将待排序序列划分为若干个子序列，对每个子序列进行插入排序。然后逐渐减小gap，重复这个过程，直到gap=1（此时相当于对整个序列进行一次插入排序）
	-  **结论：** **不符合要求**。不能保证每一趟都确定一个元素的最终位置
[[快速排序的优化]]




![[2012-exam-paper-ocr.pdf#page=2&rect=73,690,519,742|2012-exam-paper-ocr, p.2]]

[[Pasted image 20250827144831.png]]
D  [[直接插入排序和折半插入排序]]    
	C. 使用辅助空间的数量
		两种算法都属于**原地排序 (in-place sorting)**。在排序过程中，它们都只需要一个临时变量来暂存当前待插入的元素。这个空间需求是恒定的，与待排序序列的规模$n$无关。因此，它们的空间复杂度都是$O(1)$。**所以，使用的辅助空间数量是相同的
	


![[2012-exam-paper-ocr.pdf#page=2&rect=74,643,524,694|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144842.png]]
D
小学生都会做
- 反向求解
	- **问题**：已知某程序 80% 的时间用于 CPU 计算。我们希望通过优化 CPU，使整个程序的性能提升 3 倍。那么 CPU 的性能需要提升多少倍？
		- **解答**：这里已知 $S_{overall}=3$，$f=0.8$，求 $k$。
	    *   $3 = \frac{1}{(1-0.8) + \frac{0.8}{k}}$
	    *   $3 = \frac{1}{0.2 + \frac{0.8}{k}}$
	    *   $0.2 + \frac{0.8}{k} = \frac{1}{3}$
	    *   $\frac{0.8}{k} = \frac{1}{3} - 0.2 = \frac{1}{3} - \frac{1}{5} = \frac{2}{15}$
	    *   $k = 0.8 \times \frac{15}{2} = 6$。CPU 性能需要提升到原来的 6 倍

![[2012-exam-paper-ocr.pdf#page=2&rect=78,561,535,646|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144851.png]]
B
[[数据类型转换]] 
1. 直接转换法 
	1. 不断地用 `65530` 除以 16，取余数，直到商为 0。
	    *   $65530 \div 16 = 4095$ 余 $10$ (十六进制为 A)
	    *   $4095 \div 16 = 255$ 余 $15$ (十六进制为 F)
	    *   $255 \div 16 = 15$ 余 $15$ (十六进制为 F)
	    *   $15 \div 16 = 0$ 余 $15$ (十六进制为 F)
	    将余数从下往上读，得到 `FFFAH`。所以，`x` 在内存中的 16 位表示为 `FFFAH`
2. 巧算法 (利用最大值)
	16 位无符号整数的最大值是 $2^{16}-1 = 65535$。
	    其十六进制表示为 `FFFFH`。
	    我们可以计算 `65530` 与最大值的差：
	    $65535 - 65530 = 5$
	    所以，`x` 的值可以用最大值的十六进制减去 5 来得到：
	    $FFFFH - 5H = FFFAH$
	    这同样得出 `x` 的机器数是 `FFFAH`
3. 步骤 2: 分析变量 `y` 的赋值过程
	*   **代码**: `unsigned int y = x;`
	*   **类型**: `y` 是 `unsigned int`，一个无符号整型。
	*   **位宽**: 题目规定 `int` 为 32 位。
	*   **赋值操作**: 这个操作将一个 16 位的 `unsigned short` 类型的值赋给一个 32 位的 `unsigned int` 类型的变量。这涉及到**整型提升 (Integer Promotion)**。
4. 步骤 3: 理解类型转换规则 
	1. 一个较小位宽的整数类型转换为一个较大位宽的整数类型时，规则如下： 
		*   **无符号数 (Unsigned) -> 无符号数 (Unsigned)**: 进行**零扩展 (Zero Extension)**。即在高位补充 0，直到达到目标位宽，其数值保持不变。
		*   **有符号数 (Signed) -> 有符号数 (Signed)**: 进行**符号扩展 (Sign Extension)**。即在高位补充原数字的符号位。如果原数是正数（符号位为0），则补充0；如果原数是负数（符号位为1），则补充1。这样可以保持原数的数值不变。
	2. `x` 是 `unsigned short`，`y` 是 `unsigned int`，两者都是无符号数。因此，在转换时遵循**零扩展**规则 
		*   `x` 的 16 位表示是 `FFFAH`。
		*   `y` 是 32 位，比 `x` 多了 $32 - 16 = 16$ 位。
		*   进行零扩展，意味着在这 16 个高位上全部填充 0。
		*   所以，`y` 的 32 位表示为 `0000FFFAH`。
	#### 变体 1: 有符号数到有符号数的转换

假设题目改为：
```c
short x = -6;
int y = x;
```
1.  **分析 `x`**: `x` 是一个 16 位的**有符号**短整型，值为 `-6`。我们需要求 `-6` 的 16 位补码表示。
	1. 求 `+6` 的 16 位二进制原码：`0000 0000 0000 0110`
	2. 按位取反得到反码：`1111 1111 1111 1001`
    *   最后，加 1 得到补码：`1111 1111 1111 1010`
    * 这个二进制数转换为十六进制就是 `FFFAH`
	*   `y` 的 32 位表示为 `1111 1111 1111 1111 1111 1111 1111 1010`。
    *   转换为十六进制就是 `FFFF FFFAH`。
    *   这种情况下，答案就会是 **D**。



![[2012-exam-paper-ocr.pdf#page=2&rect=78,531,538,569|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144903.png]]
D
[[IEEE754单精度浮点数格式]]
对于**规格化**的浮点数（即阶码 E 不全为 0 也不全为 1 的情况），其真实值 V 的计算公式为：
$V = (-1)^S \times (1.M)_2 \times 2^{E-127}$

这里的 $(1.M)_2$ 是一个关键点，它被称为**隐藏位策略**。因为规格化的二进制数的第一位总是 1，所以这个 1 不需要存储，从而节省出一位，使得 23 位的尾数能提供 24 位的精度。
2. 第二步：分析如何构成最大正整数
	1. 要表示一个**最大**的**正** **整数**，我们需要：
		1.  **符号位 S**：必须为 0，因为是正数。
		2.  **阶码 E**：必须尽可能大。8 位阶码 E 的取值范围是 0 到 255。其中 $E=0$ 和 $E=255$ 是为特殊值（如 0、无穷大、NaN）保留的。对于规格化数，E 的最大值是 254。
		    *   当 $E=254$ 时，实际指数 $e = E - 127 = 254 - 127 = 127$。
		3.  **尾数 M**：必须尽可能大。23 位的尾数 M 全为 1 时最大。
		    *   $M = (111...1)_2$ (共 23 个 1)。
3. 第三步：进行计算 
	*   $S=0$
	*   $E=254 \implies e=127$
	*   $M = (111...1)_2$
	1. 包含隐藏位的有效数字（Significand）为 $(1.M)_2 = (1.111...1)_2$，小数点后有 23 个 1 
		1. 这个二进制小数 $(1.111...1)_2$ 的值可以这样计算：
			它等于 $2 - 2^{-23}$。
		*   为什么？因为 $(1.111...1)_2$ 再加上 $2^{-23}$ (即小数点后第 23 位加 1) 就会进位成 $(10.000...0)_2$，也就是十进制的 2。所以 $(1.111...1)_2 = 2 - 2^{-23}$
			现在，我们将这个值代回总公式：
			$V = (-1)^0 \times (2 - 2^{-23}) \times 2^{127}$
			$V = 1 \times (2 - 2^{-23}) \times 2^{127}$
			$V = 2 \times 2^{127} - 2^{-23} \times 2^{127}$
			$V = 2^{128} - 2^{104}$
	- 这个计算出的值 $2^{128} - 2^{104}$ 是一个整数，因为它的小数部分已经被指数 $2^{127}$ 移位消除了（因为 $127 > 23$ 
		）。同时，它是由最大的正号、最大的阶码和最大的尾数组合而成的，因此它就是 `float` 能表示的最大正数（恰好也是最大正整数）
	所以，正确答案是 **D**。

[[邻接矩阵，邻接表 ，稀疏图，稠密图]]



![[2012-exam-paper-ocr.pdf#page=2&rect=75,383,541,534|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144913.png]]
D

-  第一步：分析核心知识点
	1. 计算机系统中的三个核心概念：**数据类型大小**、**字节序（Endianness）** 和 **内存对齐（Data Alignment）** 
	2. 数据类型大小 
		*   题目明确规定：`int` 类型为 32 位，即 $32 \div 8 = 4$ 字节。
	    *   `short` 类型为 16 位，即 $16 \div 8 = 2$ 字节。
	    *   `char` 类型在 C 语言标准中通常为 1 字节。
	3.  字节序 #小端  [[字节序]] 
	4. [[内存对齐]]  
- 第二步：逐步推导 `record` 结构体的内存布局
	1. 成员 `int a`
		*   **大小**: 4 字节。
	    *   **对齐要求**: 地址必须是 4 的倍数。
	    *   **起始地址**: 结构体的起始地址 `0xC008`。因为 $0xC008$ 是 4 的倍数（看末尾的 `8` 即可），所以 `a` 就从 `0xC008` 开始存放。
	    *   **占用空间**: `0xC008`, `0xC009`, `0xC00A`, `0xC00B`。
	    *   **下一个可用地址**: `0xC00C`。
	2.  **成员 `char b`**:
	    *   **大小**: 1 字节。
	    *   **对齐要求**: 地址必须是 1 的倍数（任何地址都可以）。
	    *   **起始地址**: 从上一步的下一个可用地址 `0xC00C` 开始。`0xC00C` 是 1 的倍数，满足要求。
	    *   **占用空间**: `0xC00C`。
	    *   **下一个可用地址**: `0xC00D`。
	3.  **成员 `short c`**:
	    *   **大小**: 2 字节。
	    *   **对齐要求**: 地址必须是 2 的倍数（即偶数地址）。
	    *   **起始地址**: 当前可用地址是 `0xC00D`。这是一个奇数地址，不满足 2 字节对齐要求。
	    *   **填充**: 编译器必须在 `b` 和 `c` 之间填充 1 个字节，使 `c` 的起始地址移动到下一个满足对齐要求的地址。因此，地址 `0xC00D` 被填充（留空）。
	    *   **最终起始地址**: `0xC00E`。`0xC00E` 是偶数，满足要求。
	    *   **占用空间**: `0xC00E`, `0xC00F`。
	    *   **下一个可用地址**: `0xC010`。
	4. **结构体总大小**:
	    *   `record` 结构体中最大的成员是 `int a`，大小为 4 字节。因此，结构体的总大小必须是 4 的倍数。
	    *   当前已占用的空间是从 `0xC008` 到 `0xC00F`，总共是 $0xC00F - 0xC008 + 1 = 8$ 字节。
	    *   因为 8 是 4 的倍数，所以结构体末尾不需要再进行填充。
	    *   `sizeof(record)` 的结果是 8 字节。
内存布局总结如下表

| 地址       | 内容                 | 备注                   |
| :------- | :----------------- | :------------------- |
| `0xC008` | `record.a` 的第 1 字节 |                      |
| `0xC009` | `record.a` 的第 2 字节 |                      |
| `0xC00A` | `record.a` 的第 3 字节 |                      |
| `0xC00B` | `record.a` 的第 4 字节 |                      |
| `0xC00C` | `record.b`         |                      |
| `0xC00D` | **填充字节 (Padding)** | 为了 `record.c` 的对齐    |
| `0xC00E` | `record.c` 的第 1 字节 | **`record.c` 的起始地址** |
| `0xC00F` | `record.c` 的第 2 字节 |                      |
3. 第三步：回答问题 
	1. 地址 `0xC008` 中的内容是什么？
	    *   该地址存放的是 `record.a` 的第一个字节。
	    *   `record.a` 的值被设置为 273。[[进制转化]]
	    *   将十进制 273 转换为十六进制：$273 = 1 \times 256 + 17 = 1 \times 16^2 + 1 \times 16^1 + 1 \times 16^0 = 0x0111$。
	    *   作为一个 32 位（4 字节）的 `int`，它的完整表示是 `0x00000111`。
	    *   系统采用 **小端模式**，所以低位字节 `0x11` 存放在低地址。
	    *   `record.a` 的存储方式如下：
	        *   地址 `0xC008`: `0x11` (LSB)
	        *   地址 `0xC009`: `0x01`
	        *   地址 `0xC00A`: `0x00`
	        *   地址 `0xC00B`: `0x00` (MSB)
	    *   因此，地址 `0xC008` 中的内容是 **`0x11`**。
	2. `record.c` 的地址是什么？ 
		1.    根据我们第二步的内存布局分析，`record.c` 的起始地址是 **`0xC00E`** 
#### 结论

综合以上两点，地址 `0xC008` 中的内容是 `0x11`，`record.c` 的地址是 `0xC00E`。

这与选项 **D. 0x11、0xC00E** 完全匹配。
- 衍生
	- 改变字节序
	 题目可能会改为 **大端模式**。在这种情况下，`record.a = 0x00000111` 的存储方式会变为：
	        *   地址 `0xC008`: `0x00` (MSB)
	        *   地址 `0xC009`: `0x00`
	        *   地址 `0xC00A`: `0x01`
	        *   地址 `0xC00B`: `0x11` (LSB)[[字节序]]  
	- 改变结构体成员顺序 
	   *   成员的顺序会极大地影响内存布局和总大小。例如，如果结构体定义为：
        ```c
        struct {
            char b;
            int a;
            short c;
        } record;
        ```
    *   内存布局会变成：
        *   `b` (1 字节) 在 `0xC008`。
        *   `a` (4 字节) 需要 4 字节对齐，所以 `0xC009`, `0xC00A`, `0xC00B` 会被填充，`a` 从 `0xC00C` 开始。
        *   `c` (2 字节) 从 `0xC010` 开始。
        *   结构体总大小需要是 4 的倍数，当前已用 $1+3+4+2=10$ 字节，所以需要填充 2 字节，总大小变为 12 字节。
- 使用 `#pragma pack(n)`  
	-  这个预处理指令可以改变默认的对齐规则。 #pragmapack（n） 会让成员按照自身大小和 $n$ 中较小的值进行对齐 
	-   例如，使用 `#pragma pack(1)`，所有成员都按 1 字节对齐，即不存在任何填充。结构体大小就是所有成员大小之和：$4+1+2=7$ 字节 
	- 如果使用 `#pragma pack(2)`，`int a` 的对齐值会从 4 变为 2 
- #嵌套结构体或联合体   
	- 题目可能包含嵌套的 `struct` 或 `union`，需要综合考虑内外层的对齐规则。一个 `struct` 作为另一个 `struct` 的成员时，其对齐要求是其内部最大成员的对齐要求 
- #指针和类型转换  
	- 可能会让你通过一个指向结构体的指针，来读取或修改某个特定地址的值，并分析其结果。例如，`*(short*)((char*)&record + 6)` 的值是多少？（答案是 `record.c` 的值，因为 `(char*)&record + 6` 的地址是 `0xC008 + 6 = 0xC00E`）





![[2012-exam-paper-ocr.pdf#page=2&rect=76,306,347,387|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144921.png]]
A
1. 选项 B: 存储元由 MOS 管组成，是一种半导体存储器。 
	1. #闪存的核心存储单元  
		1. 闪存的核心存储单元是浮栅金属氧化物半导体场效应晶体管（Floating-gate MOSFET），它是一种特殊的MOS管。因为其物理基础是半导体技术，所以它属于半导体存储器。 
	2. 选项 C: 掉电后信息不丢失，是一种非易失性存储器
		1. 非易失性（Non-Volatile）存储器的定义就是断电后数据不会丢失。闪存正是利用浮栅中的电荷来长久保存数据，因此是典型的非易失性存储器。我们常用的U盘、SSD固态硬盘断电后数据都还在，就是这个原理。[[存储器扩展]]  [[闪存及其工作原理]] [[存储器随机访问]]
- [[存储器层次结构]]
	-   **考点：** 越往上层，速度越快，每比特成本越高，容量越小。越往下层，则相反
- [[RAM和ROM的区别]]  [[SRAM与DRAM对比]] [[机械硬盘HDD与固态硬盘SSD的对比]] 
[[Flash Memory 闪存的分类]]

![[2012-exam-paper-ocr.pdf#page=2&rect=76,246,528,309|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144930.png]]
C    这题出问题了 题采用的是一种在某些教材（如蒋本珊版）中描述的方式  
- #组相联 [[地址映射方式]]  #组相联映射  
1. 先将 Cache 分成若干个**组 (Set)**。主存中的一个块首先被**直接映射**到一个特定的组，但它可以在这个组内的**任意一行**存放 
	1. 如果一个组内有 $k$ 个行，就称为 k-路组相联
		1. 计算公式 
			1. $Cache组号 = (主存块号) \pmod{Cache总组数}$
		2. 地址结构:
		    | 标记 (Tag) | 组索引 (Set Index) | 块内偏移 (Offset) |
2. 计算 Cache 组数
	1. Cache 的总行数除以路数 (associativity, $N$)。
	    公式为：$S = \frac{\text{Cache总行数}}{N}$
		1. $S = \frac{4}{2} = 2$。所以 Cache 被分为 2 组，我们称之为第 0 组和第 1 组
3. 确定主存块到 Cache 组的映射关系
	1. 一个主存块 $j$ 应该映射到哪个 Cache 组 $i$ 是由一个固定的函数决定的。
	2. 最常见/标准的映射函数
		1. $Cache组号 = (主存块号) \pmod{Cache总组数}$
        *   如果按此标准，主存块 0, 2, 4, 6, 8... (偶数) 映射到第 0 组。
        *   主存块 1, 3, 5, 7, 9... (奇数) 映射到第 1 组。
	*   **关键发现**：
	    我们观察访问序列：0, 4, 8, 2, 0, 6, 8, 6, 4, 8。这些地址全都是**偶数**。
	    根据映射公式，任何一个偶数地址 `addr`，计算出的组号都是 $addr \pmod{2} = 0$。
	    这意味着，**在整个访问过程中，所有的操作都只针对 Cache 的 组 0 (Set 0) 进行，组 1 (Set 1) 始终为空。**
	1. 所以，问题简化为：在一个容量为 2 行、采用 LRU 替换策略的 Cache 组（即组 0）中，依次访问序列 0, 4, 8, 2, 0, 6, 8, 6, 4, 8，会发生多少次命中 
4. 来一步步跟踪组 0 (Set 0) 的状态变化。组 0 有两个位置（行）。我们会用 `{A, B}` 来表示组 0 中的内容，并用 `(旧 -> 新)` 标记 LRU 状态

[[地址映射方式]]   [[LRU替换算法]] 

| 步骤 | 访问地址 | Cache 组号 | 组 0 内容 | LRU 状态 (旧->新) | 是否命中？ | 命中次数累计 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 初始 | - | - | `{空, 空}` | - | - | 0 |
| 1 | **0** | $0 \pmod{2} = 0$ | `{0, 空}` | (0) | **Miss (不命中)** | 0 |
| 2 | **4** | $4 \pmod{2} = 0$ | `{0, 4}` | (0, 4) | **Miss (不命中)** | 0 |
| 3 | **8** | $8 \pmod{2} = 0$ | `{8, 4}` (替换0) | (4, 8) | **Miss (不命中)** | 0 |
| 4 | **2** | $2 \pmod{2} = 0$ | `{8, 2}` (替换4) | (8, 2) | **Miss (不命中)** | 0 |
| 5 | **0** | $0 \pmod{2} = 0$ | `{0, 2}` (替换8) | (2, 0) | **Miss (不命中)** | 0 |
| 6 | **6** | $6 \pmod{2} = 0$ | `{0, 6}` (替换2) | (0, 6) | **Miss (不命中)** | 0 |
| 7 | **8** | $8 \pmod{2} = 0$ | `{8, 6}` (替换0) | (6, 8) | **Miss (不命中)** | 0 |
| 8 | **6** | $6 \pmod{2} = 0$ | `{8, 6}` | (8, 6) | **Hit (命中)** | **1** |
| 9 | **4** | $4 \pmod{2} = 0$ | `{4, 6}` (替换8) | (6, 4) | **Miss (不命中)** | 1 |
| 10 | **8** | $8 \pmod{2} = 0$ | `{4, 8}` (替换6) | (4, 8) | **Miss (不命中)** | 1 |
最终，整个访问序列中只有 1 次命中。 选 A  
- 衍生
	-  #地址结构 
		-     在更复杂的问题中，需要对主存地址进行分解。一个主存地址通常被分为三部分：**标记 (Tag)**、**组索引 (Index)** 和 **块内偏移 (Offset)**。
	    *   **块内偏移**：用于在块内寻址，其位数由块大小决定。位数 = $log_2(块大小)$。
	    *   **组索引**：用于确定映射到哪个 Cache 组，其位数由 Cache 组数决定。位数 = $log_2(Cache组数)$。
	    *   **标记**：用于区分映射到同一个组的不同主存块，其位数 = $总地址位数 - 索引位数 - 偏移位数$。
	    本题因为块大小为1个字，所以块内偏移为0位。
	- [[写策略]]  



![[2012-exam-paper-ocr.pdf#page=2&rect=78,197,526,249|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144939.png]]
C
[[微程序控制思想]] [[字段直接编码法]]  [[微指令操作控制字段的编码方式]] 
- 关键信息
	-  **控制方式**：微程序控制。
	*   **编码方法**：操作控制字段采用**字段直接编码法**（Field-Direct Encoding）。
	*   **微命令总数**：33个。
	*   **分组情况**：这33个微命令被分成了5个**互斥类**（Mutually Exclusive Groups）。
	*   **各组大小**：5个互斥类分别包含 7、3、12、5 和 6 个微命令。
	*   **问题**：操作控制字段至少需要多少位？
- 题目中已经明确告诉我们，微命令被分成了5个互斥类，这正好对应了字段直接编码法中的5个字段。
1. 计算每个字段所需的位数
	1. 对于每一个互斥类（字段），我们需要用二进制位来表示该字段中的所有可能性。这些可能性包括：
		*   执行该字段中的任意一个微命令。
		*   **不执行该字段中的任何微命令**（即“空操作”或“无操作”状态） 
	2. 对于一个包含$k$个微命令的字段，总共需要表示$k+1$种状态（$k$个微命令 + 1个无操作） 
	3. 假设需要$n$个二进制位来表示这$k+1$种状态，那么必须满足以下关系：
		$2^n \ge k+1$
2. 为每个字段计算满足这个条件的最小整数$n$
	1. **第1个字段**：包含7个微命令
	    *   需要表示的状态数 = $7+1=8$。
	    *   求解$2^{n_1} \ge 8$。
	    *   $2^3=8$，所以最小的$n_1=3$位。
	2. **第2个字段**：包含3个微命令。
	    *   需要表示的状态数 = $3+1=4$。
	    *   求解$2^{n_2} \ge 4$。
	    *   $2^2=4$，所以最小的$n_2=2$位。
	3. **第3个字段**：包含12个微命令。
	    *   需要表示的状态数 = $12+1=13$。
	    *   求解$2^{n_3} \ge 13$。
	    *   $2^3=8$（不够），$2^4=16$（足够），所以最小的$n_3=4$位。
	4. **第4个字段**：包含5个微命令。
	    *   需要表示的状态数 = $5+1=6$。
	    *   求解$2^{n_4} \ge 6$。
	    *   $2^2=4$（不够），$2^3=8$（足够），所以最小的$n_4=3$位。
	5. **第5个字段**：包含6个微命令。
	    *   需要表示的状态数 = $6+1=7$。
	    *   求解$2^{n_5} \ge 7$。
	    *   $2^2=4$（不够），$2^3=8$（足够），所以最小的$n_5=3$位。
3. 计算总位数
	1. 操作控制字段的总位数是所有字段位数之和。
		总位数 = $n_1 + n_2 + n_3 + n_4 + n_5 = 3 + 2 + 4 + 3 + 3 = 15$位。
	正确答案是 **C. 15位**
- 衍生 
	- 不同编码方式的计算
	    *   同一道题，可能会问如果采用“ #直接编码法”，需要多少位？（答案是33位）
	    *   如果问采用“ #完全编码法”，需要多少位？（$2^n \ge 33$，则$n=6$位，对应选项B。但题目明确了互斥关系，所以此方法不适用，除非题目改变条件）
	- #微命令的分组  
		-  题目可能不直接给出分组，而是描述一系列微命令的功能（如`PC->MAR`, `MDR->IR`等），让你自己判断哪些是互斥的（如不能同时从两个不同来源向同一个目标传送数据），然后进行分组并计算位数。
	- 微指令的后继地址形成方式  #顺序控制字段  
	- [[控制存储器容量的计算]] 
		- 考题可能会要求计算控制存储器的总容量。容量 = 微指令字长 × 微指令条数。这就需要你先计算出微指令的完整字长（包括操作控制字段、顺序控制字段、测试字段等），再乘以给定的微程序总长度。 
 


![[2012-exam-paper-ocr.pdf#page=2&rect=78,135,539,202|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144949.png]]
C #主存写  
- #线路复用   
	- 地址/数据线复用。这意味着同一组物理线路既用于传输地址，也用于传输数据，但不能同时进行。通常是先传地址，再传数据 
- [[突发传输]] 
	- 突发传输模式下，只需要发送一个起始地址，然后就可以连续传输多个数据块，而不需要为每个数据块都发送一次地址
- 一次“主存写”总线事务，传输总数据量为 $D_{total} = 128\text{位}$。 
1. 计算时钟周期
	1. $T = 1/f$
	2. $T = 1 / (100 \text{MHz}) = 1 / (100 \times 10^6 \text{Hz}) = 10 \times 10^{-9} \text{s} = 10\text{ns}$
	3. 每个时钟周期是 $10\text{ns}$。总线上的每一次基本操作（如传输一次地址或一次数据）都需要 $10\text{ns}$ 
2. 分析突发传输 
	1. 一次完整的总线事务在突发模式下通常分为两个阶段
		1. 地址阶段
			1. 主设备（如CPU）首先要通过总线发送要写入内存的起始地址。由于地址/数据线是复用的，这个过程会独占总线。根据题意，这需要一个时钟周期
		2. 数据阶段
			1. 在地址发送并被从设备（如内存）接收后，主设备开始连续地将数据块发送到总线上。因为是突发模式，所以只需要在开头发送一次地址，后续的数据块会连续传输，每个数据块占用一个时钟周期
3. 计算各阶段所需时间
	*   **地址阶段时间 ($t_{addr}$):**
	    发送一次起始地址需要1个时钟周期。
	    $t_{addr} = 1 \times T = 1 \times 10\text{ns} = 10\text{ns}$
	-  **数据阶段时间 ($t_{data}$):**
	    首先，需要计算传输128位数据需要多少个时钟周期。总线的宽度是32位，意味着每个时钟周期可以传输32位数据。
	    需要传输的周期数 ($N_{data}$) = 总数据量 / 总线宽度
	    $N_{data} = D_{total} / W = 128\text{位} / 32\text{位} = 4$
	    所以，传输128位数据需要4个时钟周期。
	    数据阶段的总时间为：
	    $t_{data} = N_{data} \times T = 4 \times 10\text{ns} = 40\text{ns}$
4. 计算总时间
	总线事务所需的总时间是地址阶段和数据阶段时间的总和。
	
	$t_{total} = t_{addr} + t_{data} = 10\text{ns} + 40\text{ns} = 50\text{ns}$
	
	因此，完成这次“主存写”总线事务至少需要 **50ns**。答案为 **C**
- 衍生 
	- [[非突发传输模式的时间计算]] 
	- [[总线带宽计算]] 
		- #峰值带宽 
			-  指总线在理想情况下（即每个周期都在传输数据，没有地址或其他开销）的最大传输速率
			- 公式: `带宽 = 总线宽度 × 时钟频率`
				- 计算: $32\text{位} \times 100\text{MHz} = 3200 \text{Mbits/s}$因为 $32\text{位} = 4\text{字节}$ (Bytes)。 
				-    带宽 = $4\text{B} \times 100 \times 10^6\text{/s} = 400 \times 10^6 \text{B/s} = 400\text{MB/s}$。
		- #有效带宽 指在某次具体事务中，实际的数据传输速率，它考虑了地址周期等开销。
		    *   公式: `有效带宽 = 实际传输的数据总量 / 完成传输的总时间`
		    *   在本题中:
		        *   总数据量 = $128\text{位} = 16\text{字节}$
		        *   总时间 = $50\text{ns}$
		        *   有效带宽 = $16\text{B} / 50\text{ns} = 16\text{B} / (50 \times 10^{-9}\text{s}) = 320 \times 10^6 \text{B/s} = 320\text{MB/s}$。
		    *   可以看到，由于地址周期的开销，有效带宽 ($320\text{MB/s}$) 低于峰值带宽 ($400\text{MB/s}$)
	- 如果是“ #主存读”
		- 题目是“主存写”，CPU是主动方，可以直接将数据送上总线
		- 如果是“主存读”，CPU发送地址后，需要等待存储器准备好数据。这个等待时间被称为**存储器访问时间 (Memory Access Time)**。如果这个时间超过一个时钟周期， #总线控制器 会插入一个或多个**等待周期 (Wait States)**，在这些周期里总线不进行任何有效操作
		- 例如，如果读操作需要2个等待周期，那么总时间会变为：
		    $t_{total} = t_{addr} + t_{wait} + t_{data} = 10\text{ns} + (2 \times 10\text{ns}) + 40\text{ns} = 70\text{ns}$。
	


![[2012-exam-paper-ocr.pdf#page=2&rect=75,69,501,137|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827144956.png]]
D
- [[串行和并行总线的区别]]   
- [[USB拓扑结构与设备数量限制]] 
- B. 可通过级联方式连接多台外设
- 衍生 
	- #USB工作模式  
		-  考察 #USB的主从结构 。通信总是由主机 (Host) 发起，设备 (Device) 只能响应主机的请求。这与某些点对点通信协议不同。可能会引申出 USB On-The-Go (OTG) 技术，它允许某些设备（如手机）在没有电脑的情况下，既能作为设备，也能充当有限功能的主机（例如连接 U 盘）。


![[2012-exam-paper-ocr.pdf#page=2&rect=71,25,505,75|2012-exam-paper-ocr, p.2]]
[[Pasted image 20250827145009.png]]
D
- [[不同IO方式的性能计算与比较]]   [[1. IO 结构与控制]]  [[系统总线结构（数据线，地址线，控制总线）]]  [[总线的分类]] [[IO总线]] 
- 分析各个选项中的信息类型
	-   I. #I/O接口中的命令字 ：这是CPU向I/O接口（或设备控制器）发送的指令，告诉它要执行什么操作（例如，启动设备、读数据、写数据等）。这个“命令”本身是一种信息，需要从CPU传输到I/O接口。它通过**数据线**传输。CPU首先通过地址线选中目标I/O接口的控制寄存器，然后通过数据线将命令字写入该寄存器。
	- II. I/O 接口中的 #状态字
		- 这是I/O接口向CPU报告其当前状态的信息，例如设备是否准备好、数据是否传输完毕、是否发生错误等。CPU需要读取这些状态来决定下一步操作。这个“状态”信息需要从I/O接口传输到CPU。它通过**数据线**传输。CPU通过地址线选中目标I/O接口的状态寄存器，然后通过数据线读取状态字
	- III. #中断类型号
		- 当I/O设备完成任务并需要CPU处理时，它会发出中断请求。CPU响应中断后，需要知道是哪个设备发出的中断以及需要执行哪个中断服务程序。I/O接口会将一个唯一的标识码——中断类型号——发送给CPU。这个号码也是一种信息，通过**数据线**从I/O接口传输到CPU
 - [[IO接口包含的寄存器]] 
- 衍生 
	- [[地址空间划分（IO编址方式）]]  [[编址方式]] CPU如何访问I/O端口的地址？主要有两种方式 
		- #统一编址   #独立编址 
	-  [[IO控制方式]]
	- [[IO层次结构与地址转换]]  [[总线带宽计算]] 

![[2012-exam-paper-ocr.pdf#page=3&rect=80,766,500,820|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145019.png]]
B
- 核心是理解计算机在响应中断时，由**硬件自动完成**的一系列操作，这些操作被统称为“ #中断隐指令 ”（Interrupt Implicit Instruction）或“ #中断周期 ”（Interrupt Cycle）。我们需要区分哪些操作是硬件自动完成的，哪些是需要由软件（即 #中断服务程序 ）来完成的 
1. [[关中断指令]]    [[中断隐指令]]   [[单级中断处理流程]] 
- 衍生
	- [[中断向量与中断向量表]] 中断向量是什么？中断向量表的作用和结构是什么？如何根据中断向量计算中断服务程序入口地址？
	- [[中断嵌套]]   [[中断屏蔽的规则（处理中断嵌套）]] 
	- #程序状态字PSW  #标志寄存器（程序状态字PSW）  [[标志寄存器（程序状态字PSW）]]
		- PSW的作用是什么？为什么在中断时必须保存它？
	- [[中断与子程序调用的区别]] 
		- `CALL`指令和中断在实现跳转、保存返回地址、触发时机等方面有什么不同？



![[2012-exam-paper-ocr.pdf#page=3&rect=77,736,488,769|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145034.png]]
C
#系统调用   [[系统调用的过程]] 系统调用是应用程序请求操作系统提供服务的接口，例如读写文件、创建进程等。 
	系统调用的 **“调用”** 这个动作，即触发事件本身，是发生在用户态的。因此，A是可能在用户态发生的。
	
#外部中断  外部中断是由CPU外部设备（如键盘、鼠标、网卡、时钟）发出的信号，通知CPU有事件需要处理 
	外部中断的 **“发生”**（即中断信号被CPU捕获），完全可能发生在CPU处于用户态的时刻。因此，B是可能在用户态发生的
#缺页 缺页是一种异常（Exception）。当程序试图访问一个在虚拟地址空间中存在，但当前尚未加载到物理内存中的页面时，就会发生缺页。 
#进程切换 进程切换是指操作系统暂停当前正在运行的进程，保存其上下文（寄存器状态、程序计数器等），然后加载另一个进程的上下文，使其开始运行  [[进程的状态与切换]]

- 衍生
	-  [[中断、异常和系统调用的区别与联系]] 
		-  **来源**：中断来自外部硬件（异步），异常来自CPU执行指令时内部产生（同步），系统调用是应用程序主动请求（同步）。
	    *   **共同点**：它们都是从用户态进入核心态的主要方式。
	-  [[特权指令类型]]  哪些指令是特权指令？为什么需要特权指令？在用户态执行特权指令会发生什么？
	- [[上下文切换]] 进程上下文切换具体包含哪些操作？为什么它的开销很大
	- [[进程切换与线程切换的区别]] 线程切换和进程切换有什么不同？哪个开销更小？
	- [[系统调用的过程]] 用户程序如何向内核传递参数？内核如何找到对应的服务程序？


![[2012-exam-paper-ocr.pdf#page=3&rect=75,683,534,733|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145044.png]]
B
- [[中断与子程序调用的区别]]
	- 分析共同点
		- 题目指出，“中断处理”和“子程序调用”都需要“压栈以保护现场”。这里的“现场”指的是程序在被暂停（无论是被中断还是去调用子程序）前的瞬间状态
		- 为了能够正确地返回并继续执行，最核心的信息是**返回地址**
			- 也就是下一条应该执行的指令的地址。这个地址存放在 #程序计数器PC  （Program Counter, $PC$）中。因此，无论是中断还是子程序调用，都必须保存$PC$的内容。这排除了选项A，因为$PC$是两者都需要保存的，而不是它们的区别分析差异点
	- 分析差异点
		- 现在我们需要找出中断处理**一定**会保存，而子程序调用**不一定**需要保存的东西
		- #中断处理 让原程序“毫无察觉”地继续运行。为了做到“毫无察觉”，不仅要记住返回地址（$PC$），还必须保存中断发生瞬间的CPU所有状态，比如进位标志、零标志、中断是否开启等。这些状态信息被集中存放在 #程序状态字寄存器 
		- #子程序调用 由程序代码预先安排好的跳转， 除非有特殊需要（由编译器或程序员根据调用约定来决定），否则没有硬性规定必须保存调用前的CPU状态。其最根本的需求只是记录返回点（$PC$）
	C. #通用数据寄存器  D. #通用地址寄存器 
		[[调用约定（通用寄存器）]]  
- [[单级中断处理流程]] 
- [[程序计数器PC]] 也称为指令指针（Instruction Pointer, IP），它存放的是即将要执行的下一条指令的内存地址。CPU根据$PC$的值去内存中取指令。 
- [[标志寄存器（程序状态字PSW）]]
	- 一个集合了各种状态信息和控制信息的寄存器。其内容因处理器架构而异, 通常包含
		- #状态标志 和 #控制位 
-  衍生
	-  [[中断、异常和系统调用的区别与联系]]
		- CPU外部的异步事件（外部中断） #中断
			- 键盘输入、磁盘读写完成
		- CPU内部的同步事件（内部中断） #异常 
			- 如除零错误、缺页、非法指令、系统调用（陷入 trap）
	- [[中断向量与中断向量表]]  中断服务程序入口地址的表  
	- #堆栈帧  [[堆栈帧]] 
		- 用于存放返回地址、传递的参数、局部变量以及需要保存的寄存器 

![[2012-exam-paper-ocr.pdf#page=3&rect=72,633,495,691|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145054.png]]
B
[[虚拟内存]]  [[虚拟存储器]] 
[[虚拟内存与虚拟存储器的区别]] 
2. #虚拟存储器 基于程序的 #局部性原理 (Principle of Locality) ，即程序在一段时间内访问的地址通常集中在一个很小的范围内。因此，无需将整个程序加载到内存，只需加载当前需要的部分。
	*   **实现基础**：必须建立在 #非连续分配 的内存管理方式之上，
* 分析 #虚拟存储容量的限制因素
	* 虚拟存储器为用户提供了一个巨大的逻辑地址空间，这个空间的大小理论上和物理内存（RAM）大小、外存（硬盘）大小没有直接关系
		* 它由**CPU的寻址能力**决定 。CPU的地址总线有多少位，就决定了它能访问多少个不同的内存地址。例如，一个32位的CPU，它的地址总线是32条，能够产生的地址数量为 $2^{32}$ 个。 如果 #按字节编址 ，那么它的虚拟地址空间最大就是 $2^{32}$ 字节，即 4GB。同理，一个64位的CPU，其理论虚拟地址空间大小为 $2^{64}$ 字节，这是一个极其庞大的数字。

![[2012-exam-paper-ocr.pdf#page=3&rect=68,547,547,636|2012-exam-paper-ocr, p.3]][[Pasted image 20250827145104.png]]
A
- 衍生
	- [[IO层次结构与地址转换]] 
	 - [[IO控制方式]] 
	 - [[缓冲技术]]  
		 - 单缓冲  双缓冲 循环缓冲/缓冲池 
	 - [[磁盘调度算法]]
		  先来先服务 最短寻道时间优先  扫描算法 循环扫描算法 LOOK C-LOOK 
	 - 假设当前磁头在53号磁道，请求队列为 `98, 183, 37, 122, 14, 124, 65, 67`，采用 #最短寻道时间优先算法SSTF 
	    移动顺序为：`53 -> 65 -> 67 -> 37 -> 14 -> 98 -> 122 -> 124 -> 183`
	    总移动道数计算：
	    $T_{move} = |65-53| + |67-65| + |37-67| + |14-37| + |98-14| + |122-98| + |124-122| + |183-124|$
	    $T_{move} = 12 + 2 + 30 + 23 + 84 + 24 + 2 + 59 = 236$


![[2012-exam-paper-ocr.pdf#page=3&rect=73,394,543,550|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145114.png]]
D
[[银行家算法核心思想与数据结构]]
**关键数据结构：**
1.  **Available (可用资源向量)**：一个向量，表示当前系统中每种资源的可用实例数量。
2.  **Max (最大需求矩阵)**：一个 $n \times m$ 的矩阵（n个进程，m类资源），表示每个进程对每种资源的最大需求量。
3.  **Allocation (已分配资源矩阵)**：一个 $n \times m$ 的矩阵，表示当前已分配给每个进程的每种资源的数量。
4.  **Need (需求矩阵)**：一个 $n \times m$ 的矩阵，表示每个进程**还需**要的每种资源的数量。
它们之间存在一个重要的关系：
$Need[i, j] = Max[i, j] - Allocation[i, j]$
- 第一步：整理已知信息并计算 `Available` 和 `Need` 
1. 系统总资源
    *   $R_1 = 18$
    *   $R_2 = 6$
    *   $R_3 = 22$
    *   所以，总资源向量 $Total = (18, 6, 22)$。
2. 已分配资源 从题目表格中直接读取 
    *   $P_0$: (3, 2, 3)
    *   $P_1$: (4, 0, 3)
    *   $P_2$: (4, 0, 5)
    *   $P_3$: (2, 0, 4)
    *   $P_4$: (3, 1, 4)
3. 计算已分配资源总量 
    *   $R_1$ 已分配: $3+4+4+2+3 = 16$
    *   $R_2$ 已分配: $2+0+0+0+1 = 3$
    *   $R_3$ 已分配: $3+3+5+4+4 = 19$
    *   已分配总量向量为 $(16, 3, 19)$。
4. 计算当前可用资源 
    *   $Available = Total - \text{Sum of Allocation}$
    *   $Available = (18, 6, 22) - (16, 3, 19) = (2, 3, 3)$
    *   这与解析中给出的 `Available` 表格一致。
5. 计算各进程的需求
    *   $Need = Max - Allocation$
    *   $P_0$: $(5, 5, 10) - (3, 2, 3) = (2, 3, 7)$
    *   $P_1$: $(5, 3, 6) - (4, 0, 3) = (1, 3, 3)$
    *   $P_2$: $(4, 0, 11) - (4, 0, 5) = (0, 0, 6)$
    *   $P_3$: $(4, 2, 5) - (2, 0, 4) = (2, 2, 1)$
    *   $P_4$: $(4, 2, 4) - (3, 1, 4) = (1, 1, 0)$
    *   这与解析中给出的 `Need` 表格完全一致。
- 第二步：应用 #安全性算法 ，寻找安全序列  [[安全性算法]]
1. 寻找一个进程 $P_i$，使其满足条件 $Need_i \le Available$  
	1. 如果找到，就假定该进程执行完毕并释放其**所有已分配**的资源，然后更新 `Available` 向量：$Available = Available + Allocation_i$ 
	2. 重复此过程，直到所有进程都执行完毕。 
2. 检查题目给出的四个选项 
	1. **初始状态**: $Available = (2, 3, 3)$ 
	**检查可作为序列第一个执行的进程**：
	*   $P_0$: $Need_0=(2, 3, 7)$。因为 $7 > 3$，所以 $Need_0 \not\le Available$。$P_0$ 不能第一个执行。**排除选项 A**。
	*   $P_1$: $Need_1=(1, 3, 3)$。因为 $1 \le 2, 3 \le 3, 3 \le 3$，所以 $Need_1 \le Available$。$P_1$ **可以**第一个执行。
	*   $P_2$: $Need_2=(0, 0, 6)$。因为 $6 > 3$，所以 $Need_2 \not\le Available$。$P_2$ 不能第一个执行。**排除选项 C**。
	*   $P_3$: $Need_3=(2, 2, 1)$。因为 $2 \le 2, 2 \le 3, 1 \le 3$，所以 $Need_3 \le Available$。$P_3$ **可以**第一个执行。
	*   $P_4$: $Need_4=(1, 1, 0)$。因为 $1 \le 2, 1 \le 3, 0 \le 3$，所以 $Need_4 \le Available$。$P_4$ **可以**第一个执行。
	
	现在我们只需要验证选项 B 和 D。
- **验证选项 D: <$P_3, P_1, P_2, P_4, P_0$>**
1. **执行 $P_3$**:
    *   初始 $Available = (2, 3, 3)$。
    *   $Need_3 = (2, 2, 1) \le (2, 3, 3)$，满足条件。
    *   $P_3$ 执行完毕，释放资源。
    *   新的 $Available = \text{旧 } Available + Allocation_3 = (2, 3, 3) + (2, 0, 4) = (4, 3, 7)$。
    *   已完成序列: <$P_3$> 
2.  **执行 $P_2$**:
    *   当前 $Available = (8, 3, 10)$。
    *   $Need_2 = (0, 0, 6) \le (8, 3, 10)$，满足条件。
    *   $P_2$ 执行完毕，释放资源。
    *   新的 $Available = (8, 3, 10) + Allocation_2 = (8, 3, 10) + (4, 0, 5) = (12, 3, 15)$。
    *   已完成序列: <$P_3, P_1, P_2$>
3.  **执行 $P_4$**:
    *   当前 $Available = (12, 3, 15)$。
    *   $Need_4 = (1, 1, 0) \le (12, 3, 15)$，满足条件。
    *   $P_4$ 执行完毕，释放资源。
    *   新的 $Available = (12, 3, 15) + Allocation_4 = (12, 3, 15) + (3, 1, 4) = (15, 4, 19)$。
    *   已完成序列: <$P_3, P_1, P_2, P_4$>
4. **执行 $P_0$**:
    *   当前 $Available = (15, 4, 19)$。
    *   $Need_0 = (2, 3, 7) \le (15, 4, 19)$，满足条件。
    *   $P_0$ 执行完毕，释放资源。
    *   新的 $Available = (15, 4, 19) + Allocation_0 = (15, 4, 19) + (3, 2, 3) = (18, 6, 22)$。
    *   这个最终的 `Available` 向量等于系统总资源向量，这是一个很好的验证。
    *   已完成序列: <$P_3, P_1, P_2, P_4, P_0$>
由于我们成功找到了一个能让所有进程都执行完毕的序列，所以这个序列是一个 #安全序列 ，系统处于安全状态。**因此，选项 D 是正确的。**

- 衍生 
	- #资源请求算法  [[资源请求算法]] 
	- [[死锁产生的四个条件]] 
	- [[死锁预防 vs 死锁避免vs 死锁检测与解除]]    
	- #死锁检测与解除 
		- 允许系统进入死锁状态，但系统会定期检测是否存在死锁。如果检测到，则采取措施（如剥夺资源、终止进程）来解除死锁
![[2012-exam-paper-ocr.pdf#page=3&rect=72,306,538,398|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145124.png]]
A
1. I. 若该文件的数据不在内存中，则该进程进入睡眠等待状态
	1. 正确的 
		1. [[阻塞]] 
		2. [[CPU调度]]   
			1. 进程进入阻塞态，就会放弃CPU的使用权 ， #操作系统调度器  会从 #就绪队列 中 选择另一个 处于就绪态的进程来执行 ，从而提高CPU的利用率 
		3. [[唤醒]] 
			1. #磁盘控制器 完成了数据读取，并将数据放入内存后，会向CPU发送一个中断信号，操作系统捕获这个中断，执行相应的中断服务程序，并将之前被阻塞进程的状态从 #阻塞态 改为 #就绪态 放入就绪队列 ，等待下一次被调度执行
		4. 因此，进程会因为 等待 IO操作完成而进入睡眠等待状态 
2. II. 请求 `read` 系统调用会导致 CPU 从用户态切换到核心态 
	1. 正确的
3. III. `read` 系统调用的参数应包含文件的名称  [[文件操作流程（打开，读取，写入，关闭）]] 
	1.  **文件操作流程**: 在类 UNIX 系统（如 Linux）中，对文件的操作通常遵循 `open` -> `read`/`write` -> `close` 的流程
	2.   **`open` 系统调用**: 这个调用的作用是根据 **文件路径和名称** 打开一个文件。如果成功，内核会为这个打开的文件创建一个上下文（记录了读写位置、权限等信息），并返回一个小的非负整数给用户进程，这个整数就是 #文件描述符 
	[[文件描述符、打开文件表和FCB(inode)的关系]] 


![[2012-exam-paper-ocr.pdf#page=3&rect=77,234,529,312|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145133.png]]
B
#批处理系统 
	这是一个 #多道批处理系统 ，意味着当一个作业（进程）在进行I/O操作时，CPU可以被另一个作业使用，从而实现CPU和I/O设备的并行工作。
1. [[操作系统的种类]] 
	**时间段 4: $180 \sim 220$ms**
	*   在此期间，$P_1$ 正在使用CPU，$P_2$ 正在进行I/O操作，再次实现了并行。
	*   $P_1$ 的CPU计算将持续到 $t = 180 + 20 = 200$ms。
	*   $P_2$ 的I/O操作将持续到 $t = 180 + 40 = 220$ms。
	*   **$t=200$ms:** $P_1$ 完成了所有任务，**作业$P_1$结束**。CPU变得空闲。
	*   **$t=220$ms:** $P_2$ 完成了I/O操作。它现在需要进行第二个计算任务（40ms）。
	
	**时间段 5: $220 \sim 260$ms**
	*   **$t=220$ms:** $P_2$ 需要CPU，并且CPU从200ms开始就一直空闲，所以 $P_2$ 立即获得CPU。
	*   $P_2$ 的第二个计算任务将持续到 $t = 220 + 40 = 260$ms。
	*   **$t=260$ms:** $P_2$ 完成了所有任务，**作业$P_2$结束**。
- 衍生
	- 不同的调度算法
	    如果题目改为使用其他调度算法，结果会完全不同。
	    *   **短作业优先 (SJF, Shortest Job First):** 在 $t=180$ms 时，就绪队列中有 $P_1$（需CPU 20ms）和（假设有另一个进程$P_3$需CPU 50ms），SJF会选择 $P_1$。
	    *   **优先级调度 (Priority Scheduling):** 如果为 $P_1$ 和 $P_2$ 分配了不同的优先级，调度决策会基于优先级。
	- #周转时间 作业从到达系统到完成所花费的总时间。
        *   $P_1$的周转时间: $T_{周转} = T_{完成} - T_{到达} = 200 - 0 = 200$ms
        *   $P_2$的周转时间: $T_{周转} = T_{完成} - T_{到达} = 260 - 5 = 255$ms
        *   平均周转时间: $(200 + 255) / 2 = 227.5$ms

![[2012-exam-paper-ocr.pdf#page=3&rect=78,141,543,232|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145146.png]]
C

#处理机调度  [[处理机调度的时机]] 
[[进程同步-临界区问题-皮特森算法]]
1. A. 在进程结束时能进行处理机调度 
	1. 当一个进程执行完毕（无论是正常结束还是异常终止），它会释放所占有的CPU。此时，操作系统必须从就绪队列（Ready Queue）中选择另一个进程来运行。因此，进程结束是一个必然会触发 #处理机调度 的时刻。  
2. B. 创建新进程后能进行处理机调度
	1.  **正确**。当一个新进程被创建后，它会被放入就绪队列。在 #抢占式调度 策略中，如果新创建的进程比当前正在运行的进程有更高的优先级，调度程序可能会立即剥夺当前进程的CPU，转而运行新进程。即使在非抢占式调度中，这也是一个潜在的调度点（尽管调度不一定会立即发生）。因此，创建新进程后可以进行调度
3. C. 在进程处于临界区时不能进行处理机调度 
	1. **错误** 
		1. #临界区  指的是进程中访问共享资源（如共享变量、文件、设备等）的一段代码。为了保证数据的一致性，需要确保在同一时刻只有一个进程能进入临界区，这称为 #互斥 
	2. 实现互斥的机制（如锁、信号量）是用来保护**共享资源**的，而不是为了禁止**处理机调度**
		1. 一个进程在临界区中运行时，完全可能因为时间片用完（在分时系统中）或被更高优先级的进程抢占而被中断。发生调度后，CPU会分配给其他进程。如果其他进程也想进入同一个临界区，它会被 #互斥机制 （如获取锁失败）阻塞，而不会破坏数据。CPU可以继续去执行其他与该临界区无关的就绪进程 
		2. 如果一个进程正在访问打印机（一个临界资源），而访问打印机是一个相对慢速的I/O操作。如果此时禁止调度，CPU就只能空闲等待，直到打印结束，这将导致系统性能急剧下降。正确的做法是，允许调度，让CPU去执行其他计算任务，从而提高利用率。
4. D. 在系统调用完成并返回用户态时能进行处理机调度 
	1.  **正确**。当服务完成，准备从内核态返回用户态时，是一个非常关键的调度时机。因为在内核中，进程的状态可能已经改变（例如，请求I/O的进程可能从运行态变成了阻塞态），或者I/O操作的完成可能使另一个高优先级的进程从阻塞态变为了就绪态。因此，在返回用户态之前，内核会检查是否需要进行一次调度，以确保当前最应该运行的进程获得CPU



![[2012-exam-paper-ocr.pdf#page=3&rect=79,59,355,138|2012-exam-paper-ocr, p.3]]
[[Pasted image 20250827145155.png]]
A
[[进程与线程的区别]]
1. C
    *   **系统级线程 (Kernel-Level Thread, KLT)**：线程的创建、销毁和切换都由操作系统内核（Kernel）直接管理。因此，系统级线程的切换需要在内核态完成，需要内核的支持。
    *   **用户级线程 (User-Level Thread, ULT)**：线程的管理（创建、切换等）完全由用户空间的线程库来完成，内核对此一无所知，它只看得到这个进程。用户级线程的切换只是在用户态下保存和恢复上下文，不需要陷入内核，因此**不需要内核的支持**。这种切换速度非常快
2. D. 同一进程中的各个线程拥有各自不同的地址空间 (错误)
	 **分析**：这是对线程核心优势的误解。线程之所以“轻量”，一个关键原因就是它们**共享**同一个进程的地址空间。
- 衍生
	- [[线程模型]]  
	- [[线程安全]]  指一个函数或一段代码在多线程环境中被并发调用时，能够正确地处理共享变量，不会产生不确定的结果。
	- [[协程]] 

![[2012-exam-paper-ocr.pdf#page=4&rect=74,767,448,821|2012-exam-paper-ocr, p.4]]

[[Pasted image 20250827145202.png]]
B
[[磁盘调度算法]]
1. #重排I/O请求次序  这直接减少了总的寻道时间 ($T_{seek}$)，是提升磁盘 I/O 性能最主要和最有效的手段之一
2. 分区主要是为了逻辑管理，与提升物理 I/O 性能没有直接关系。所以，B **不能**改善性能 [[磁盘分区]] 
3. #预读和滞后写   #滞后写 [[预读和滞后写]]	 这两种技术通过减少实际访问磁盘的次数和优化访问模式，极大地提升了系统的宏观 I/O 性能。
4. [[磁盘碎片整理]]  #磁盘碎片 这直接减少了读取一个文件所需的寻道次数和寻道距离，从而显著提升了 I/O 性能。 
5.  [[文件分配方式（文件物理结构） 文件分配方式的对比]]
- 衍生 
	- [[磁盘调度算法]]
		给定一个磁道请求序列和当前磁头位置，要求使用不同的调度算法（如SSTF, SCAN, C-SCAN）计算磁头的总移动距离。
		*   **示例**：假设磁道范围为0-199，当前磁头在53号磁道，请求序列为 98, 183, 37, 122, 14, 124, 65, 67。请计算SSTF算法的总寻道距离。
			*   **解**：从53开始，依次寻找最近的请求：
				*   53 -> 65 (距离12)
				*   65 -> 67 (距离2)
				*   67 -> 37 (距离30)
				*   37 -> 14 (距离23)
				*   14 -> 98 (距离84)
				*   98 -> 122 (距离24)
				*   122 -> 124 (距离2)
				*   124 -> 183 (距离59)
				*   总移动距离 = $12+2+30+23+84+24+2+59 = 236$
		- [[几种技术和常见的 RAID 级别]]
		- [[机械硬盘HDD与固态硬盘SSD的对比]]




![[2012-exam-paper-ocr.pdf#page=4&rect=74,733,446,772|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145211.png]]
B
1. [[ICMP（互联网控制报文协议）]] 
	1. 用于在 IP 主机、路由器之间传递控制消息，报告错误、交换网络状态等。例如，我们常用的 ping 命令就是利用 ICMP 的回显请求（Echo Request）和回显应答（Echo Reply）报文
	2. ICMP 在协议层次上被认为是 #网络层 （Internet Layer）协议，与 IP 协议处于同一层。但是，ICMP 报文并不能独立传输，它必须被封装在 #IP数据报 （Datagram）中才能在网络中传递
[[数据封装过程]] 
[[TCP IP参考模型(OSI与TCPIP模型的对比）]]
  - [[IP头部的协议字段]]
	  - 这是 IP 协议能够为多个上层协议提供服务的关键。IP 头部中有一个 8 位的字段，专门用来标识其数据部分承载的是哪种协议的报文。
  - #封装与解封装  提问：一个 HTTP 请求从客户端发送到服务器，数据依次经过的封装是？
	*   答案：HTTP 消息 -> TCP 段 -> IP 数据报 -> 以太网帧
* #协议字段的作用 提问：IP 协议如何区分其承载的数据是 TCP 报文还是 UDP 报文？
	*   答案：通过 IP 头部的协议字段
* [[数据单元PDU]] 在 TCP/IP 模型中，传输层的数据单元称为什么？ 
	* 段    答案：C (TCP 称为段 Segment，UDP 也可称数据报 Datagram，但段是更常见的传输层术语)






![[2012-exam-paper-ocr.pdf#page=4&rect=75,694,472,738|2012-exam-paper-ocr, p.4]][[Pasted image 20250827145224.png]] 
C
[[TCP IP参考模型(OSI与TCPIP模型的对比）]]
[[物理层接口的四个特性]] 
- 衍生
	- 1.  **概念辨析题（类似本题）**: 给出一种描述，让你判断属于哪种特性。
	    *   例：规定网线接口必须是8针的RJ45接头，这属于物理层的\_\_\_\_\_特性。 (答案：机械特性)
	    *   例：规定在某条信号线上，+5V代表逻辑"0"，-5V代表逻辑"1"，这属于\_\_\_\_\_特性。 (答案：电气特性)
	
	1.  **举例说明题**: 让你列举某个特性在现实中的具体例子。
	    *   例：请举出至少两个关于物理层机械特性的实例。 (答案：USB Type-C接口、HDMI接口的形状)
	
	2.  **综合应用题**: 描述一个通信故障场景，让你分析可能与哪种特性有关。
	    *   例：两台设备通过串口连接，但无法通信。技术人员发现其中一台设备的TxD引脚连接到了另一台的TxD引脚，而不是RxD引脚。这个问题与物理层的\_\_\_\_\_特性定义有关。 (答案：功能特性，因为引脚的功能定义被错误使用了)
	    *   例：一根网线过长，导致网络信号衰减严重，频繁丢包。这违反了物理层\_\_\_\_\_特性的规定。 (答案：电气特性，因为超过了最大传输距离限制)
	
	3.  **与数据传输速率相关的计算**: 电气特性中规定了传输速率，这可以引申出与信道容量相关的计算题，例如奈奎斯特定理和香农定理。
	    *   #奈奎斯特定理[[结合信道带宽（奈奎斯特定理）]]: 在理想的无噪声信道中，极限数据传输速率$C$与信道带宽$B$和信号电平级数$M$的关系为：
	        $C=2B\log_2M$
	        (单位：bps)
	    *   #香农定理 : 在有噪声的信道中，极限数据传输速率$C$与信道带宽$B$和信噪比$S/N$的关系为：
	        $C=B\log_2(1+S/N)$
	        (单位：bps)
	    *   **考题示例**: 若某信道带宽为3kHz，信噪比为30dB，则该信道的最大数据传输速率约为多少？ (需要先将dB转换为线性值：$30dB = 10\log_{10}(S/N) \Rightarrow S/N=1000$，然后代入香农公式计算)。


![[2012-exam-paper-ocr.pdf#page=4&rect=75,665,492,701|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145234.png]]
A  [[以太网的特性（无链接不可靠）]] 
1. [[MAC地址]] [[有链接服务与无链接服务]]   [[（不）可靠服务]]
	1. 因为以太网协议既不编号也不要求确认，所以它无法保证数据帧一定能送达，也无法保证送达的顺序，更无法保证数据帧没有损坏。因此，它提供的是 **“不可靠”** 的服务
2. #MAC地址  MAC地址是48位的全球唯一硬件地址。其地址空间大小为$2^{48}$ 
	1.  考查MAC地址的格式（通常写为6个字节的十六进制数，如 `00:1A:2B:3C:4D:5E`）。
    *   广播MAC地址 (`FF:FF:FF:FF:FF:FF`) 和组播MAC地址的特点。
3. #CSMA/CD协议  
	1.  传统以太网（共享总线型）使用的介质访问控制协议是载波侦听多路访问/碰撞检测 CSMA/CD协议 
	2. 其工作原理：先听后发、边听边发、碰撞后随机退避。 
	3. 在 #现代交换式以太网 中，由于 #交换机 实现了 #全双工通信 ，每个端口都是一个独立的碰撞域，CSMA/CD协议的作用已经大大减弱，但它仍然是网络基础知识的重要组成部分 

![[2012-exam-paper-ocr.pdf#page=4&rect=80,601,534,663|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145242.png]]
B
[[后退N帧协议GBN]]  #数据帧

[[数据链路层的信道利用率（有效数据传输速率）]] #帧序号  [[帧序号]] #计算机网络入门题目 #帧序号的比特数  
1. 第一步：确定计算参数
	*   **数据传输速率 (R):** $16 \text{ kbps} = 16 \times 10^3 \text{ bps}$
	*   **单向传播时延 (t_p):** $270 \text{ ms}$
	*   **数据帧长度 (L):** 范围是 $128 \sim 512$ 字节。
	*   **确认帧：** 长度与数据帧相等。这是一个关键信息，通常确认帧很短，但此题有特殊规定。
	1. 为了尽可能多地发送帧，从而对发送窗口大小提出最高的要求（这会决定序号比特数的下限），我们应该选择**最短的数据帧**进行计算。因为帧越短，发送时间越短，在固定的 #往返时延RTT 内能发送的帧数就越多。
	所以，我们选择 #数据帧长度  $L = 128$ 字节
2. 第二步：计算发送一帧数据的时间 ($t_t$)
	1. 发送时间是指将一帧的所有比特推到信道上所需的时间。
		$t_t = \frac{\text{帧长度(比特)}}{\text{数据传输速率(bps)}}$
	2. $t_t = \frac{1024 \text{ bit}}{16 \times 10^3 \text{ bit/s}} = 0.064 \text{ s} = 64 \text{ ms}$ 
3. 第三步：计算完整的 #往返时延RTT  [[往返时延RTT]] 
	1. $RTT = t_{t\_data} + t_p + t_{t\_ack} + t_p = t_{t\_data} + 2 \times t_p + t_{t\_ack}$
	2. 确认帧与数据帧等长，所以它们的发送时间也相等：
		$t_{t\_ack} = t_{t\_data} = 64 \text{ ms}$
		
		代入数值：
		$RTT = 64 \text{ ms} + 2 \times 270 \text{ ms} + 64 \text{ ms} = 64 + 540 + 64 = 668 \text{ ms}$
1. 第四步：计算所需的发送窗口大小 ($W_S$) 
	1. 为了实现100%的信道利用率，发送方在 $RTT$ 这段时间内必须能不停地发送。那么在这段时间内最多可以发送多少帧呢？
		$W_S = \frac{RTT}{t_t} = \frac{668 \text{ ms}}{64 \text{ ms}} \approx 10.4$
	2. 发送方需要能够缓存并发送至少10.4个帧而无需等待。这 意味着发送窗口大小 $W_S$ 必须至少为 **11**
2. 第五步：根据窗口大小计算 #序号 比特数 (k)
	1. 在GBN协议中，发送窗口大小 $W_S$ 和序号空间大小（由比特数 $k$ 决定，为 $2^k$）的关系是：
		$1 \le W_S \le 2^k - 1$
3. 为了避免新旧窗口序号重叠导致接收方无法区分。接收方窗口大小 $W_R$ 恒为1
	1. 已经计算出需要 $W_S \ge 11$。因此，我们需要找到满足下面不等式的最小整数 $k$：
		$2^k - 1 \ge 11$
		$2^k \ge 12$
	2.  当 $k=4$，$2^4 = 16$，满足 $16 \ge 12$ **结论：** 答案是 **B. 4**。 
- 衍生
	- [[不同协议的窗口大小限制]] 
	- 信道利用率的计算公式 
		- 如果本题中序号比特数固定为3位，求最大信道利用率。
	        *   $k=3$，则GBN协议下最大发送窗口 $W_{S,max} = 2^3 - 1 = 7$。
	        *   $RTT = 668 \text{ ms}$，$t_t = 64 \text{ ms}$。
	        *   最大信道利用率 $η_{max} = \frac{7 \times 64 \text{ ms}}{668 \text{ ms}} = \frac{448}{668} \approx 67\%$。
	- #ACK帧的影响 本题明确指出ACK帧与数据帧等长，这在实际中不常见。大多数题目会**忽略ACK的发送时间**（即认为 $t_{t\_ack} \approx 0$），或者采用**捎带确认**
		- **衍生问题：** 如果本题忽略ACK的发送时间，结果会是多少？
			-  $RTT = t_{t\_data} + 2 \times t_p = 64 + 2 \times 270 = 604 \text{ ms}$。
	        *   所需窗口大小 $W_S = \frac{604}{64} \approx 9.44$，即 $W_S$ 至少为10。
	        *   $2^k - 1 \ge 10 \implies 2^k \ge 11$。
	        *   $k$ 仍然需要为4。虽然计算过程有变，但此题的最终答案恰好不变
![[2012-exam-paper-ocr.pdf#page=4&rect=78,511,486,600|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145257.png]]
C

- I. 运行路由协议，设置路由表
	-  这是路由器的核心功能之一，属于路由器的 #控制平面 路由器通过运行RIP、OSPF、BGP等[[路由协议中的汇总]]，与其他路由器交换网络拓扑信息，学习如何到达各个目标网络，并根据这些信息生成和维护自己的路由表。路由表是路由器进行数据转发的依据。
- II. 监测到拥塞时，合理丢弃 IP 分组  
	- [[TCP流量控制与拥塞控制]]    [[TCP拥塞控制与路由器拥塞控制]]  
	-  这是路由器的拥塞控制功能。路由器的内存（缓冲区）是有限的。当数据包到达的速率超过其转发出去的速率时，缓冲区会逐渐被填满，这就是网络拥塞。当缓冲区满时，路由器必须丢弃新到达的数据包 #尾丢弃 
		- 一些更智能的拥塞避免机制，如随机早期检测（RED），甚至会在缓冲区完全满之前就开始有选择地丢弃数据包，以提前向发送方发出拥塞信号。因此，丢弃分组是处理拥塞的必要手段 
1. III. 对收到的 IP 分组头进行差错校验，确保传输的 IP 分组不丢失 
	1. [[IP头部校验和]]    这是正确的。
		1. IP分组头部有一个“ #首部校验和” 字段。每个路由器收到IP分组时，都会重新计算头部的校验和，以检查在传输过程中头部是否出现了错误。如果校验和不匹配，路由器会直接丢弃该分组
			1. IP首部校验和只对IP首部进行校验，不包括数据部分。其目的是检测IP首部在传输过程中是否发生错误 
	2. “确保传输的IP分组不丢失” 这是错误的。
		1. IP协议本身是一个“尽力而为”的、不可靠的协议。 数据包可能因为多种原因丢失，例如：头部校验和错误、网络拥塞（如II所述）、TTL（生存时间）耗尽等。保证数据不丢失是传输层协议（如TCP）的责任，而不是IP路由器的责任
- IV. 根据收到的 IP 分组的目的 IP 地址，将其转发到合适的输出线路上  #路由选择与分组转发   #分组转发 
	- **分析：** 这是路由器的基本和核心的功能，属于路由器的 #数据平面     **结论：** 该描述正确 
- 衍生
	 - #IP路由器功能    [[路由器的核心功能]]  #路由选择与分组转发  
	-  [[IP协议的不可靠性]]    IP协议是无连接的、尽力而为的协议 
	- [[IP分组的生命周期]]  当TTL减到0时，路由器会丢弃该分组，并向源主机发送一个ICMP“超时”报文。这也是IP分组会“丢失”的一个原因 
	- [[TCP与UDP的对比]] 
![[2012-exam-paper-ocr.pdf#page=4&rect=77,462,457,512|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145305.png]]
A 
1. #ARP协议与RARP协议  [[ARP地址解析协议]] 
    *   **A. 根据 IP 地址查询 MAC 地址**：这个描述的是从一个已知的网络层地址（IP）去寻找对应的数据链路层地址（MAC）。
    *   **B. 根据 MAC 地址查询 IP 地址**：这是选项 A 的反向操作。 由 #RARP (Reverse ARP) 或更现代的 #BOOTP/DHCP 协议实现。
    *   **C. 根据域名查询 IP 地址**：这是将人类可读的网站名（如 `www.google.com`）转换为 IP 地址的过程。功能由 #DNS (Domain Name System) 协议实现
    *   **D. 根据 IP 地址查询域名**：这是选项 C 的反向操作。功能由 #反向DNS (Reverse DNS) 实现
- 衍生 
	- #RARP 现状：RARP 已基本被更强大的 BOOTP 和 DHCP 协议所取代。 
	- #ARP缓存表    [[ARP缓存表]] 
	- #ARP欺骗 一种网络攻击手段。攻击者通过发送伪造的 ARP 回复包，将网络中某台主机（如网关）的 IP 地址映射到攻击者自己的 MAC 地址上 
	- #免费ARP 一种特殊的 ARP 请求，主机广播一个请求，请求的目标 IP 地址是它自己的 IP 地址 
	- #代理ARP 
	    *   **定义**：路由器的一个功能。当路由器收到一个它知道如何到达的目标 IP 的 ARP 请求时，即使该 IP 不在请求发出的那个网段，路由器也会用自己的 MAC 地址作为 ARP 回复，代为应答。
	    *   **作用**：可以使两个物理上隔离的网段对彼此透明，让它们感觉像在同一个局域网内，而无需修改主机的路由表。

![[2012-exam-paper-ocr.pdf#page=4&rect=77,413,525,461|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145314.png]]
D  #子网划分     [[IP子网划分]]
#计算广播地址的核心规则 ： 将IP地址中对应子网掩码为`0`的主机位（Host ID）全部置为`1`。[[特殊地址计算（网络地址，广播地址）]] 
1. 第一步：将IP地址和子网掩码转换为二进制形式
	1. 为了进行位运算，我们需要将IP地址和子网掩码从点分十进制表示法转换为32位的二进制表示法。我们重点关注非255和非0的第三个字节 
		*   **子网掩码**: `255.255.252.0`
		    *   `255` = `11111111`
		    *   `252` = `11111100`
		    *   `0` = `00000000`
		    *   二进制形式: `11111111.11111111.11111100.00000000`
		
		*   **IP地址**: `180.80.77.55`
		    *   `180` = `10110100`
		    *   `80` = `01010000`
		    *   `77` = `01001101`
		    *   `55` = `00110111`
		    *   二进制形式: `10110100.01010000.01001101.00110111`
2. 第二步：确定网络位和主机位
	子网掩码的作用就是区分一个IP地址中的网络部分和主机部分。
	*   掩码中为 `1` 的位对应的是 **网络位** (Network ID)。
	*   掩码中为 `0` 的位对应的是 **主机位** (Host ID)。
	观察子网掩码的二进制形式，我们可以看到：
	*   前 `8 + 8 + 6 = 22` 位是 `1`，所以网络位有22位。
	*   后 `2 + 8 = 10` 位是 `0`，所以主机位有10位。
3. 第三步：计算网络地址  
	1. 网络地址是该子网的标识，其主机位全为`0`。可以通过将IP地址和子网掩码进行 按位与 ( #AND运算 ) 得到。 [[位运算]] [[特殊地址计算（网络地址，广播地址）]] 
		$NetworkAddress = IPAddress \land SubnetMask$

```
  10110100.01010000.01001101.00110111   (IP地址: 180.80.77.55)
& 11111111.11111111.11111100.00000000   (子网掩码: 255.255.252.0)
-----------------------------------------
  10110100.01010000.01001100.00000000   (网络地址)
```
将结果转换回十进制：
*   `10110100` -> `180`
*   `01010000` -> `80`
*   `01001100` -> `64 + 8 + 4 = 76`
*   `00000000` -> `0`
	所以，该子网的网络地址是 `180.80.76.0`。
4. 第四步：计算 #广播地址 
	1. 广播地址是该子网的最后一个地址，其主机位全为`1`。我们可以基于网络地址，将所有主机位（后10位）设置为`1`来得到。

		*   网络地址 (二进制): `10110100.01010000.010011`**`00.00000000`**
		    *   加粗部分为10位主机位。
		*   将主机位全置为`1`: `10110100.01010000.010011`**`11.11111111`**
		
		将这个二进制地址转换回十进制：
		*   `10110100` -> `180`
		*   `01010000` -> `80`
		*   `01001111` -> `64 + 8 + 4 + 2 + 1 = 79`
		*   `11111111` -> `255`
		
		所以，该子网的广播地址是D选项  **`180.80.79.255`**。
- 衍生 
	- #判断两个IP是否在同一个子网    给定两个IP地址和同一个子网掩码，分别计算它们的网络地址。 
		-   如果计算出的两个网络地址相同，则这两个IP地址在同一个子网中；否则不在。
	    *   例如，判断 `180.80.77.55` 和 `180.80.79.100` 是否在子网 `255.255.252.0` 中。
	- [[子网划分核心概念]]
		- 给定一个大的网络块（如 `192.168.0.0/16`），要求将其划分为多个更小的子网以满足不同部门的需求（如需要5个子网，每个子网至少30台主机）。这需要计算新的子网掩码，并列出每个子网的网络地址、广播地址和可用IP范围
	- [[可用主机数计算公式]] 
	- [[可用IP地址范围]] 





![[2012-exam-paper-ocr.pdf#page=4&rect=79,287,532,418|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145323.png]]
D
[[邮件传输的完整过程]] 
#简单邮件传输协议SMTP  
- 衍生 
	- [[电子邮件系统的组成]] 






![[2012-exam-paper-ocr.pdf#page=4&rect=79,205,532,283|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145341.png]]
[[Pasted image 20250827145351.png]]
- 题的核心是“ #多路归并”中的“ #最优归并策略”问题，其解法与数据结构中的“ #哈夫曼树”（Huffman Tree）思想完全一致  
1. 合并长度为m 和 n的两个有序表，在最坏的情况下的比较次数为 m + n -1 
2. 最优归并策略与哈夫曼树 
	1. 哈夫曼树的构造算法（贪心算法）
		1. 将每个待合并的表 看作一个独立的节点， 表的长度就是该节点的权值
		2. 在所有节点中，选择权值最小的两个节点
		3. 将这两个节点合并，形成一个新的父节点 ，这个父节点的权值等于两个字节点权值之和
		4. 用这个新的父节点替换掉原来的 两个字节点 
		5. 重复 步骤 234 知道只剩下一个节点（根节点） 
- 题目求解过程推导 
	1. **初始表的长度（权值）**：
		A(10), B(35), C(40), D(50), E(60), F(200)
	2. 第1次合并
		从集合 {10, 35, 40, 50, 60, 200} 中选择最小的两个：10 和 35。
		*   合并表A和表B。
		*   生成的新表AB长度为 $10+35=45$。
		*   **比较次数** = $10+35-1=44$。
		*   现在的集合变为：{40, 45, 50, 60, 200
	3. 第2次合并
		*   从集合 {40, 45, 50, 60, 200} 中选择最小的两个：40 和 45。
		*   合并表C和表AB。
		*   生成的新表ABC长度为 $40+45=85$。
		*   **比较次数** = $40+45-1=84$。
		*   现在的集合变为：{50, 60, 85, 200}。
	4. 第3次合并
		*   从集合 {50, 60, 85, 200} 中选择最小的两个：50 和 60。
		*   合并表D和表E。
		*   生成的新表DE长度为 $50+60=110$。
		*   **比较次数** = $50+60-1=109$。
		*   现在的集合变为：{85, 110, 200}。
	5. 第4次合并
		*   从集合 {85, 110, 200} 中选择最小的两个：85 和 110。
		*   合并表ABC和表DE。
		*   生成的新表ABCDE长度为 $85+110=195$。
		*   **比较次数** = $85+110-1=194$。
		*   现在的集合变为：{195, 200}。
	6. 第5次合并
		*   从集合 {195, 200} 中选择最小的两个（也是仅剩的两个）：195 和 200。
		*   合并表ABCDE和表F。
		*   生成最终表ABCDEF长度为 $195+200=395$。
		*   **比较次数** = $195+200-1=394$。
		*   现在的集合变为：{395}，合并完成。
$Total = 44 + 84 + 109 + 194 + 394 = 825$
- (2) 描述 N (N≥2) 个不等长升序表的合并策略，并说明理由。 
1. 合并策略
	1. 对于 $N$ 个不等长的升序表，为了使最坏情况下的总比较次数最少，应当采用如下的贪心策略：在每一步合并时，总是选择当前所有表中长度最小的两个进行合并，并将合并后的新表放回待选集合中，如此重复 $N-1$ 次，直到所有表合并成一个表
	2. 哈夫曼算法通过让权值小（长度短）的节点离根节点更远（深度更大），权值大（长度长）的节点离根节点更近（深度更小），来保证带权路径长度 $\sum w_i d_i$ 最小。
	3. 为了降低总成本，我们应该让这些“高频”参与者每次都与同样规模较小的表合并，避免它们过早地与一个非常大的表合并，从而产生巨大的单次合并开销
- 衍生
	- [[哈夫曼编码]] 考题可能会给你一段文本，要求你统计字符频率，并为每个字符设计最优前缀码（即哈夫曼编码），并计算平均编码长度。此处的字符频率就相当于本题中的“表的长度”
	- [[哈夫曼树]]  #哈夫曼树的算法实现  要求用代码实现哈夫曼树的构建过程。这通常需要使用 #优先队列（最小堆） 来高效地找到当前权值最小的两个节点。  
	- #m叉哈夫曼树的构造规则  要求构建K叉哈夫曼树。其思想类似，只是每次选择最小的K个节点进行合并。 
	- #外部排序 这个问题是外部排序（External Sorting）中“归并阶段”的核心。考题可能结合内存大小、磁盘读写等因素，设计一个完整的外部排序问题，其中一步就是求解最优归并策略 
	- #证明哈夫曼是最优 #贪心算法的证明 ：可能会要求你证明哈夫曼算法的正确性，即证明它确实能得到最优解。这通常使用反证法或替换法（Exchange Argument）。



![[2012-exam-paper-ocr.pdf#page=4&rect=75,25,544,203|2012-exam-paper-ocr, p.4]]
[[Pasted image 20250827145409.png]]
[[Pasted image 20250827145421.png]] 
- “如何找到两个可能相交的单链表的第一个公共节点” 
1. “相交”指的是，从某个节点开始，两个链表共享后续所有的节点，形成一个 "Y" 字形结构。因为是单链表，每个节点只有一个 `next` 指针，所以它们不可能相交后又分开，只能是合并成一条
- 解法推导过程 
1. 最朴素的想法（暴力法）
	1. 我们可以遍历链表 `str1` 的每一个节点。对于 `str1` 的每个节点 `p`，我们都再从头到尾完整地遍历一遍链表 `str2`，看看 `str2` 中有没有节点和 `p` 是同一个节点（内存地址相同）。
    *   **问题：** 这种方法效率太低。如果 `str1` 的长度是 $m$，`str2` 的长度是 $n$，那么时间复杂度将是 $O(m \times n)$，在链表很长时是不可接受的。
2. 空间换时间（哈希法）
	我们可以用一个哈希集合（Hash Set）来优化。
	*   首先遍历链表 `str1`，将每个节点的内存地址存入哈希集合中。
	*   然后遍历链表 `str2`，对于 `str2` 的每一个节点，都去哈希集合里查询它的地址是否存在。
	*   第一个在哈希集合中找到的 `str2` 节点，就是第一个公共节点。
	*   **问题：** 这种方法的时间复杂度是 $O(m+n)$，效率很高。但它需要一个额外的哈希集合，空间复杂度为 $O(m)$（或 $O(n)$），不满足某些题目对空间复杂度 $O(1)$ 的要求。
3. 题目中的解法：双指针 + 长度差
	-   **关键观察：** 如果两个链表相交，那么从相交点到链表结尾的部分是完全重合的。这意味着**这部分公共尾部的长度是相同的**。
	- 假设 `str1` 的总长度为 $len1$，`str2` 的总长度为 $len2$。
    *   `str1` 的非公共部分长度为 $a$，`str2` 的非公共部分长度为 $b$。
    *   公共部分的长度为 $c$。
    *   那么我们有：
        *   $len1 = a + c$
        *   $len2 = b + c$

    我们的目标是让两个指针 `p` (从 `str1` 出发) 和 `q` (从 `str2` 出发) **同时到达** 第一个公共节点。但由于 $a$ 和 $b$ 可能不相等，如果 `p` 和 `q` 同时从头出发，它们很可能一前一后地错过
4. 如何让它们“对齐” 
	1. 既然它们的尾部是对齐的，那我们就可以让它们从某个点开始，到终点的距离相等。
	    *   计算出两个链表的长度差：$d = |len1 - len2| = |(a+c) - (b+c)| = |a-b|$。
	    *   这个长度差 $d$ 正是两条链表非公共部分的长度之差。
	    *   让指向**较长链表**的指针先走 $d$ 步。
	    *   这样操作之后，两个指针距离各自链表末尾的长度就变得完全一样了。
	    *   此时，再让两个指针**同步前进**，每次各走一步。
	    *   它们第一次相遇的那个节点，必然就是第一个公共节点。如果它们一直走到 `NULL` 都没有相遇，那就说明两个链表不相交。
	
### (2) C++ 代码实现与注释

下面是根据上述思想编写的 C++ 代码。我们首先需要定义链表节点的结构。

```cpp
#include <iostream>
#include <cmath> // 用于 abs 函数

// 定义链表节点结构
// 为了与题目保持一致，数据域使用 char 类型
struct ListNode {
    char data;          // 节点存储的数据
    ListNode* next;     // 指向下一个节点的指针

    // 构造函数，方便创建新节点
    ListNode(char val) : data(val), next(nullptr) {}
};

/**
 * @brief 计算链表的长度
 * @param head 链表的头节点
 * @return 链表的节点数量
 */
int getLength(ListNode* head) {
    int length = 0;
    ListNode* current = head;
    while (current != nullptr) {
        length++;
        current = current->next;
    }
    return length;
}

/**
 * @brief 查找两个单向链表的第一个公共节点
 * @param head1 第一个链表的头节点 (对应题目中的 str1)
 * @param head2 第二个链表的头节点 (对应题目中的 str2)
 * @return 指向第一个公共节点的指针；如果不存在公共节点，则返回 nullptr
 */
ListNode* findFirstCommonNode(ListNode* head1, ListNode* head2) {
    // --- 步骤 1: 分别计算两个链表的长度 ---
    int len1 = getLength(head1);
    int len2 = getLength(head2);

    // 初始化两个指针，分别指向两个链表的头
    ListNode* p1 = head1;
    ListNode* p2 = head2;

    // --- 步骤 2: 对齐指针 ---
    // 计算长度差，让较长的链表的指针先走 diff 步
    int diff = len1 - len2;

    if (diff > 0) { // 如果链表1更长
        for (int i = 0; i < diff; ++i) {
            p1 = p1->next;
        }
    } else { // 如果链表2更长或等长
        for (int i = 0; i < -diff; ++i) { // -diff 将负数转为正数
            p2 = p2->next;
        }
    }

    // 此时，p1 和 p2 距离各自链表末尾的长度是相同的

    // --- 步骤 3 & 4: 同步前进，寻找交点 ---
    // 循环直到两个指针相遇
    while (p1 != p2) {
        // 如果 p1 或 p2 为空，说明已经走到末尾且未相遇，
        // 但由于我们已经对齐，如果存在公共节点，它们必定同时到达；
        // 如果不存在，它们会同时变为 nullptr。
        // 所以，这个循环在 p1 和 p2 相等时（无论是否为 nullptr）都会停止。
        p1 = p1->next;
        p2 = p2->next;
    }

    // 返回相遇的节点。如果链表没有交点，此时 p1 和 p2 都是 nullptr
    return p1;
}

```

(3) 时间复杂度分析

该算法的时间复杂度可以分步计算：

1.  **计算 `len1`**：需要遍历整个 `str1` 链表，时间复杂度为 O(m)，其中 m 是 `str1` 的长度。
2.  **计算 `len2`**：需要遍历整个 `str2` 链表，时间复杂度为 O(n)，其中 n 是 `str2` 的长度。
3.  **对齐指针**：较长的链表指针移动 `|m-n|` 步，时间复杂度为 O(|m-n|)。
4.  **同步前进**：两个指针一起移动，最多移动 `min(m, n)` 步即可找到公共节点或到达末尾。时间复杂度为 O(min(m, n))。

**总时间复杂度** = O(m) + O(n) + O(|m-n|) + O(min(m, n))。
在这些项中，O(m) 和 O(n) 是主导项，因此，**最终的时间复杂度为 O(m + n)**。

**空间复杂度**：
该算法只使用了几个额外的指针变量（`p1`, `p2`）和几个整型变量（`len1`, `len2`, `diff`），这些占用的空间是固定的，与链表的长度无关。因此，**空间复杂度为 O(1)**。

- 衍生 #链表问题 
	- 【升级版解法】不先计算长度的双指针法： 
		还有一个更优雅的解法，同样是双指针，但不需要预先计算长度。
	    *   创建两个指针 `pA` 和 `pB`，分别指向 `str1` 和 `str2` 的头节点。
	    *   两个指针同时前进。
	    *   如果 `pA` 走到了链表 `str1` 的末尾，就将它重定向到 `str2` 的头节点。
	    *   如果 `pB` 走到了链表 `str2` 的末尾，就将它重定向到 `str1` 的头节点。
	    *   如果两个链表相交，那么 `pA` 和 `pB` 最终一定会在第一个公共节点相遇。
	    *   **为什么？** 假设非公共部分长度为 $a$ 和 $b$，公共部分为 $c$。指针 `pA` 走到相遇点走过的路程是 $a+c+b$。指针 `pB` 走过的路程是 $b+c+a$。路程相等，所以必然相遇。如果链表不相交，它们最终会同时变为 `NULL`。
	- #判断链表是否有环  
		*   **问题描述:** 给定一个链表，判断它内部是否存在一个环。
	    *   经典解法  使用 #快慢指针 。一个慢指针 `slow` 每次走一步，一个快指针 `fast` 每次走两步。如果链表有环，`fast` 指针最终会从后面“追上”`slow` 指针，两者相遇。如果 `fast` 指针到达了 `NULL`，则说明无环。
	- [[找到环的入口（链表）]] 



![[2012-exam-paper-ocr.pdf#page=5&rect=78,660,526,819|2012-exam-paper-ocr, p.5]]
[[Pasted image 20250827145436.png]]
-  (1) 
1. [[计算机性能评测的四个指标]]   [[Cache缺失损失]] 
	1. 计算 #MIPS每秒执行百万条指令数    
		1.   公式:
	        $\text{MIPS}=\frac{f}{CPI \times 10^6}=\frac{80 \times 10^6}{4 \times 10^6}=20$
	2. 计算平均每秒Cache缺失次数
		1. 每秒执行的指令数 = $20 \times 10^6$ 条 
		2. 平均每条指令访存 $1.5$ 次
		    *   每秒总访存次数 = $20 \times 10^6 \text{ 指令/秒} \times 1.5 \text{ 次/指令} = 30 \times 10^6 \text{ 次/秒}$
			*   Cache命中率 $H_c = 99\%$，则缺失率 $M_c = 1 - 99\% = 1\%$
		    *   每秒Cache缺失次数 = 每秒总访存次数 $\times$ 缺失率
		    *   $= 30 \times 10^6 \text{ 次/秒} \times 1\% = 300,000 \text{ 次/秒} = 300\text{k/s}$
		3. 公式:
	        $\text{每秒Cache缺失次数}=\frac{f}{CPI} \times \text{每指令访存次数} \times (1-H_c)$
	        $=(20 \times 10^6) \times 1.5 \times (1-0.99)=300,000\text{次/秒}$
	3. 计算 #主存带宽
		1. 当 #Cache缺失 时，需要从主存中读取一个 #数据块 （Block）到Cache中。主存带宽必须能满足这种数据传输的需求
			*   每秒Cache缺失 $300,000$ 次，意味着每秒需要从主存读取 $300,000$ 个数据块。
		    *   主存与Cache之间交换的数据块大小为 $16 \text{B}$。
		    *   所需主存带宽 = 每秒缺失次数 $\times$ 块大小
		    *   $= 300,000 \text{ 次/秒} \times 16 \text{ B/次} = 4,800,000 \text{ B/s} = 4.8 \text{ MB/s}$
		    *   公式:
		        $\text{主存带宽}=\text{每秒Cache缺失次数} \times \text{块大小}$
		        $=300,000 \text{/s} \times 16 \text{ B}=4.8 \text{ MB/s}$
- (2)  假定在Cache缺失的情况下访问主存时，存在0.0005%的缺页率，则CPU平均每秒产生多少次 #缺页异常 ？若页面大小为4KB，每次缺页都需要访问磁盘，访问磁盘时DMA传送采用周期挪用方式，磁盘I/O接口的数据缓冲寄存器为32位，则磁盘I/O接口平均每秒发出的DMA请求次数至少是多少？
1. 计算平均每秒缺页次数
	1.  公式:
        $\text{每秒缺页次数}=\text{每秒主存访问次数} \times \text{缺页率}=300,000 \times 0.0005\%=1.5\text{次/秒}$
	2. 计算每秒DMA请求次数
		1. 发生缺页时，需要通过DMA方式将磁盘上的一个页面（Page）传送到主存。
		*   页面大小 = $4 \text{KB} = 4096 \text{ B}$
			  磁盘I/O接口的数据缓冲寄存器为32位，即每次DMA传送的数据量为 $32 \text{位} = 4 \text{ B}$。
		    *   传送一个页面所需的DMA次数 = $\frac{\text{页面大小}}{\text{每次DMA传送的数据量}} = \frac{4096 \text{ B}}{4 \text{ B}} = 1024$ 次。
		    *   平均每秒发生 $1.5$ 次缺页，所以总的DMA请求次数为：
		    *   每秒DMA请求次数 = 每秒缺页次数 $\times$ 传送一个页面所需的DMA次数
		    *   $= 1.5 \text{ 次/秒} \times 1024 \text{ 次} = 1536 \text{ 次/秒}$
		    *   公式:
		        $\text{每秒DMA请求次数}=\text{每秒缺页次数} \times \frac{\text{页面大小}}{\text{DMA单次传送宽度}}$
		        $=1.5 \times \frac{4\text{KB}}{32\text{位}}=1.5 \times \frac{4096\text{B}}{4\text{B}}=1536\text{次/秒}$
- (3) CPU和DMA控制器同时要求使用存储器总线时，哪个优先级更高？为什么？ 
1. DMA控制器优先级更高
[[DMA和CPU的优先级]]
- (4) 为了提高性能，主存采用四体低位交叉存储模式，工作时每1/4个存储周期启动一个体。若每个体的存储周期为50ns，则该主存能提供的最大带宽是多少？
1. 理解 #四体低位交叉存储
    *   **四体 ($m=4$)**: 主存被分为4个独立的存储模块（体）。
    *   **低位交叉**: 内存地址的低位用于选择不同的体，高位用于选择体内的地址。这意味着连续的地址分布在不同的体中。
    *   **流水线工作**: 由于地址连续，可以像流水线一样，在一个存储周期内，相继启动所有4个存储体。题目中“每1/4个存储周期启动一个体”正是这种流水线工作模式的描述
2. 计算最大带宽
    *   存储体数量 $m = 4$
    *   每个体的存储周期 $T_m = 50 \text{ ns}$
    *   启动一个新体的时间间隔 $\tau = T_m / m = 50 \text{ ns} / 4 = 12.5 \text{ ns}$
    *   存储器总线宽度为32位 = $4 \text{ B}$ (这是每次从一个体中读出的数据量)。
    *   在流水线稳定工作后，每隔 $12.5 \text{ ns}$ 就能从总线上获得 $4 \text{ B}$ 的数据。
    *   最大带宽 = $\frac{\text{每次传输的数据量}}{\text{传输时间间隔}} = \frac{4 \text{ B}}{12.5 \text{ ns}} = \frac{4 \text{ B}}{12.5 \times 10^{-9} \text{ s}} = 320 \times 10^6 \text{ B/s} = 320 \text{ MB/s}$
*   另一种等效的计算方法是，在一个存储周期($T_m$)内，可以完成对 $m$ 个体的访问。
    *   公式:
        $\text{带宽} = \frac{m \times \text{总线宽度}}{T_m} = \frac{4 \times 4\text{B}}{50\text{ns}} = \frac{16\text{B}}{50 \times 10^{-9}\text{s}} = 320 \times 10^6 \text{B/s} = 320\text{MB/s}$
#直接存储器存取DMA [[IO控制方式]]
[[不同IO方式的性能计算与比较]]
#交叉存储  #低位字节LSB  [[总线与主存技术]] 
- 衍生 
	- 计算 #平均访存时间AMAT   
		-   例如：若Cache命中时间为1ns，主存访问时间为50ns，计算AMAT。
	        $T_{AMAT} = 1\text{ns} + 1\% \times 50\text{ns} = 1.5\text{ns}$
	 - #写操作的性能影响   [[写策略]] 
		 -  题目可能会引入写操作，并指定写策略（**写回法 Write-Back** 或 **写直达法 Write-Through**），分析其对总线流量和性能的影响
	- [[多级Cache]] 
	- [[交叉存储器读取连续数据的总时间]] 

![[2012-exam-paper-ocr.pdf#page=5&rect=78,159,527,658|2012-exam-paper-ocr, p.5]]
[[Pasted image 20250827145508.png]]
[[Pasted image 20250827145515.png]]
#指令Cache  #数据Cache 
[[流水线技术]] 
- #五级流水线   经典的MIPS流水线结构。    
	1. [[流水线冒险]]  
		1. #数据冒险 指令间存在数据依赖，导致后序指令用到错误的数据。
			1. [[数据冒险的解决方案]] 
	2. #没有数据转发  
		*   但在本题的设定中，**没有这个“快捷方式”**。一个寄存器的值只有在写入它的指令**完成了WB阶段后**，才对后续所有指令的**ID阶段**可见。
	    *   **规则**：如果指令`J`需要读取某个寄存器，而指令`I`（在`J`之前）会写入该寄存器，那么`J`的ID阶段必须暂停，直到`I`的WB阶段执行完毕。
	3. #按序发射，按序完成   [[按序发射，按序完成]]
1. (1) `int`型变量`x`的值为-513，存放在寄存器`R1`中，执行`SHR R1`后，`R1`的内容是多少？ 
	1. 将-513转换为16位二进制补码
		*   首先，求+513的二进制。$513 = 512 + 1 = 2^9 + 2^0$。
	    *   写成16位二进制为：`0000 0010 0000 0001`
	    *   然后，求其补码（按位取反，末位加1）：
	        *   取反：`1111 1101 1111 1110`
	        *   加1： `1111 1101 1111 1111`
	    *   转换为十六进制：`F D F F`。所以，执行前 `(R1) = FDFFH`。
	2. 执行`SHR R1`（算术右移）
	    *   `SHR`是算术右移（Shift Right Arithmetic），对于负数（符号位为1），右移时要在最高位补`1`，以保持符号不变。
	    *   将 `1111 1101 1111 1111` 右移一位：
	    *   最高位补`1`，最低位`1`移出。
	    *   结果为：`1111 1110 1111 1111`
	    *   转换为十六进制：`F E F F`。所以，执行后 `(R1) = FEFFH`。
-  (2) 若某个时间段中，有连续的4条指令进入流水线，其执行过程中没有发生任何阻塞，则执行这4条指令需要多少个时钟周期？
	1. 基础的 #流水线吞吐率 问题。  [[流水线性能分析]] 
		*   流水线级数 $k=5$。
		*   指令数 $n=4$。
		*   在没有阻塞的情况下，总执行周期 $T = (k + n - 1)$ 个时钟周期。
		*   计算：$T = (5 + 4 - 1) = 8$ 个时钟周期 
		- **直观理解**：第一条指令需要5个周期才能完成（流过所有5个阶段）。当第一条指令的IF阶段结束后，第二条指令的IF就可以开始，之后每隔一个周期就有一条新指令完成。所以总时间是第一条指令的耗时加上剩下 $n-1$ 条指令的耗时。
		    *   $T = 5 + (4-1) = 8$ 个周期。
-  (3) 解释`I₃`的ID段和`I₄`的IF段被阻塞的原因。 
	1.   **指令序列**：
	    *   `I₁: LOAD R1, [a]`
	    *   `I₂: LOAD R2, [b]`
	    *   `I₃: ADD R1, R2`
	    *   `I₄: STORE R2, [x]`
	2. #数据相关分析
	    *   **`I₃`对`I₁`和`I₂`**：`I₃`的`ADD`指令需要读取`R1`和`R2`的值。而`R1`由`I₁`写入，`R2`由`I₂`写入。这是典型的 #RAW数据相关 。
	    *   **`I₄`对`I₂`**：`I₄`的`STORE`指令需要读取`R2`的值，而`R2`由`I₂`写入。这也是 #RAW数据相关 。
	3. 阻塞原因分析
		1.  **`I₃`的ID段被阻塞**：
	        *   `I₃`在第4个时钟周期进入ID段，准备读取`R1`和`R2`。
	        *   此时，`I₁`在M段，`I₂`在EX段。它们都还没有完成WB（写回）阶段。
	        *   根据“无转发”规则，`I₃`必须等待。`I₁`在第5周期完成WB，`I₂`在第7周期完成WB。`I₃`需要等待两个操作数都准备好，所以它必须等到`I₂`也完成WB后才能继续。
	        *   `I₂`在第7周期WB，意味着`R2`的值在第8周期初才可用。因此`I₃`的ID段必须一直暂停（stall），直到可以安全地读取`R1`和`R2`。图表中显示`I₃`在第7周期进入EX，这意味着它在第6周期结束时成功读取了所需数据，这与`I₂`在第7周期才WB的图示存在矛盾。**这再次说明题目图表可能简化或存在不一致，但根本原因无疑是`I₃`对`I₁`和`I₂`的数据依赖。**
		2. **`I₄`的IF段被阻塞**：
	        *   这不是数据相关，而是**结构相关（Structural Hazard）**或流水线控制逻辑导致的。
	        *   当`I₃`的ID段被阻塞时，它会一直占据着ID阶段。流水线是一个“管道”，如果前面一个阶段被堵住了，后面就无法将新的东西送进来。
	        *   因为`I₃`卡在ID段（周期4, 5, 6），所以IF段无法将下一条指令`I₄`传递给ID段。因此，IF段本身也必须暂停工作，不能去取`I₄`。直到`I₃`离开ID段（在周期7进入EX段），IF段才被解锁，可以在第7周期去取`I₄`指令。
- (4) `x=x*2+a` 的 #流水线执行过程
	1.  翻译为 #汇编指令 ：    
	    *   `x*2` 可以用一条左移指令 `SHL` (Shift Left) 或 `ADD R, R` 实现。
	    *   `+a` 用一条 `ADD` 指令实现。
	    *   需要从内存加载`x`和`a`，最后将结果存回内存。
	    *   一个合理的指令序列如下（与答案一致）：
	        *   `I₁: LOAD R1, [x]`  // R1 = x
	        *   `I₂: LOAD R2, [a]`  // R2 = a
	        *   `I₃: SHL R1, 1`      // R1 = R1 * 2 (即 x*2)
	        *   `I₄: ADD R1, R2`      // R1 = R1 + R2 (即 x*2+a)
	        *   `I₅: STORE R1, [x]` // x = R1 (将结果存回)
	        *   **注意**：答案中`I₅`写为`STORE R2, [x]`是明显的笔误，因为最终结果在`R1`中。我们按`STORE R1, [x]`分析。
	2. #数据相关分析
	    *   `I₃` (SHL) **依赖** `I₁` (LOAD)：`I₃`要用`R1`，`I₁`写入`R1`。
	    *   `I₄` (ADD) **依赖** `I₃` (SHL) 和 `I₂` (LOAD)：`I₄`要用`R1`和`R2`，`R1`由`I₃`写入，`R2`由`I₂`写入。
	    *   `I₅` (STORE) **依赖** `I₄` (ADD)：`I₅`要将`R1`的值存入内存，`R1`由`I₄`写入。
	3. 绘制流水线时序图
		*   **C1-C5**: `I₁`无阻碍执行，在第5周期完成WB。`R1`的值在**第6周期初**可用。
	    *   **C2-C7**: `I₂`并行执行，在第7周期完成WB（图中的空一格可能是为了视觉清晰，或代表某种总线冲突，但我们按图示结果即可）。`R2`的值在**第8周期初**可用。
	    *   **`I₃`的执行**:
	        *   `I₃`在C4进入ID，发现需要`R1`。
	        *   它必须等待`I₁`完成WB。`I₁`在C5完成WB。
	        *   `I₃`的ID段因此暂停（stall）在C5和C6。
	        *   在C7，`I₃`进入EX阶段。
	        *   `I₃`的WB在C9完成。`R1`的新值（x*2）在**第10周期初**可用。
	    *   **`I₄`的执行**:
	        *   `I₄`在C7进入IF，C8进入ID。它发现需要`R1`（来自`I₃`）和`R2`（来自`I₂`）。
	        *   `R2`在C8初就绪，但`R1`要到C10初才就绪。`I₄`必须等待最晚的那个，即`R1`。
	        *   因此，`I₄`的ID段在C9, C10暂停。
	        *   在C11，`I₄`进入EX阶段。
	        *   `I₄`的WB在C13完成。`R1`的最终结果在**第14周期初**可用。
	    *   **`I₅`的执行**:
	        *   由于`I₄`阻塞了ID段，`I₅`直到C11才能进入IF，C12进入ID。它发现需要`R1`。
	        *   它必须等待`I₄`完成WB。`I₄`在C13完成WB。
	        *   `I₅`的ID段在C13暂停。
	        *   在C14，`I₅`进入EX阶段（地址计算）。
	        *   在C15，`I₅`进入M阶段，此时它需要从寄存器堆读取`R1`的值写入内存。由于`R1`在C14初已经就绪，所以M阶段可以顺利执行。
	        *   `I₅`的WB在C17完成。
	    *   **结论**：整个过程在第17个时钟周期结束。


- 衍生	
1. [[数据传输时间计算（分组交换网络-存储转发方式）]]  
	1. 如果题目改为“采用数据转发”，你需要重新画时序图。届时，暂停会大大减少。例如，`I₃`可以在`I₁`的M阶段结束后就从`M/WB`流水线寄存器获得数据，几乎不需要暂停
2. [[控制冒险的解决方案]] 
	1. 如果代码中出现分支（branch）或跳转（jump）指令，会引入控制冒险。考点会集中在：
	    *   #分支预测 (Branch Prediction) ：静态预测（如总是预测不跳转）和动态预测（使用分支历史表BHT）
	    *   #分支延迟槽 (Branch Delay Slot) ：在分支指令后放一条或多条无论如何都会执行的指令，以填充流水线气泡
3. #指令重排 
	1. 编译器可以通过重新安排指令顺序来减少暂停。例如，在本题中，如果`I₂`和`I₃`之间有其他不相关的指令，可以把它们插在中间，以“填补”`I₃`等待`I₁`的空闲周期。
4. #超标量和乱序执行 
	1. 更高级的处理器可以每个周期发射多条指令，并且不按程序顺序执行指令（只要不违反数据依赖关系），以最大化执行单元的利用率
	



![[2012-exam-paper-ocr.pdf#page=6&rect=75,661,527,817|2012-exam-paper-ocr, p.6]]
[[Pasted image 20250827145612.png]]
[[页面置换算法]]  #页框  
1. #驻留集   指当前分配给一个进程，且已装入物理内存（页框）的页面的集合。
2. #空闲页框链表FFL   操作系统维护的一个数据结构，记录了当前所有可用的物理页框。 
3. #缺页 [[缺页中断]]
4. #页面回收 [[页面回收]] 
5. #事件局限性 程序在运行时，倾向于在不久的将来再次访问最近被访问过的内存地址。一个好的页面置换策略应该能利用这个特性
该题目的策略可以总结如下：
*   **扫描周期**: 系统每隔5个时间单位（$T=5$）进行一次扫描。
*   **扫描对象**: 进程P的驻留集。
*   **扫描动作**: 检查在过去一个周期内（例如，在时间点$t=5$扫描时，检查$[0, 5)$时间段内）驻留集中的页面是否被访问过。
*   **回收规则**: 如果一个页面在过去一个周期内**未被访问**，则回收其占用的页框，并将其**放入空闲页框链表的队尾**。
*   **缺页处理**:
    *   **软缺页**: 如果要访问的页面曾经使用过，并且其页框还在空闲页框链表中，则直接从链表中找回该页框，并放回驻留集。
    *   **硬缺页**: 如果是新页面或其页框已被覆盖，则从空闲页框链表的**队头**取出一个新页框进行分配。
- 
- 题目推演过程 
1. 初始状态 (t=0):
	*   进程P驻留集: `{}` (空)
	*   空闲页框链表 (FFL): `[32, 15, 21, 41]` (队头 -> 队尾)
		*   **t=0**: **第1轮扫描**。驻留集为空，无事发生。
		*   **t=1**: 访问 `<1, 1>` (虚拟页1)。
		    *   **事件**: 缺页。页1不在驻留集中。
		    *   **处理**: 硬缺页。从FFL队头取出页框 **32**。
		    *   **状态**:
		        *   驻留集: `{<页1, 框32>}` (页1在$[0,5)$内被访问)
		        *   FFL: `[15, 21, 41]`
		*   **t=2**: 访问 `<3, 2>` (虚拟页3)。
		    *   **事件**: 缺页。页3不在驻留集中。
		    *   **处理**: 硬缺页。从FFL队头取出页框 **15**。
		    *   **状态**:
		        *   驻留集: `{<页1, 框32>, <页3, 框15>}` (页1, 3在$[0,5)$内被访问)
		        *   FFL: `[21, 41]`
		*   **t=4**: 访问 `<0, 4>` (虚拟页0)。
		    *   **事件**: 缺页。页0不在驻留集中。
		    *   **处理**: 硬缺页。从FFL队头取出页框 **21**。
		    *   **状态**:
		        *   驻留集: `{<页1, 框32>, <页3, 框15>, <页0, 框21>}` (页0, 1, 3在$[0,5)$内被访问)
		        *   FFL: `[41]`
		**回答 (1): 访问<0, 4>时，对应的页框号是什么？说明理由。**
		**答案**: 页框号为 **21**。
		**理由**: 因为初始驻留集为空，前三次访问 `<1,1>`, `<3,2>`, `<0,4>` 均发生缺页。系统按顺序从空闲页框链表头部取出页框分配，依次是32, 15, 21。因此，访问页0时分配到的是第三个空闲页框21
2. **时间段 `[5, 10)`:**
	*   **t=5**: **第2轮扫描**。检查驻留集 `{<1,32>, <3,15>, <0,21>}` 在时间段 $[0,5)$ 的访问情况。
	    *   页1 (框32): 在 $t=1$ 被访问。保留。
	    *   页3 (框15): 在 $t=2$ 被访问。保留。
	    *   页0 (框21): 在 $t=4$ 被访问。保留。
	    *   **结论**: 没有页框被回收。
	*   **t=6**: 访问 `<0, 6>` (虚拟页0)。
	    *   **事件**: 命中。页0在驻留集中 (框21)。
	    *   **处理**: 记录页0在$[5,10)$内被访问。
	    *   **状态**:
	        *   驻留集: `{<1, 32>, <3, 15>, <0, 21>}` (页0在$[5,10)$内被访问)
	        *   FFL: `[41]`
3. **时间段 `[10, 15)`:**
	*   **t=10**: **第3轮扫描**。检查驻留集 `{<1,32>, <3,15>, <0,21>}` 在时间段 $[5,10)$ 的访问情况。
	    *   页1 (框32): 在 $[5,10)$ **未被访问**。回收，放入FFL队尾。
	    *   页3 (框15): 在 $[5,10)$ **未被访问**。回收，放入FFL队尾。
	    *   页0 (框21): 在 $t=6$ 被访问。保留。
	    *   **状态**:
	        *   驻留集: `{<0, 21>}`
	        *   FFL: `[41, 32, 15]` (41是队头，32和15加入队尾)
	*   **t=11**: 访问 `<1, 11>` (虚拟页1)。
	    *   **事件**: 缺页。页1不在驻留集中。
	    *   **处理**: 软缺页。系统检查发现页1之前使用过页框32，且页框32当前在FFL中。因此从FFL中**重新取回页框32**。
	    *   **状态**:
	        *   驻留集: `{<0, 21>, <1, 32>}` (页1在$[10,15)$内被访问)
	        *   FFL: `[41, 15]` (32被移出)

	**回答 (2): 访问<1, 11>时，对应的页框号是什么？说明理由。**
	**答案**: 页框号为 **32**。
	**理由**: 在 $t=10$ 的第3轮扫描中，页1因为在 $[5,10)$ 时间段内未被访问，其页框32被回收并放入空闲页框链表。在 $t=11$ 时访问页1发生缺页，系统发现其旧页框32仍在空闲链表中，因此将其重新取回（软缺页），避免了从磁盘读取。
4. 时间段 `[13,14)`  
*   **t=13**: 访问 `<0, 13>` (虚拟页0)。
    *   **事件**: 命中。页0在驻留集中 (框21)。
    *   **处理**: 记录页0在$[10,15)$内被访问。
*   **t=14**: 访问 `<2, 14>` (虚拟页2)。
    *   **事件**: 缺页。页2不在驻留集中，且是首次访问。
    *   **处理**: 硬缺页。从FFL队头取出页框 **41**。
    *   **状态**:
        *   驻留集: `{<0, 21>, <1, 32>, <2, 41>}`
        *   FFL: `[15]`

	**回答 (3): 访问<2, 14>时，对应的页框号是什么？说明理由。**
	**答案**: 页框号为 **41**。
	**理由**: 访问页2时发生缺页，且页2是首次被访问，不属于软缺页。因此系统从当前的空闲页框链表 `[41, 15]` 的头部取出一个新页框，即41。
- (4): 该策略是否适合于 #时间局部性 好的程序？说明理由。 
	**答案**: **合适**。
	**理由**: 时间局部性好的程序意味着一个页面被访问后，在不久的将来很可能再次被访问。该策略的核心优势在于，当一个页面因为暂时不被使用而被移出驻留集时，它的页框并不会被立即覆盖，而是被放入空闲页框链表作为一个“缓冲”。如果程序由于良好的时间局部性很快再次访问该页面，就可以通过“软缺页”的方式快速从空闲链表中恢复，这个开销远小于从磁盘重新加载的“硬缺页”。程序的局部性越好，发生软缺页的几率就越大，该策略的性能优势就越明显。

- 衍生
	- [[工作集模型]]   
		- 本题的策略就是工作集模型的一个实现。扫描周期 $T=5$ 就相当于工作集窗口 $\Delta$。可能会考查工作集模型的原理、如何选择合适的 $\Delta$ 值，以及它如何防止 #系统颠簸 
	- #时钟算法Clock  
		- [[页面置换算法]]  [[时钟算法CLOCK]] 
			- 对比本题策略和标准时钟算法的异同。本题是周期性扫描，而标准时钟算法是在缺页时才扫描。可能会要求手写模拟标准的时钟算法或改进的时钟算法（例如增加修改位）
	- [[页面缓冲算法]]  
		- 可能会考查其他页面缓冲技术，如维护一个已修改页面的列表，在系统空闲时批量写回磁盘，以提高效率
	- [[全局置换与局部置换]] 
		- 本题是**局部置换**
			- **考点**: 对比两者的优缺点。全局置换（如全局LRU）通常能获得更好的系统整体吞吐率，但可能导致一个进程“窃取”另一个进程的页框，公平性差。局部置换则能更好地隔离进程，防止一个进程的行为影响其他进程，但可能无法达到全局最优


![[2012-exam-paper-ocr.pdf#page=6&rect=71,541,541,663|2012-exam-paper-ocr, p.6Pasted image 20250909011625.png]][[Pasted image 20250909011641.png]]

1. #文件控制块FCB  [[文件控制块FCB]] [[索引分配]]  [[文件分配方式]]    
2. 第一问 (1)
	**问题**: 假设索引表区仅采用直接索引结构，索引表项中块号最少占多少字节？可支持的单个文件最大长度是多少字节？
	1. 计算系统中的总磁盘块数
		1.     文件系统总容量为4TB，磁盘块大小为1KB。我们需要计算出整个系统空间被分成了多少个磁盘块。
		    *   系统总容量: $4\text{TB} = 4 \times 2^{40}\text{B} = 2^2 \times 2^{40}\text{B} = 2^{42}\text{B}$
		    *   磁盘块大小: $1\text{KB} = 2^{10}\text{B}$
		    *   总磁盘块数 = $\frac{\text{系统总容量}}{\text{磁盘块大小}} = \frac{2^{42}\text{B}}{2^{10}\text{B}} = 2^{32}$
		    所以，系统中共有$2^{32}$个不同的磁盘块。
		2. 计算块号所需的最小字节数
			- 为了能唯一地标识这$2^{32}$个磁盘块，每个块号（地址）至少需要能表示$2^{32}$个不同的值。所需的二进制位数是：
			    *   所需位数 = $\lceil \log_2(2^{32}) \rceil = 32$ 位 (bits)
			    将位数转换为字节数（1字节 = 8位）：
			    *   所需字节数 = $\frac{32 \text{ bits}}{8 \text{ bits/byte}} = 4$ 字节 (Bytes)
			    **因此，索引表项中的块号最少要占4B。**
		3. 计算单个文件的最大长度
			FCB中的 #索引表区 大小为512B，每个 #索引项（块号） 占4B。那么这个索引表区最多能存放多少个索引项呢？
			*   最大索引项数量 = $\frac{\text{索引表区总大小}}{\text{每个索引项大小}} = \frac{512\text{B}}{4\text{B}} = 128$ 个
			因为是直接索引，每个索引项指向一个磁盘块，所以这个文件最多可以由128个磁盘块组成。
			*   单个文件最大长度 = 最大索引项数量 $\times$ 磁盘块大小 = $128 \times 1\text{KB} = 128\text{KB}$
			**因此，可支持的单个文件最大长度是128KB。**
3.   (2)**问题**: 索引表区采用新结构：前8字节为`<起始块号, 块数>`，其中起始块号占6B，块数占2B；剩余504字节采用直接索引。
		a) 这种结构下可支持的单个文件最大长度是多少？
		b) 为了使文件长度达到最大，请指出起始块号和块数分别所占字节数的合理值并说明理由。
	1. 解题步骤
		1. Part a) 计算给定结构下的文件最大长度
			- 这个混合结构将文件分成了两部分：
				 1.  #连续分配 部分 : 由`<起始块号, 块数>`描述。
				    *   `块数`字段占2B = 16位。
				    *   它能表示的最大块数是 $2^{16}$。
				    *   这部分空间的大小 = $2^{16} \times 1\text{KB} = 2^{16} \times 2^{10}\text{B} = 2^{26}\text{B} = 64\text{MB}$。
				2.   #直接索引 部分: 剩余的504B空间。
				    *   这部分存放的是直接索引的块号。块号的大小应该与`起始块号`的大小保持一致，即6B。（因为它们都需要在整个4TB空间内寻址）。
				    *   可存放的索引项数量 = $\frac{504\text{B}}{6\text{B}} = 84$ 个。
				    *   这部分空间的大小 = $84 \times 1\text{KB} = 84\text{KB}$。
				3.  **总的最大长度**
				    文件的总长度是这两部分之和。
				    *   文件最大长度 = $64\text{MB} + 84\text{KB}$。
		2. Part b) 重新分配字节以达到理论最大文件长度
			1. **目标**: 调整`<起始块号, 块数>`这8个字节的内部分配，使得单个文件可能达到的长度最大。
				*   一个文件的理论最大尺寸，就是占满整个文件系统，即4TB。
				*   要描述一个4TB大小的连续文件，我们需要两个关键信息：它的起始位置 (`起始块号`) 和它的长度 (`块数`)。
				*   **`起始块号`需要多大？** 它需要能够定位到系统中的任何一个块。我们已经知道系统有$2^{32}$个块，所以`起始块号`需要32位，即**4B**。
				*   **`块数`需要多大？** 它需要能够表示文件的最大可能长度。文件的最大长度是$2^{32}$个块（整个系统），所以`块数`字段也需要能表示$2^{32}$这个数值，同样需要32位，即**4B**。
- **结论**:
	*   `起始块号`和`块数`两者所需的总字节数为 $4\text{B} + 4\text{B} = 8\text{B}$。
	*   这恰好等于题目中为它们预留的总空间。
	*   因此，最合理的分配是： #起始块号 占4字节， #块数 占4字节 。
	*   **理由**: 这样分配后，`起始块号`字段可以寻址到$2^{32}$个块中的任意一个，覆盖了整个4TB的存储空间。同时，`块数`字段可以表示最多$2^{32}$个块，使得一个文件在理论上可以大到4TB，即整个文件系统的容量，从而实现了单个文件长度的最大化。
- 衍生 
	- [[多级索引]] 
		-  计算支持的最大文件大小。通常会给出一个i-node（索引节点）结构，包含若干直接索引项、一个一级间接索引项、一个二级间接索引项等。
	- [[文件分配表FAT]] 
		-  **考点**: 虽然属于链接分配的变种，但其核心是FAT表。可能会问给定FAT表项大小（如FAT12, FAT16, FAT32）和簇（Cluster，即磁盘块）大小，计算最大分区容量
	- [[文件访问效率（文件分配方式效率）]] 
		- **考点**: 比较连续分配、链接分配、索引分配在顺序访问和随机访问文件时的磁盘I/O次数。
	- [[磁盘空闲空间管理]] 
		-  **考点**: 结合文件分配，考察空闲块的管理方法，如空闲块表法、空闲链表法、位示图法（Bitmap）。可能会让你计算位示图的大小或在特定操作后位示图的变化。


![[2012-exam-paper-ocr.pdf#page=7&rect=67,240,558,825|2012-exam-paper-ocr, p.7]]
[[Pasted image 20250909011719.png]]![[截屏2025-09-29 下午12.01.19.png]]
-  这道网络协议分析题。这道题综合考察了对 IPv4 协议、TCP 协议以及以太网 #帧格式  #以太网帧结构  的理解，需要通过解析十六进制的原始报文数据来回答问题  
	- [[完整的IP头部详解]] 
		- [[IP头部略讲]]   
			- 你需要熟悉 IPv4 头部各个字段的含义、位置和长度。
	- [[TCP头部结构]]  你需要熟悉 TCP 头部关键字段的含义。 
	- [[TCP三次握手]] 建立 TCP 连接的过程。 
	- #HDLC帧结构与以太网帧结构 [[HDLC帧结构与以太网帧结构]]
	- [[以太网帧结构的层次化解析]]   #IP数据报  就是以太网帧的数据载荷。如果 IP 数据报的长度小于 46 字节，数据链路层会进行 #填充  （Padding）以满足最小长度要求。
1.  (1) H 发送了哪些分组？TCP 连接如何建立？哪些分组需要填充？
	1. 第一部分：H 发送了哪些分组？
		*   **思路**：通过 IP 头部中的“源 IP 地址”字段来判断发送方。
		*   **已知信息**：H 的 IP 地址是 `192.168.0.8`。
		*   **换算**：将 `192.168.0.8` 转换为十六进制：
		    *   $192 = c0_{16}$
		    *   $168 = a8_{16}$
		    *   $0 = 00_{16}$
		    *   $8 = 08_{16}$
		    *   所以 H 的 IP 地址是 `c0a80008`。
		*   **分析题 47-a 表**：检查每个分组的第 13-16 字节（源 IP 地址）。
		    *   **分组 1**: `c0 a8 00 08`。**匹配**，由 H 发送。
		    *   **分组 2**: `d3 44 47 50`。不匹配。这是 S 的 IP (`211.68.71.80`)。
		    *   **分组 3**: `c0 a8 00 08`。**匹配**，由 H 发送。
		    *   **分组 4**: `d3 44 47 50`。不匹配。
		    *   **分组 5**: `c0 a8 00 08`。**匹配**，由 H 发送。
		*   **结论**：分组 1、3、5 是由 H 发送的。
	2. 第二部分：TCP 连接如何建立？
		 **思路**：分析前几个分组的 TCP 标志位，看它们是否符合“三次握手”的过程。TCP 头部紧跟在 20 字节的 IP 头部之后。TCP 标志位在 TCP 头部的第 14 字节。
	*   **分析**：
	    *   **分组 1 (H -> S)**：
	        *   #TCP头部 从第 21 字节开始：`0b d9 13 88 ...`
	        *   #TCP标志位 在第 $20 + 14 = 34$ 字节。在表中是 `70 02 43 80` 中的 `02`。
	        *   `02` (十六进制) = `00000010` (二进制)。根据  #TCP标志位顺序 (URG, ACK, PSH, RST, **SYN**, FIN)，从右往左数第 2 位是 SYN 位。所以 `SYN=1`, `ACK=0`。 
	        *   这是三次握手的**第一次握手**。
	    *   **分组 2 (S -> H)**：
	        *   TCP 标志位在第 34 字节，是 `80 12 16 d0` 中的 `12`。
	        *   `12` (十六进制) = `00010010` (二进制)。ACK 位（第 5 位）和 SYN 位（第 2 位）都为 1。所以 `SYN=1`, `ACK=1`。
	        *   同时，它的确认号 `84 6b 41 c6` 是分组 1 的序号 `84 6b 41 c5` 加 1。
	        *   这是三次握手的**第二次握手**。
	    *   **分组 3 (H -> S)**：
	        *   TCP 标志位在第 34 字节，是 `50 10 43 80` 中的 `10`。
	        *   `10` (十六进制) = `00010000` (二进制)。ACK 位为 1。所以 `SYN=0`, `ACK=1`。
	        *   同时，它的确认号 `e0 59 9f f0` 是分组 2 的序号 `e0 59 9f ef` 加 1。
	        *   这是三次握手的**第三次握手**。
	*   **结论**：通过分组 1、2、3 完成了 TCP 连接的建立过程。
	**第三部分：哪些分组需要填充？**
	
	*   **思路**：检查每个 IP 分组的“总长度”字段。如果长度小于以太网要求的 #最小载荷 46 字节，则需要 #填充 。  [[IP地址 进制转化]] [[进制转化]]  [[字节，比特，十六进制]]
	*   **分析题 47-a 表**：IP 总长度在第 3-4 字节。  [[完整的IP头部详解]]
	    *   **分组 1**: `00 30` (十六进制) = $48$ 字节。$48 > 46$，不需要填充。
	    *   **分组 2**: `00 30` (十六进制) = $48$ 字节。$48 > 46$，不需要填充。
	    *   **分组 3**: `00 28` (十六进制) = $40$ 字节。$40 < 46$，**需要填充**。
	    *   **分组 4**: `00 38` (十六进制) = $56$ 字节。$56 > 46$，不需要填充。
	    *   **分组 5**: `00 28` (十六进制) = $40$ 字节。$40 < 46$，**需要填充**。
	*   **结论**：分组 3 和 5 在通过以太网传输时需要填充。
 (2) S 已经收到的应用层数据字节数是多少？

*   **思路**：应用层数据的大小 = IP 总长度 - IP 头部长度 - TCP 头部长度。我们需要找到从 H 发往 S 且携带应用层数据的分组。
*   **分析**：
    *   分组 1 和 3 是握手报文，不携带应用层数据。
    *   分组 5 是 H 发往 S 的，在三次握手之后，可能携带数据。
        *   IP 总长度 = $40$ 字节。
        *   IP 头部长度 = $20$ 字节 (由 `45` 的 `5` 得出)。
        *   TCP 头部长度：查看分组 5 的 TCP 头部第 13 字节的前 4 位。TCP 头部为 `0b d9 13 88 ... 50 10 16 d0 ...`。第 13 字节是 `50`。`5` (十六进制) 表示首部长度为 $5 \times 4 = 20$ 字节。
        *   应用层数据 = $40 - 20 - 20 = 0$ 字节。所以分组 5 只是一个纯粹的 ACK 报文，没有数据。
2）由 3 号分组封装的 TCP 段可知，发送应用层数据初始序号为 seq=846b 41c6H，由 5 号分组封装的

TCP 段可知，ack 为 seq=846b 41d6H，所以 S 己经收到的应用层数据的字节数为 846b 41d6H - 846b

41c6H = 10H = 16，所以 S 已经接收到了 16 个字节的应用层数据。

第一部分： 

第二部分： #经过了多少个路由器 ？

首先需要确定表 47-a 中的哪一个 IP 分组与表 47-b 中的 IP 分组相对应，这就要根据 IP 分组中的标识字段（第 5-6 个字节），观察可以判断表 47-a 编号为 5 的分组是与表 47-b 的分组相对应的，因为它们的标识字段都是 68H。若要判断 IP 分组经过多少个路由器就要观察 TTL字段（第 9 个字节），发送前来自 S 的分组的 TTL 为 40H，H 接收到的分组的 TTL 为 31H，所以经过路由器的个数为 40H - 31H= 15。



