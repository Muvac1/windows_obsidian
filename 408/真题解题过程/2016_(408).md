![[2016-exam-paper-ocr.pdf#page=1&rect=81,531,524,702|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041413.png]]

[[链表]]
[[逻辑地址到物理地址的转换]]
- 解题步骤详解 
1. 第一步：根据表格重建原始链表的逻辑顺序 
	1. 从题目给定的表头元素 `c` 开始，沿着“链接地址”追踪  
		1.  表头是 `c`，其物理地址是 `1008H`。`c` 的链接地址是 `1000H`。
		2.  我们找到物理地址为 `1000H` 的节点，它是 `a`。所以 `c` 指向 `a`。
		3.  节点 `a` 的链接地址是 `1010H`。
		4.  我们找到物理地址为 `1010H` 的节点，它是 `e`。所以 `a` 指向 `e`。
		5.  节点 `e` 的链接地址是 `1004H`。
		6.  我们找到物理地址为 `1004H` 的节点，它是 `b`。所以 `e` 指向 `b`。
		7.  节点 `b` 的链接地址是 `100CH`。
		8.  我们找到物理地址为 `100CH` 的节点，它是 `d`。所以 `b` 指向 `d`。
		9.  节点 `d` 的链接地址是 `NULL`，表示链表结束。
		所以，原始链表的**逻辑顺序**是：`c -> a -> e -> b -> d`。
2. 第二步：执行插入操作
	1.  **插入后**的逻辑关系变为：`... -> a -> f -> e -> ...`  
3. 第三步：确定新的链接地址 
	1. 确定题目所问的 `a`, `e`, `f` 三个节点的链接地址
	2. D 
- 衍生 
	- #节点删除操作 
		-  可能会问：如果从原始链表中删除节点 `e`，那么节点 `a` 的新链接地址是什么？
	    *   **解法**：要删除 `e`，需要让 `e` 的前驱节点 `a`直接指向 `e` 的后继节点 `b`。所以 `a` 的新链接地址应为 `b` 的物理地址 $1004H$。
	* #双向链表 
		* 如果这是一个双向链表，每个节点除了 `next` 指针外，还有一个 `prev` 指针指向上一个节点。
		*   **考点**：在 `a` 和 `e` 之间插入 `f` 后，不仅要修改 `a->next` 和 `f->next`，还需要修改 `e->prev` 和 `f->prev`。
	- #循环链表  
		-  链表的最后一个节点不指向 `NULL`，而是指向头节点。
	    *   **考点**：遍历循环链表的终止条件不再是 `p == NULL`，而是 `p->next == head`
	* #查找链表 
		*  可能会问：在链表中查找元素 `b` 需要经过几次指针访问？
	    *   **解法**：从头节点 `c` 开始，`c -> a -> e -> b`，共需 3 次指针跳转
	* #链表时间复杂度分析 
		* **考点**：对比链表和数组在增、删、查、改等操作上的时间复杂度。
        *   按索引访问：数组为 $O(1)$，链表为 $O(n)$。
        *   在已知前驱节点的情况下插入/删除：链表为 $O(1)$。
        *   在任意位置插入/删除（需要先查找）：数组和链表平均都为 $O(n)$




![[2016-exam-paper-ocr.pdf#page=1&rect=76,427,538,532|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041417.png]]
#双向链表   
#链表
#节点删除操作   
1. `p` 节点的前驱是 `p->prev`，后继是 `p->next`。  
	*   `p` 的前驱节点的 `next` 指针指向 `p`，即：`p->prev->next == p`
	*   `p` 的后继节点的 `prev` 指针指向 `p`，即：`p->next->prev == p` 
	2. 我们要将 `p` 从链表中“摘除”，让 `p->prev` 和 `p->next` 直接相连
2. 为了达到这个目标，需要进行两步关键的指针修改
	1. **让 `p` 的前驱节点 (`p->prev`) “跳过” `p`，直接指向 `p` 的后继节点 (`p->next`)** 
		*   在代码中，这意味着我们要修改 `p->prev` 节点的 `next` 指针。
	    *   正确的赋值语句是：`p->prev->next = p->next;`
	2. **让 `p` 的后继节点 (`p->next`) “跳过” `p`，直接指向 `p` 的前驱节点 (`p->prev`)**。
	    *   在代码中，这意味着我们要修改 `p->next` 节点的 `prev` 指针。
	    *   正确的赋值语句是：`p->next->prev = p->prev;`
	-    在完成了链表的“重新链接”之后，节点 `p` 就被孤立出来了。此时，它所占用的内存空间已经不再需要，应该被释放，以防内存泄漏。
	*   执行内存释放操作：`free(p);`
	*   **重要**：`free(p)` 必须在两个指针修改操作**之后**执行。如果先执行 `free(p)`，指针 `p` 将成为一个悬挂指针，我们无法再安全地通过 `p->prev` 和 `p->next` 访问它的前驱和后继节点，从而导致链表断裂。
- 衍生 
	- #双向链表的插入操作  
		- 这是删除的逆操作。要在节点 `q` 之后插入一个新节点 `s`，需要修改四个指针：
		    *   `s->next = q->next;`
		    *   `q->next->prev = s;`
		    *   `q->next = s;`
		    *   `s->prev = q;`
		    考点会集中在**操作的正确顺序**上。与删除不同，插入操作的顺序非常重要，错误的顺序会导致链表信息丢失。
	- 边界条件处理 
		- 删除头节点或尾节点
			- 在 #双向循环链表 中，由于头尾相连，删除第一个或最后一个数据节点（紧随头结点或在头结点之前）的逻辑与删除中间节点完全相同，代码具有普适性。但在 #非循环双向链表 中，删除头/尾节点是特殊情况，需要额外处理 `head` 或 `tail` 指针
		- 删除链表中唯一的节点 
			- 删除后链表变为空。需要将头结点的 `next` 和 `prev` 都指向它自己



![[2016-exam-paper-ocr.pdf#page=1&rect=78,301,529,428|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041423.png]]

#最长递减子序列 
1.  从 `8` 开始，我们可以找到 `8, 4, 2, 1`。这是一个长度为4的递减子序列。
2.  我们再检查其他的可能性：
    *   `8, 5, 3, 1` (长度为4)
    *   `8, 4, 3, 1` (长度为4)
    *   `4, 2, 1` (长度为3)
    *   `5, 3, 1` (长度为3)

通过检查，我们可以发现最长的递减子序列长度为4。例如 **`8, 4, 2, 1`** 这个子序列。

*   `8` 在原序列第1位。
*   `4` 在原序列第2位。
*   `2` 在原序列第3位。
*   `1` 在原序列第7位。

这四个数字在原序列中依次出现，并且数值上是严格递减的。

根据上述定理，我们需要的最小轨道数 `n` 就等于最长递减子序列的长度。
所以，$n_{至少} = 4$。

- 衍生
	-  #最长递增/递减子序列 
		- **问题:** 给定一个序列，求其最长递增（或递减）子序列的长度。
	    *   **算法:**
	        *   **动态规划 $O(n^2)$:** 定义 $dp[i]$ 为以第 $i$ 个元素结尾的最长递增子序列的长度。状态转移方程为 $dp[i] = \max(dp[j]) + 1$，其中 $0 \le j < i$ 且 $array[j] < array[i]$。
	        *   **贪心 + 二分查找 $O(n \log n)$:** 维护一个数组 `tails`，其中 `tails[i]` 存储长度为 $i+1$ 的所有递增子序列中末尾元素的最小值。遍历原序列，对于每个元素，通过二分查找在 `tails` 中找到它的位置并更新。这是解决此类问题的最高效方法。
	- #栈的输出序列 
		- [[栈]] **问题:** 给定一个入栈序列（如 `1, 2, 3, ..., n`），问哪些出栈序列是合法的。 

![[2016-exam-paper-ocr.pdf#page=1&rect=78,248,527,300|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041657.png]]
[[Pasted image 20250930041709.png]]

#下标  [[三对角行列式的递推公式]] 
#三对角行列式  [[压缩存储]] 
1. #按行优先  即将矩阵的非零元素逐行地、从左到右地存放到一个一维数组中。
	根据图示，存储顺序为：
	$a_{1,1}, a_{1,2}, a_{2,1}, a_{2,2}, a_{2,3}, a_{3,2}, a_{3,3}, a_{3,4}, \dots$
2. 方法一： #公式法（计算三角矩阵）  
	1. 一个计算下标的公式：对于元素 $a_{i,j}$，其在一维数组 B (即题目中的 N) 中的下标 $k$ 为：
			$k = 2i + j - 3$ 
	2. $k = 2 \times 30 + 30 - 3$
		$k = 60 + 30 - 3$
		$k = 87$
-  方法二：根据原理手动推导 (原理推导法) 
	1.  步骤1：计算前29行（行号从1到29）的非零元素总数  
		1.   **第1行**：有2个非零元素。
			*   **第2行到第29行**：这些都是中间行，每行有3个非零元素。总共有 $29 - 2 + 1 = 28$ 行。
			*   所以，第2行到第29行的非零元素总数为：$28 \times 3 = 84$ 个。
			*   因此，前29行的非零元素总数为：$2 + 84 = 86$ 个
	2. **步骤2：确定 $m_{30,30}$ 在第30行的位置。**
		*   第30行是中间行，其非零元素按顺序存储为：$m_{30,29}, m_{30,30}, m_{30,31}$。
		*   可见，$m_{30,30}$ 是第30行中的**第2个**非零元素。 
	3. **步骤3：计算最终下标。**
		*   前29行总共有86个元素，由于数组 $N$ 的下标从0开始，这86个元素会占据下标 $0, 1, \dots, 85$。
		*   第30行的第一个非零元素 $m_{30,29}$ 的下标紧随其后，为 $86$。
		*   第30行的第二个非零元素 $m_{30,30}$ 的下标就是 $87$。
- 衍生 
	- 改变下标起始值  
		- 如果题目改为矩阵下标 $i, j$ 从0开始 ($0 \le i, j < 100$)，而数组下标仍从0开始。那么 $m_{30,30}$ 实际是第31行第31列。这时就需要重新推导公式。新的元素是 $m'_{i',j'}$，其中 
		-  $i' = i-1, j' = j-1$。代入原公式 $k = 2(i'+1) + (j'+1) - 3 = 2i' + j' 。$ 对于 $m'_{29,29}$ (即原来的 $m_{30,30}$)，$k=2 \times 29 + 29 = 87$ 
		- 如果数组下标从1开始，那么所有计算出的下标结果都需要加1。原题的答案就变成 $87+1=88$。 
	- #不同的压缩存储方式  [[压缩存储]] 



![[2016-exam-paper-ocr.pdf#page=1&rect=76,218,447,249|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041715.png]]
#树的结点总数 [[结点总数与度]]  #森林  [[二叉树的性质]]
1. #树的性质 一个包含 $n$ 个结点（顶点）的树，必然有且仅有 $n-1$ 条边  
	1. 对于任意一棵独立的树，其结点数永远比边数多 1  
2. [[森林的性质]]   
	1. 在一个森林中，树的个数（$k$）等于总结点数（$V$）减去总边数（$E$）
3. $k = 25 - 15 = 10$
 
- 衍生 
	- [[树的等价定义（无向图）]] 
	- [[生成树]]  一个有 $n$ 个结点的连通图，其生成树有多少条边？（答案：永远是 $n-1$ 条） 
		-  如何求一个图的生成树？（例如，通过深度优先搜索(DFS)或广度优先搜索(BFS)遍历可以得到一棵生成树）。
	
	- [[连通分量与强连通分量的求解算法]]
		-  **考点：** 对于任意一个无向图 $G$，它的连通分量个数 $k$ 和结点数 $V$、边数 $E$ 之间有什么关系？
			 关系是 $k \ge V - E$。
	    *   只有当图中没有环路时（即图是一个森林），等号才成立，即 $k = V - E$。这道题就是这个特例。如果图中有环，每增加一个环，至少会使 $V-E$ 的值减1

![[2016-exam-paper-ocr.pdf#page=1&rect=77,111,500,213|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041721.png]]
[[深度优先遍历实现步骤（有向图）]]  
D 
- 衍生 
	-  #图的存储结构  [[邻接矩阵，邻接表 ，稀疏图，稠密图]] 
		-    **邻接矩阵**: 用一个二维数组 `G[V][V]` 表示。`G[i][j] = 1` 表示顶点i和j之间有边。
	    *   **邻接表**: 用一个数组，每个元素指向一个链表，链表中存储该顶点的所有邻接点。
	    *   **复杂度影响**: 对于一个有 $V$ 个顶点和 $E$ 条边的图，DFS和BFS使用邻接表的时间复杂度是 $O(V+E)$；使用邻接矩阵的时间复杂度是 $O(V^2)$。
	- [[最短路径算法]] 



![[2016-exam-paper-ocr.pdf#page=1&rect=74,72,507,110|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041737.png]]


[[拓扑排序]]
#Kahn算法  
	#Kahn算法和DFS算法的时间复杂度   都是$O(V+E)$。因为每个顶点和每条边都只被访问常数次
- 现在我们来分析每一步的时间复杂度，前提是图使用**邻接表**来存储： 
1. 步骤1：计算所有顶点 的入度 
	1.   我们需要遍历整个图来确定每个顶点的入度。
	    *   使用邻接表时，遍历所有顶点的邻接链表即可。这个过程需要访问每个顶点（共 $n$ 个）和每条边（共 $e$ 条）一次。
	    *   因此，这一步的时间复杂度是 $O(n+e)$。
2. 步骤2：初始化队列
	*   我们需要遍历一次所有 $n$ 个顶点，检查它们的入度是否为0，并将符合条件的顶点入队。
    *   这个过程的时间复杂度是 $O(n)$。
3. 步骤3：主循环 
	1. 每个顶点最多入队一次，出队一次。因此，出队操作（`a`）总共会执行 $n$ 次 
		1. 对于每个出队的顶点 $u$，我们需要遍历它的所有出边。在整个算法的执行过程中，图中的每一条边 $e$ 都会被访问且仅被访问一次（当其起始顶点出队时） 
	2. 因此，更新邻接点入度（`b`, `c`, `d`）的总操作次数与边的数量 $e$ 成正比 
		1.  综合来看，主循环的总时间复杂度是 $O(n+e)$
4. 算法的总时间复杂度是以上各个步骤复杂度的总和：
	$T(n, e) = O(n+e) \text{ (计算入度)} + O(n) \text{ (初始化队列)} + O(n+e) \text{ (主循环)}$  
	根据 #大O表示法的加法法则 ，我们取最高阶的项，所以最终的时间复杂度为 $O(n+e)$。

- 衍生 
	- 不同存储结构下的时间复杂度 
		-   **问题:** 如果图采用**邻接矩阵**存储，拓扑排序的时间复杂度是多少？
	    *   **解析:**
	        *   **计算入度:** 需要遍历整个邻接矩阵的每一列，时间复杂度为 $O(n^2)$。
	        *   **主循环:** 当一个顶点 $u$出队后，需要找到所有从 $u$ 出发的边，这需要遍历邻接矩阵的第 $u$ 行，耗时 $O(n)$。由于有 $n$ 个顶点，主循环总耗时为 $O(n^2)$。
	        *   **总复杂度:** $O(n^2)$。这是一个非常经典的对比考点。
	- #判断图中是否存在环
		- **问题:** 如何使用拓扑排序来判断一个有向图中是否存在环？
	    *   **解析:** 在Kahn算法执行完毕后，检查排好序的顶点个数是否小于图中的总顶点数 $n$。
	        *   如果个数等于 $n$，说明所有顶点都成功出队，图是DAG。
	        *   如果个数小于 $n$，说明队列提前变空，而图中仍有顶点未被访问（这些顶点的入度始终无法变为0），这些顶点必然构成了环。
	- [[关键路径]]  
		-   **问题:** 在项目管理中，拓扑排序和什么概念紧密相关？
		    *   **解析:** 关键路径。在AOE网（Activity on Edge Network）中，通常先进行拓扑排序来确保事件发生的顺序，然后在此基础上计算每个事件的最早和最晚发生时间，从而找出关键路径。关键路径是项目中耗时最长的路径，决定了项目的总工期。这是数据结构在工程应用中的一个重要考点。
			






![[2016-exam-paper-ocr.pdf#page=2&rect=70,703,525,822|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041745.png]]
[[Pasted image 20250930041751.png]]

[[Dijkstra 算法]]
 1. A
- #Dijkstra算法的局限性  
	- 该算法不能处理带有**负权边**的图。如果存在负权边，贪心选择可能导致最终结果不是全局最优解。对于存在负权边的情况，需要使用Bellman-Ford算法或SPFA算法。

 



![[2016-exam-paper-ocr.pdf#page=2&rect=75,555,535,701|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041757.png]]
送分题 
B


![[2016-exam-paper-ocr.pdf#page=2&rect=75,506,442,554|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041822.png]]

[[B树和B+树的区别]] 
A
由于 B+树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，可以进行顺序查找，而 B 树不支持顺序查找（只支持多路查找）

- 衍生 
	- 树的高度与I/O性能 
		-   **考点:** 为什么 B+树比 B 树更适合做数据库索引？ 
	- #B树的阶数计算 [[B树的阶数计算]] 
		- **考点:** 假设磁盘页大小为 $P$ 字节，关键字大小为 $k$ 字节，指针大小为 $ptr$ 字节。计算一个B树（或B+树）的阶数 $m$ 
			- **解答:** 对于B树的内部节点，一个节点需要存储 $m$ 个指向子节点的指针和 $m-1$ 个关键字及对应的数据。假设数据大小为 $d$。则有不等式： 
				-     $(m-1) \times (k+d) + m \times ptr \le P$
		    *   对于B+树的内部节点，不存储数据，因此不等式为：
		        $(m-1) \times k + m \times ptr \le P$
			-  通过解这个不等式，可以得出 $m$ 的最大值。这个计算题是衡量对 B/B+树物理结构理解程度的常见考点。



![[2016-exam-paper-ocr.pdf#page=2&rect=78,471,480,507|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041958.png]]

[[排序算法]] [[内部排序和外部排序]]   [[各类内部排序算法的时间复杂与空间复杂度]] 
D
- 衍生 
	- 外部排序的 I/O 成本计算 
		- 可能会让你计算总的磁盘读写次数。
	    *   假设总数据块数为 $B$，内存缓冲块数为 $M$。
	- 特定场景下的算法选择
		- **问题**：当数据量不大，但要求最坏情况下的时间复杂度必须是 $O(n \log n)$ 时，应该选择什么？
	    *   **答案**：堆排序或归并排序（快速排序最坏情况是 $O(n^2)$）。
	    *   **问题**：当待排序序列大部分已有序时，哪种算法效率更高？
	    *   **答案**：插入排序或冒泡排序，它们在这种情况下时间复杂度可以接近 $O(n)$。

![[2016-exam-paper-ocr.pdf#page=2&rect=78,436,484,470|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042003.png]]
C
[[程序设计语言的处理过程]] 
 [[高级语言处理的完整流程]] 
 - 衍生 
	 - [[编译与解释的详细对比（动态语言vs静态语言 ）]]  





![[2016-exam-paper-ocr.pdf#page=2&rect=75,360,527,437|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042008.png]]

[[浮点数运算规则]] 
[[补码]]




![[2016-exam-paper-ocr.pdf#page=2&rect=79,296,522,358|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042015.png]]
[[Pasted image 20250930042022.png]]
[[字节序]]
#小端模式 






![[2016-exam-paper-ocr.pdf#page=2&rect=82,190,525,296|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042029.png]]


![[2016-exam-paper-ocr.pdf#page=2&rect=82,142,526,193|2016-exam-paper-ocr, p.2]]
![[Pasted image 20250930042035.png]]


![[2016-exam-paper-ocr.pdf#page=2&rect=76,64,532,139|2016-exam-paper-ocr, p.2]]
![[Pasted image 20250930042105.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=77,766,520,820|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042111.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=75,692,526,770|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042117.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=80,629,523,692|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042123.png]]
![[Pasted image 20250930042131.png]]

![[2016-exam-paper-ocr.pdf#page=3&rect=78,581,513,631|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042137.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=74,520,521,581|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042144.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=78,445,476,519|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042159.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=79,381,518,444|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042208.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=80,319,521,383|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042216.png]]


![[2016-exam-paper-ocr.pdf#page=3&rect=77,227,526,319|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042223.png]]
![[Pasted image 20250930042228.png]]

![[2016-exam-paper-ocr.pdf#page=3&rect=78,35,527,229|2016-exam-paper-ocr, p.3]]
![[Pasted image 20250930042234.png]]


![[2016-exam-paper-ocr.pdf#page=4&rect=73,709,488,825|2016-exam-paper-ocr, p.4]]
![[Pasted image 20250930042243.png]]

![[Pasted image 20250930042416.png]]
![[Pasted image 20250930042257.png]]

![[2016-exam-paper-ocr.pdf#page=4&rect=64,344,534,528|2016-exam-paper-ocr, p.4]]
![[截屏2025-09-30 上午4.24.42.png]]
![[截屏2025-09-30 上午4.24.48.png]]

![[2016-exam-paper-ocr.pdf#page=4&rect=76,269,357,344|2016-exam-paper-ocr, p.4]]
![[截屏2025-09-30 上午4.24.54.png]]

![[2016-exam-paper-ocr.pdf#page=4&rect=75,206,516,272|2016-exam-paper-ocr, p.4]]
![[截屏2025-09-30 上午4.25.03.png]]


![[2016-exam-paper-ocr.pdf#page=4&rect=74,161,473,211|2016-exam-paper-ocr, p.4]]
![[Pasted image 20250930042548.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=70,553,550,824|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042556.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=75,502,520,552|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042605.png]]
![[Pasted image 20250930042622.png]]

![[2016-exam-paper-ocr.pdf#page=5&rect=74,455,524,503|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042634.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=74,405,520,457|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042639.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=75,344,516,406|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042644.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=80,268,521,345|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042650.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=81,202,515,270|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042658.png]]


![[2016-exam-paper-ocr.pdf#page=6&rect=75,633,522,821|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042706.png]]
![[Pasted image 20250930042714.png]]

![[2016-exam-paper-ocr.pdf#page=6&rect=78,568,518,634|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042731.png]]


![[2016-exam-paper-ocr.pdf#page=6&rect=79,479,521,567|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042739.png]]
![[Pasted image 20250930042747.png]]![[Pasted image 20250930042807.png]]

![[2016-exam-paper-ocr.pdf#page=6&rect=75,261,527,480|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042852.png]]


![[2016-exam-paper-ocr.pdf#page=7&rect=79,512,521,819|2016-exam-paper-ocr, p.7]]
![[Pasted image 20250930042904.png]]
![[Pasted image 20250930042930.png]]

![[2016-exam-paper-ocr.pdf#page=7&rect=78,390,524,514|2016-exam-paper-ocr, p.7]]
![[Pasted image 20250930042948.png]]
![[Pasted image 20250930042953.png]]

![[2016-exam-paper-ocr.pdf#page=7&rect=74,125,528,390|2016-exam-paper-ocr, p.7]]
![[Pasted image 20250930043006.png]]






