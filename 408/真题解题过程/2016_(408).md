![[2016-exam-paper-ocr.pdf#page=1&rect=81,531,524,702|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041413.png]]

[[链表]]
[[逻辑地址到物理地址的转换]]
- 解题步骤详解 
1. 第一步：根据表格重建原始链表的逻辑顺序 
	1. 从题目给定的表头元素 `c` 开始，沿着“链接地址”追踪  
		1.  表头是 `c`，其物理地址是 `1008H`。`c` 的链接地址是 `1000H`。
		2.  我们找到物理地址为 `1000H` 的节点，它是 `a`。所以 `c` 指向 `a`。
		3.  节点 `a` 的链接地址是 `1010H`。
		4.  我们找到物理地址为 `1010H` 的节点，它是 `e`。所以 `a` 指向 `e`。
		5.  节点 `e` 的链接地址是 `1004H`。
		6.  我们找到物理地址为 `1004H` 的节点，它是 `b`。所以 `e` 指向 `b`。
		7.  节点 `b` 的链接地址是 `100CH`。
		8.  我们找到物理地址为 `100CH` 的节点，它是 `d`。所以 `b` 指向 `d`。
		9.  节点 `d` 的链接地址是 `NULL`，表示链表结束。
		所以，原始链表的**逻辑顺序**是：`c -> a -> e -> b -> d`。
2. 第二步：执行插入操作
	1.  **插入后**的逻辑关系变为：`... -> a -> f -> e -> ...`  
3. 第三步：确定新的链接地址 
	1. 确定题目所问的 `a`, `e`, `f` 三个节点的链接地址
	2. D 
- 衍生 
	- #节点删除操作 
		-  可能会问：如果从原始链表中删除节点 `e`，那么节点 `a` 的新链接地址是什么？
	    *   **解法**：要删除 `e`，需要让 `e` 的前驱节点 `a`直接指向 `e` 的后继节点 `b`。所以 `a` 的新链接地址应为 `b` 的物理地址 $1004H$。
	* #双向链表 
		* 如果这是一个双向链表，每个节点除了 `next` 指针外，还有一个 `prev` 指针指向上一个节点。
		*   **考点**：在 `a` 和 `e` 之间插入 `f` 后，不仅要修改 `a->next` 和 `f->next`，还需要修改 `e->prev` 和 `f->prev`。
	- #循环链表  
		-  链表的最后一个节点不指向 `NULL`，而是指向头节点。
	    *   **考点**：遍历循环链表的终止条件不再是 `p == NULL`，而是 `p->next == head`
	* #查找链表 
		*  可能会问：在链表中查找元素 `b` 需要经过几次指针访问？
	    *   **解法**：从头节点 `c` 开始，`c -> a -> e -> b`，共需 3 次指针跳转
	* #链表时间复杂度分析 
		* **考点**：对比链表和数组在增、删、查、改等操作上的时间复杂度。
        *   按索引访问：数组为 $O(1)$，链表为 $O(n)$。
        *   在已知前驱节点的情况下插入/删除：链表为 $O(1)$。
        *   在任意位置插入/删除（需要先查找）：数组和链表平均都为 $O(n)$




![[2016-exam-paper-ocr.pdf#page=1&rect=76,427,538,532|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041417.png]]
#双向链表   
#链表
#节点删除操作   
1. `p` 节点的前驱是 `p->prev`，后继是 `p->next`。  
	*   `p` 的前驱节点的 `next` 指针指向 `p`，即：`p->prev->next == p`
	*   `p` 的后继节点的 `prev` 指针指向 `p`，即：`p->next->prev == p` 
	2. 我们要将 `p` 从链表中“摘除”，让 `p->prev` 和 `p->next` 直接相连
2. 为了达到这个目标，需要进行两步关键的指针修改
	1. **让 `p` 的前驱节点 (`p->prev`) “跳过” `p`，直接指向 `p` 的后继节点 (`p->next`)** 
		*   在代码中，这意味着我们要修改 `p->prev` 节点的 `next` 指针。
	    *   正确的赋值语句是：`p->prev->next = p->next;`
	2. **让 `p` 的后继节点 (`p->next`) “跳过” `p`，直接指向 `p` 的前驱节点 (`p->prev`)**。
	    *   在代码中，这意味着我们要修改 `p->next` 节点的 `prev` 指针。
	    *   正确的赋值语句是：`p->next->prev = p->prev;`
	-    在完成了链表的“重新链接”之后，节点 `p` 就被孤立出来了。此时，它所占用的内存空间已经不再需要，应该被释放，以防内存泄漏。
	*   执行内存释放操作：`free(p);`
	*   **重要**：`free(p)` 必须在两个指针修改操作**之后**执行。如果先执行 `free(p)`，指针 `p` 将成为一个悬挂指针，我们无法再安全地通过 `p->prev` 和 `p->next` 访问它的前驱和后继节点，从而导致链表断裂。
- 衍生 
	- #双向链表的插入操作  
		- 这是删除的逆操作。要在节点 `q` 之后插入一个新节点 `s`，需要修改四个指针：
		    *   `s->next = q->next;`
		    *   `q->next->prev = s;`
		    *   `q->next = s;`
		    *   `s->prev = q;`
		    考点会集中在**操作的正确顺序**上。与删除不同，插入操作的顺序非常重要，错误的顺序会导致链表信息丢失。
	- 边界条件处理 
		- 删除头节点或尾节点
			- 在 #双向循环链表 中，由于头尾相连，删除第一个或最后一个数据节点（紧随头结点或在头结点之前）的逻辑与删除中间节点完全相同，代码具有普适性。但在 #非循环双向链表 中，删除头/尾节点是特殊情况，需要额外处理 `head` 或 `tail` 指针
		- 删除链表中唯一的节点 
			- 删除后链表变为空。需要将头结点的 `next` 和 `prev` 都指向它自己



![[2016-exam-paper-ocr.pdf#page=1&rect=78,301,529,428|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041423.png]]

#最长递减子序列 
1.  从 `8` 开始，我们可以找到 `8, 4, 2, 1`。这是一个长度为4的递减子序列。
2.  我们再检查其他的可能性：
    *   `8, 5, 3, 1` (长度为4)
    *   `8, 4, 3, 1` (长度为4)
    *   `4, 2, 1` (长度为3)
    *   `5, 3, 1` (长度为3)

通过检查，我们可以发现最长的递减子序列长度为4。例如 **`8, 4, 2, 1`** 这个子序列。

*   `8` 在原序列第1位。
*   `4` 在原序列第2位。
*   `2` 在原序列第3位。
*   `1` 在原序列第7位。

这四个数字在原序列中依次出现，并且数值上是严格递减的。

根据上述定理，我们需要的最小轨道数 `n` 就等于最长递减子序列的长度。
所以，$n_{至少} = 4$。

- 衍生
	-  #最长递增/递减子序列 
		- **问题:** 给定一个序列，求其最长递增（或递减）子序列的长度。
	    *   **算法:**
	        *   **动态规划 $O(n^2)$:** 定义 $dp[i]$ 为以第 $i$ 个元素结尾的最长递增子序列的长度。状态转移方程为 $dp[i] = \max(dp[j]) + 1$，其中 $0 \le j < i$ 且 $array[j] < array[i]$。
	        *   **贪心 + 二分查找 $O(n \log n)$:** 维护一个数组 `tails`，其中 `tails[i]` 存储长度为 $i+1$ 的所有递增子序列中末尾元素的最小值。遍历原序列，对于每个元素，通过二分查找在 `tails` 中找到它的位置并更新。这是解决此类问题的最高效方法。
	- #栈的输出序列 
		- [[栈]] **问题:** 给定一个入栈序列（如 `1, 2, 3, ..., n`），问哪些出栈序列是合法的。 

![[2016-exam-paper-ocr.pdf#page=1&rect=78,248,527,300|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041657.png]]
[[Pasted image 20250930041709.png]]

#下标  [[三对角行列式的递推公式]] 
#三对角行列式  [[压缩存储]] 
1. #按行优先  即将矩阵的非零元素逐行地、从左到右地存放到一个一维数组中。
	根据图示，存储顺序为：
	$a_{1,1}, a_{1,2}, a_{2,1}, a_{2,2}, a_{2,3}, a_{3,2}, a_{3,3}, a_{3,4}, \dots$
2. 方法一： #公式法（计算三角矩阵）  
	1. 一个计算下标的公式：对于元素 $a_{i,j}$，其在一维数组 B (即题目中的 N) 中的下标 $k$ 为：
			$k = 2i + j - 3$ 
	2. $k = 2 \times 30 + 30 - 3$
		$k = 60 + 30 - 3$
		$k = 87$
-  方法二：根据原理手动推导 (原理推导法) 
	1.  步骤1：计算前29行（行号从1到29）的非零元素总数  
		1.   **第1行**：有2个非零元素。
			*   **第2行到第29行**：这些都是中间行，每行有3个非零元素。总共有 $29 - 2 + 1 = 28$ 行。
			*   所以，第2行到第29行的非零元素总数为：$28 \times 3 = 84$ 个。
			*   因此，前29行的非零元素总数为：$2 + 84 = 86$ 个
	2. **步骤2：确定 $m_{30,30}$ 在第30行的位置。**
		*   第30行是中间行，其非零元素按顺序存储为：$m_{30,29}, m_{30,30}, m_{30,31}$。
		*   可见，$m_{30,30}$ 是第30行中的**第2个**非零元素。 
	3. **步骤3：计算最终下标。**
		*   前29行总共有86个元素，由于数组 $N$ 的下标从0开始，这86个元素会占据下标 $0, 1, \dots, 85$。
		*   第30行的第一个非零元素 $m_{30,29}$ 的下标紧随其后，为 $86$。
		*   第30行的第二个非零元素 $m_{30,30}$ 的下标就是 $87$。
- 衍生 
	- 改变下标起始值  
		- 如果题目改为矩阵下标 $i, j$ 从0开始 ($0 \le i, j < 100$)，而数组下标仍从0开始。那么 $m_{30,30}$ 实际是第31行第31列。这时就需要重新推导公式。新的元素是 $m'_{i',j'}$，其中 
		-  $i' = i-1, j' = j-1$。代入原公式 $k = 2(i'+1) + (j'+1) - 3 = 2i' + j' 。$ 对于 $m'_{29,29}$ (即原来的 $m_{30,30}$)，$k=2 \times 29 + 29 = 87$ 
		- 如果数组下标从1开始，那么所有计算出的下标结果都需要加1。原题的答案就变成 $87+1=88$。 
	- #不同的压缩存储方式  [[压缩存储]] 



![[2016-exam-paper-ocr.pdf#page=1&rect=76,218,447,249|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041715.png]]
#树的结点总数 [[结点总数与度]]  #森林  [[二叉树的性质]]
1. #树的性质 一个包含 $n$ 个结点（顶点）的树，必然有且仅有 $n-1$ 条边  
	1. 对于任意一棵独立的树，其结点数永远比边数多 1  
2. [[森林的性质]]   
	1. 在一个森林中，树的个数（$k$）等于总结点数（$V$）减去总边数（$E$）
3. $k = 25 - 15 = 10$
 
- 衍生 
	- [[树的等价定义（无向图）]] 
	- [[生成树]]  一个有 $n$ 个结点的连通图，其生成树有多少条边？（答案：永远是 $n-1$ 条） 
		-  如何求一个图的生成树？（例如，通过深度优先搜索(DFS)或广度优先搜索(BFS)遍历可以得到一棵生成树）。
	
	- [[连通分量与强连通分量的求解算法]]
		-  **考点：** 对于任意一个无向图 $G$，它的连通分量个数 $k$ 和结点数 $V$、边数 $E$ 之间有什么关系？
			 关系是 $k \ge V - E$。
	    *   只有当图中没有环路时（即图是一个森林），等号才成立，即 $k = V - E$。这道题就是这个特例。如果图中有环，每增加一个环，至少会使 $V-E$ 的值减1

![[2016-exam-paper-ocr.pdf#page=1&rect=77,111,500,213|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041721.png]]
[[深度优先遍历实现步骤（有向图）]]  
D 
- 衍生 
	-  #图的存储结构  [[邻接矩阵，邻接表 ，稀疏图，稠密图]] 
		-    **邻接矩阵**: 用一个二维数组 `G[V][V]` 表示。`G[i][j] = 1` 表示顶点i和j之间有边。
	    *   **邻接表**: 用一个数组，每个元素指向一个链表，链表中存储该顶点的所有邻接点。
	    *   **复杂度影响**: 对于一个有 $V$ 个顶点和 $E$ 条边的图，DFS和BFS使用邻接表的时间复杂度是 $O(V+E)$；使用邻接矩阵的时间复杂度是 $O(V^2)$。
	- [[最短路径算法]] 



![[2016-exam-paper-ocr.pdf#page=1&rect=74,72,507,110|2016-exam-paper-ocr, p.1]]
[[Pasted image 20250930041737.png]]


[[拓扑排序]]
#Kahn算法  
	#Kahn算法和DFS算法的时间复杂度   都是$O(V+E)$。因为每个顶点和每条边都只被访问常数次
- 现在我们来分析每一步的时间复杂度，前提是图使用**邻接表**来存储： 
1. 步骤1：计算所有顶点 的入度 
	1.   我们需要遍历整个图来确定每个顶点的入度。
	    *   使用邻接表时，遍历所有顶点的邻接链表即可。这个过程需要访问每个顶点（共 $n$ 个）和每条边（共 $e$ 条）一次。
	    *   因此，这一步的时间复杂度是 $O(n+e)$。
2. 步骤2：初始化队列
	*   我们需要遍历一次所有 $n$ 个顶点，检查它们的入度是否为0，并将符合条件的顶点入队。
    *   这个过程的时间复杂度是 $O(n)$。
3. 步骤3：主循环 
	1. 每个顶点最多入队一次，出队一次。因此，出队操作（`a`）总共会执行 $n$ 次 
		1. 对于每个出队的顶点 $u$，我们需要遍历它的所有出边。在整个算法的执行过程中，图中的每一条边 $e$ 都会被访问且仅被访问一次（当其起始顶点出队时） 
	2. 因此，更新邻接点入度（`b`, `c`, `d`）的总操作次数与边的数量 $e$ 成正比 
		1.  综合来看，主循环的总时间复杂度是 $O(n+e)$
4. 算法的总时间复杂度是以上各个步骤复杂度的总和：
	$T(n, e) = O(n+e) \text{ (计算入度)} + O(n) \text{ (初始化队列)} + O(n+e) \text{ (主循环)}$  
	根据 #大O表示法的加法法则 ，我们取最高阶的项，所以最终的时间复杂度为 $O(n+e)$。

- 衍生 
	- 不同存储结构下的时间复杂度 
		-   **问题:** 如果图采用**邻接矩阵**存储，拓扑排序的时间复杂度是多少？
	    *   **解析:**
	        *   **计算入度:** 需要遍历整个邻接矩阵的每一列，时间复杂度为 $O(n^2)$。
	        *   **主循环:** 当一个顶点 $u$出队后，需要找到所有从 $u$ 出发的边，这需要遍历邻接矩阵的第 $u$ 行，耗时 $O(n)$。由于有 $n$ 个顶点，主循环总耗时为 $O(n^2)$。
	        *   **总复杂度:** $O(n^2)$。这是一个非常经典的对比考点。
	- #判断图中是否存在环
		- **问题:** 如何使用拓扑排序来判断一个有向图中是否存在环？
	    *   **解析:** 在Kahn算法执行完毕后，检查排好序的顶点个数是否小于图中的总顶点数 $n$。
	        *   如果个数等于 $n$，说明所有顶点都成功出队，图是DAG。
	        *   如果个数小于 $n$，说明队列提前变空，而图中仍有顶点未被访问（这些顶点的入度始终无法变为0），这些顶点必然构成了环。
	- [[关键路径]]  
		-   **问题:** 在项目管理中，拓扑排序和什么概念紧密相关？
		    *   **解析:** 关键路径。在AOE网（Activity on Edge Network）中，通常先进行拓扑排序来确保事件发生的顺序，然后在此基础上计算每个事件的最早和最晚发生时间，从而找出关键路径。关键路径是项目中耗时最长的路径，决定了项目的总工期。这是数据结构在工程应用中的一个重要考点。
			






![[2016-exam-paper-ocr.pdf#page=2&rect=70,703,525,822|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041745.png]]
[[Pasted image 20250930041751.png]]

[[Dijkstra 算法]]
 1. A
- #Dijkstra算法的局限性  
	- 该算法不能处理带有**负权边**的图。如果存在负权边，贪心选择可能导致最终结果不是全局最优解。对于存在负权边的情况，需要使用Bellman-Ford算法或SPFA算法。

 



![[2016-exam-paper-ocr.pdf#page=2&rect=75,555,535,701|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041757.png]]
送分题 
B


![[2016-exam-paper-ocr.pdf#page=2&rect=75,506,442,554|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041822.png]]

[[B树和B+树的区别]] 
A
由于 B+树的所有叶结点中包含了全部的关键字信息，且叶结点本身依关键字从小到大顺序链接，可以进行顺序查找，而 B 树不支持顺序查找（只支持多路查找）

- 衍生 
	- 树的高度与I/O性能 
		-   **考点:** 为什么 B+树比 B 树更适合做数据库索引？ 
	- #B树的阶数计算 [[B树的阶数计算]] 
		- **考点:** 假设磁盘页大小为 $P$ 字节，关键字大小为 $k$ 字节，指针大小为 $ptr$ 字节。计算一个B树（或B+树）的阶数 $m$ 
			- **解答:** 对于B树的内部节点，一个节点需要存储 $m$ 个指向子节点的指针和 $m-1$ 个关键字及对应的数据。假设数据大小为 $d$。则有不等式： 
				-     $(m-1) \times (k+d) + m \times ptr \le P$
		    *   对于B+树的内部节点，不存储数据，因此不等式为：
		        $(m-1) \times k + m \times ptr \le P$
			-  通过解这个不等式，可以得出 $m$ 的最大值。这个计算题是衡量对 B/B+树物理结构理解程度的常见考点。



![[2016-exam-paper-ocr.pdf#page=2&rect=78,471,480,507|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930041958.png]]

[[排序算法]] [[内部排序和外部排序]]   [[各类内部排序算法的时间复杂与空间复杂度]] 
D
- 衍生 
	- 外部排序的 I/O 成本计算 
		- 可能会让你计算总的磁盘读写次数。
	    *   假设总数据块数为 $B$，内存缓冲块数为 $M$。
	- 特定场景下的算法选择
		- **问题**：当数据量不大，但要求最坏情况下的时间复杂度必须是 $O(n \log n)$ 时，应该选择什么？
	    *   **答案**：堆排序或归并排序（快速排序最坏情况是 $O(n^2)$）。
	    *   **问题**：当待排序序列大部分已有序时，哪种算法效率更高？
	    *   **答案**：插入排序或冒泡排序，它们在这种情况下时间复杂度可以接近 $O(n)$。

![[2016-exam-paper-ocr.pdf#page=2&rect=78,436,484,470|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042003.png]]
C
[[程序设计语言的处理过程]] 
 [[高级语言处理的完整流程]] 
 - 衍生 
	 - [[编译与解释的详细对比（动态语言vs静态语言 ）]]  





![[2016-exam-paper-ocr.pdf#page=2&rect=75,360,527,437|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042008.png]]
- 这道题目考察的是C语言中整数的内部表示（特别是补码）以及有符号整数（`signed`）和无符号整数（`unsigned`）之间的类型转换规则。 [[数据类型转换]] 
	- 进行**符号扩展 (Sign Extension)**。即在高位补充原数字的符号位。如果原数是正数（符号位为0），则补充0；如果原数是负数（符号位为1），则补充1。这样可以保持原数的数值不变。 #有符号整数到无符号整数的类型转换规则 
1. 第1步：理解数据类型和其在内存中的大小 
	1. **`short`**：是有符号的16位整数。它的表示范围是 $-32768$ 到 $32767$。这个范围可以用公式 $[ -2^{16-1}, 2^{16-1}-1 ]$ 计算得出。
		*   **`unsigned short`**：是无符号的16位整数。它的表示范围是 $0$ 到 $65535$。这个范围可以用公式 $[ 0, 2^{16}-1 ]$ 计算得出。
2. 第2步：理解有符号整数的补码表示
	1.  **取其绝对值的原码**：[[原码，反码的运算和溢出判断]] #原码表示   [[补码]]
	    `32767` 的16位二进制表示（原码）是：
	    `0111 1111 1111 1111`
	    （因为 $32767 = 2^{15} - 1$）
	2. **按位取反（得到反码）**：
	    将二进制的每一位 `0` 变成 `1`，`1` 变成 `0`。
	    `1000 0000 0000 0000`
	3. **加 1（得到补码）**：
	    在反码的基础上加1。
	    `1000 0000 0000 0001`
3. 第3步：理解 `signed` 到 `unsigned` 的转换规则
	1.   对于变量 `usi`（`unsigned short` 类型），`1000 0000 0000 0001` 这个位模式被解释为一个无符号数。在无符号数中，没有符号位的概念，所有16位都用来表示数值的大小。 #有符号整数到无符号整数的类型转换规则 
4. 第4步：计算 `usi` 的值
	1. 我们需要计算二进制数 `1000 0000 0000 0001` 作为无符号16位整数时，它代表的十进制值。
		这个二进制数中，第15位（最高位）是1，第0位（最低位）是1，其他位都是0。其值为：
	$1 \times 2^{15} + 0 \times 2^{14} + \dots + 0 \times 2^1 + 1 \times 2^0$
		$= 2^{15} + 2^0$
		$= 32768 + 1$
		$= 32769$
-  另一种更快的计算方法（ #模运算 ） 
	1. C语言标准规定，将一个有符号数 `v` 转换为N位的无符号数时，如果 `v` 是负数，结果是 $v + 2^N$。
		在本题中，`v = -32767`，`N = 16`。
		所以 `usi` 的值为：
		$usi = -32767 + 2^{16}$
		$= -32767 + 65536$
		$= 32769$
			

- 衍生 
	- **反向转换**：从 `unsigned short` 转换为 `short` 
		-   ```c
    unsigned short a = 65535;
    short b = a;
    // 问 b 的值是多少？
    ```
    *   **解析**：`65535` 的二进制是 `1111 1111 1111 1111`。当这个位模式被解释为 `short` 时，最高位 `1` 是符号位，表示负数。这是一个补码，我们需要求它的原码。补码求原码（负数）：减1，再按位取反。
    *   `1111 1111 1111 1111` - 1 = `1111 1111 1111 1110` (反码)
    *   按位取反 = `0000 0000 0000 0001` (原码，值为1)
    *   所以 `b` 的值是 `-1`。
- 涉及不同位宽的转换
	- 
		-  ```c
    int i = -1;
    unsigned short usi = i;
    // 问 usi 的值是多少？
    ```
    *   **解析**：假设 `int` 是32位。`-1` 的32位补码是 `1111....1111` (32个1)。当赋给16位的 `unsigned short` 时，会发生**截断**，只保留低16位。所以 `usi` 得到 `1111 1111 1111 1111`，其值为 `65535`。
- 混合类型算术运算中的隐式转换
	- ```c
    int i = -1;
    unsigned int u = 0;
    if (i < u) {
        printf("i < u");
    } else {
        printf("i >= u");
    }
    ```
    *   **解析**：当有符号数和无符号数进行比较时，C语言的"寻常算术转换"规则会将有符号数 `i` 隐式地转换为无符号数。
    *   `i` 的值是 `-1`，其32位补码是 `0xFFFFFFFF`。
    *   当 `-1` 被转换为 `unsigned int` 时，它变成了 $2^{32}-1$，一个非常大的正数。
    *   因此，比较变成了 `(一个很大的正数 < 0)`，这个条件为假。程序会输出 `i >= u`。


![[2016-exam-paper-ocr.pdf#page=2&rect=79,296,522,358|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042015.png]]
[[Pasted image 20250930042022.png]]
- 这道题的核心是考察计算机中多字节数据（例如`double`类型）在内存中的存储方式，具体来说是**字节序（Endianness）** 的概念
- [[字节序]]
#小端模式 
 1. 根据小端模式的规则，我们需要将数据的字节**倒序**存入内存。

	*   数据的字节顺序（从高到低）：`11`, `22`, `33`, `44`, `55`, `66`, `77`, `88`
	*   内存地址顺序（从低到高）：`8040H`, `8041H`, `8042H`, `8043H`, `8044H`, `8045H`, `8046H`, `8047H`
	
	现在我们将字节逐一映射到内存地址：
	
	| 内存地址 | 存放内容 | 说明 |
	| :--- | :--- | :--- |
	| `0000 8040H` | `88H` | 存放最低位字节 (LSB) |
	| `0000 8041H` | `77H` | |
	| `0000 8042H` | `66H` | |
	| `0000 8043H` | `55H` | |
	| `0000 8044H` | `44H` | |
	| `0000 8045H` | `33H` | |
	| **`0000 8046H`** | **`22H`** | **<-- 题目所问** |
	| `0000 8047H` | `11H` | 存放最高位字节 (MSB) |
	
	从上表可以清晰地看到，地址为`0000 8046H`的存储单元中存放的内容是`22H`。因此，正确答案是 **A. 22H**。

 - 衍生 
	 - 数据对齐 
		 -    **对齐规则：**
	        1.  结构体中每个成员的偏移量（offset）必须是其自身大小的整数倍。
	        2.  结构体的总大小必须是其所有成员中**最大对齐模数**的整数倍。
	    *   **示例：**
	        ```c
	        struct Example {
	            char a;     // 1字节
	            int b;      // 4字节
	            short c;    // 2字节
	        };
	        ```
	        在32位系统中，`sizeof(struct Example)`通常是12字节，而不是 $1+4+2=7$ 字节。
	        *   `a` 存放在偏移量0处 (1字节)。
	        *   `b` 是4字节，需对齐到4的倍数，所以编译器在`a`后面填充3个字节。`b`存放在偏移量4处 (4字节)。
	        *   `c` 是2字节，需对齐到2的倍数，当前偏移量为8，是2的倍数。`c`存放在偏移量8处 (2字节)。
	        *   结构体总大小需是最大对齐模数（`int`的4字节）的倍数。当前大小为10字节，不是4的倍数，所以再填充2个字节，最终总大小为12字节。
	* 计算机字长 
		*    **寻址能力：** 如果地址总线的宽度等于字长，那么一个32位系统的 #最大寻址空间 就是$2^{32}$个地址单元。如果按字节编址，最大可寻址内存就是 $2^{32}$ B = 4 GB。  #可寻址空间 
	    *   **数据类型大小：** 字长会影响`int`, `long`, 指针等数据类型的默认大小。在32位系统中，`int`和指针通常是32位（4字节）；在64位系统中，它们通常是64位（8字节），但`int`也可能保持32位。这个问题需要根据具体的编程环境和规范来确定。 
	    *   **注意：** 在本题中，“32位字长”这个信息与`double`（64位）的存储并不直接冲突，它可能描述的是CPU的通用寄存器大小，而浮点运算单元（FPU）可以有不同大小的寄存器（如80位或128位）来处理`double`类型。所以这个信息在本题中可以看作是一个背景条件，并不影响字节序的判断。
	




![[2016-exam-paper-ocr.pdf#page=2&rect=82,190,525,296|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042029.png]]
#Cache命中率 [[Cache命中率]]
#Cache命中率计算  
$命中率_A = \frac{命中次数}{总访问次数}$
[[地址映射方式]]
#直接映射  
- **Cache 配置**:
    *   **类型**: 数据 Cache (Data Cache)
    *   **映射方式**: 直接映射 (Direct Mapped)
    *   **总大小**: 1KB (1024 字节)
    *   **块大小 (Block Size / Line Size)**: 16 字节 (16B)
1. 第一步：分析 #内存访问模式 
	1. 在循环体 `a[k] = a[k] + 32;` 中，对数组 `a` 进行了两次访问：
		1.  **读操作**: 从内存中读取 `a[k]` 的值（在表达式的右侧）。
		2.  **写操作**: 将计算结果 `a[k] + 32` 写回到 `a[k]` 的位置（在表达式的左侧）。
2. 第二步：理解 #Cache块和数据存放关系  
	1. Cache与主存之间的数据交换单位是 **块(Block)**。当发生Cache缺失(Miss)时，CPU会从主存中加载一整个数据块到Cache中，而不是仅仅加载所需要的那一个数据。这是利用了程序的 #空间局部性原理 ，即如果一个存储单元被访问，那么它附近的单元也很有可能在短时间内被访问。 #事件局限性 
		1. $每块存放的整数个数 = \frac{\text{块大小}}{\text{单个整数大小}} = \frac{16B}{4B} = 4 \text{ 个}$ 
3. 第三步：模拟循环过程，分析Cache命中/缺失情况
	1. 每4个元素（即一个Cache块的数据量）为一个分析周期  
	*   **当 k = 0 时:**
	    1.  **读 `a[0]`**: Cache初始为空，所以这必然是一次 **缺失 (Miss)**。
	    2.  **处理缺失**: 系统从主存中将包含 `a[0]` 的整个块（即包含`a[0], a[1], a[2], a[3]`的数据块）加载到Cache中。
	    3.  **写 `a[0]`**: 此时包含 `a[0]` 的数据块已经在Cache里了，所以这次写操作是 **命中 (Hit)**。
	
	*   **当 k = 1 时:**
	    1.  **读 `a[1]`**: 因为上一步已经将包含`a[0]`到`a[3]`的块加载到Cache中，所以`a[1]`已经在Cache里。这是一次 **命中 (Hit)**。
	    2.  **写 `a[1]`**: 同样是 **命中 (Hit)**。
	
	*   **当 k = 2 和 k = 3 时:**
	    *   对 `a[2]` 和 `a[3]` 的读、写操作也都是 **命中 (Hit)**。
	
	*   **当 k = 4 时:**
	    1.  **读 `a[4]`**: `a[4]` 位于一个新的数据块中，这个块当前不在Cache里。因此，这是一次 **缺失 (Miss)**。
	    2.  **处理缺失**: 系统从主存加载包含`a[4], a[5], a[6], a[7]`的新数据块到Cache中。
	    3.  **写 `a[4]`**: 此时新块已在Cache中，所以是 **命中 (Hit)**。
	**规律总结**:
	我们可以看到一个清晰的模式：对于每4个连续的数组元素（`a[0]`-`a[3]`, `a[4]`-`a[7]`, ...），总共会发生 $4 \times 2 = 8$ 次访问。在这8次访问中，只有第一次（即读取 `a[0]`, `a[4]`, `a[8]`...）是缺失，其余7次都是命中。
1. 第四步：计算总缺失率 
	1. $缺失率 = \frac{\text{缺失次数}}{\text{总访问次数}} = \frac{1}{8}$ 
		1. 将这个分数转换为百分比：
			$缺失率 = \frac{1}{8} = 0.125 = 12.5\%$
	2. 关于“直接映射”和“Cache大小为1KB”的说明 
		1. 在本题的特定访问模式（严格的顺序访问）下，这两个条件不会影响最终结果。因为数组是顺序访问的，我们永远不会在访问 `a[i]` 之后回头去访问一个很早之前的元素 `a[j]` (其中 `i-j` 很大)。所以，虽然数组大小 (1000 * 4B = 4KB) 大于Cache大小 (1KB)，可能会导致之前加载的Cache块被覆盖（这称为**冲突缺失**或**容量缺失**），但在本题的顺序访问模式下，被覆盖的块我们刚好不再需要了。因此，本题中所有的缺失都是第一次访问数据块时发生的 **强制性缺失

- 衍生 
	- 改变 #访问步长
		-   **代码**: `a[k] = a[k*4] + 32;` (k从0到249)
		    *   **分析**: 访问的元素是 `a[0], a[4], a[8], ...`。每次访问的地址间隔为 $4 \times 4B = 16B$，正好等于一个Cache块的大小。这意味着每次访问 `a[k*4]` 都是一个新块的开始。
		    *   **结果**:
		        *   读 `a[k*4]`: **Miss** (加载一个新块)。
		        *   写 `a[k*4]`: **Hit** (因为块刚被加载)。
		        *   每次循环2次访问，1次Miss，缺失率为 $1/2 = 50\%$。
	- 二维数组的访问顺序(行主序 vs 列主序)
		-  **代码 (行主序访问)**:
	        ```c
	        int x[100][100];
	        for(i=0; i<100; i++)
	          for(j=0; j<100; j++)
	            x[i][j] = 0;
	        ```
	    *   **分析**: C语言中数组按行主序存储，即 `x[i][j]` 和 `x[i][j+1]` 在内存中是相邻的。这种访问方式与内存布局一致，空间局部性极好，缺失率会很低（类似于本题）。
	    *   **代码 (列主序访问)**:
	        ```c
	        for(j=0; j<100; j++)
	          for(i=0; i<100; i++)
	            x[i][j] = 0;
	        ```
	    *   **分析**: 访问顺序是 `x[0][0], x[1][0], x[2][0], ...`。`x[i][j]` 和 `x[i+1][j]` 在内存中相隔了整整一行（100个`int`，即400字节）。这个步长远大于Cache块大小(16B)，导致每次访问几乎都是一次Cache Miss，缺失率会非常高。
	- 改变 #Cache映射方式  [[地址映射方式]] 
		- 如果题目改为 **全相联映射 (Fully Associative)**，则可以避免冲突缺失。对于本题，结果不变。但对于访问模式复杂的程序，全相联映射的缺失率通常更低。
	    *   如果改为 **组相联映射 (Set-Associative)**，则需要分析数据块会映射到哪个组，以及组内是否会发生冲突。这是直接映射和全相联映射的折中


![[2016-exam-paper-ocr.pdf#page=2&rect=82,142,526,193|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042035.png]]

[[计算物理地址位数]]
[[字节，比特，十六进制]]
[[RAM和ROM的区别]] 
[[SRAM与DRAM对比]] 
#SRAM
1. 第一步：计算ROM和RAM的容量 
	1. **计算ROM区的容量**
	    *   ROM的地址范围是 4000H 到 5FFFH（H代表十六进制）。
	    *   计算地址空间大小的公式是：末地址 - 首地址 + 1。
	    *   进行十六进制减法：
	        $5FFF\text{H} - 4000\text{H} = 1FFF\text{H}$
	    *   然后加1：
	        $1FFF\text{H} + 1 = 2000\text{H}$
	    *   所以ROM区共有 $2000\text{H}$ 个地址。因为是按字节编址，所以ROM的容量就是 $2000\text{H}$ 字节。
	    *   现在我们将十六进制的容量转换为我们熟悉的KB单位：[[按字节编址]]   
	        $2000_{16} = 2 \times 16^3 = 2 \times 4096 = 8192$
	    *   因为 $1\text{KB} = 1024\text{B}$，所以：
	        $8192\text{B} / 1024\text{B/KB} = 8\text{KB}$
	    *   因此，ROM区的容量为 **8KB**
	2. **计算RAM区的容量**
	    *   总存储容量为64KB。
	    *   ROM区占用了8KB。
	    *   剩余的部分都是RAM区，所以RAM区的容量为：
	        $64\text{KB} - 8\text{KB} = 56\text{KB}$
	    *   因此，我们需要设计的RAM区的总容量为 **56KB**。
2. 第二步：计算所需的SRAM芯片数量  
	1. 用 8K × 4位 的SRAM芯片来构成一个 56KB 的RAM区。这里涉及到 #存储器的位扩展和字扩展 #位扩展字扩展 [[存储器扩展]]
		- **目标RAM规格**：容量为56KB。由于系统是按字节编址，数据总线的宽度通常是字节的倍数，这里我们默认是按字节存取，即数据宽度为8位。所以目标是构建一个 56K × 8位 的存储空间。
		*   **SRAM芯片规格**：8K × 4位。这表示每个芯片有8K（$8 \times 1024 = 8192$）个存储单元，每个单元可以存储4位数据。
- 方法一：总容量相除法  
	1. 用目标总容量除以单个芯片的容量。为了避免单位混淆，我们都换算成“位”  
		1.  **目标RAM总位数**：
		    $56\text{KB} = 56 \times 1024 \text{ Bytes} = 56 \times 1024 \times 8 \text{ bits}$
		2.  **单个SRAM芯片的总位数**：
		    $8\text{K} \times 4 \text{位} = 8 \times 1024 \times 4 \text{ bits}$
		3.  **计算所需芯片数量**：
		    $\text{芯片数量} = \frac{\text{目标总位数}}{\text{单个芯片总位数}} = \frac{56 \times 1024 \times 8}{8 \times 1024 \times 4}$
		    我们可以消去 $1024$：
		    $\text{芯片数量} = \frac{56 \times 8}{8 \times 4} = \frac{56}{4} = 14$
- 方法二：位扩展和字扩展组合法  
	1. 位扩展（增加数据宽度）：
	    *   我们需要的数据宽度是8位（1字节）。
	    *   每个SRAM芯片的数据宽度是4位。
	    *   为了实现8位的数据宽度，我们需要将2个芯片并联。这样，当CPU访问一个地址时，可以同时从这2个芯片中各读出4位，合并成一个8位的数据。
	    *   所需并联芯片数 = $\frac{\text{目标数据宽度}}{\text{单芯片数据宽度}} = \frac{8\text{位}}{4\text{位}} = 2$ 个。
	    *   这两个芯片构成一个存储组（Bank），这个组的规格是 8K × 8位。

	2.  **字扩展（增加存储单元数）**：
		*   我们需要总共56K个存储单元（地址）。
		*   每个存储组（Bank）提供了8K个存储单元。
		*   为了达到56K的总容量，我们需要多个这样的存储组。
		*   所需存储组数量 = $\frac{\text{目标存储单元数}}{\text{每组的存储单元数}} = \frac{56\text{K}}{8\text{K}} = 7$ 组。
	
	3.  **计算总芯片数**：
		*   我们总共需要7个存储组，每个存储组由2个芯片构成。
		*   总芯片数量 = $(\text{字扩展所需的组数}) \times (\text{位扩展每组的芯片数}) = 7 \times 2 = 14$ 个。
- 衍生 
	- #地址译码器的设计 
		-   可能会问：要实现对上述7个RAM组的选择，需要几条地址线参与译码？应该如何设计译码电路？
	    *   **解答思路**：因为有7个组，我们需要能区分7个不同的对象。$2^2 < 7 < 2^3$，所以至少需要3条地址线来做译码（例如，使用一个3-8译码器，只用其中7个输出即可）
	* 具体的 #地址线分配
		* 可能会问：对于 8K × 4位 的芯片，其内部地址线有多少根？连接到CPU地址总线的哪些线上？哪些CPU地址线用于片选？
	    *   **解答思路**：一个8K容量的芯片，需要 $log_2(8K) = log_2(8 \times 1024) = log_2(2^3 \times 2^{10}) = log_2(2^{13}) = 13$ 根地址线（如A0-A12）。这些线会直接连接到CPU地址总线的低13位。而CPU地址总线中更高位的地址线（如A13, A14, A15等）则会进入地址译码器，用于生成片选信号，以选择不同的芯片组













![[2016-exam-paper-ocr.pdf#page=2&rect=76,64,532,139|2016-exam-paper-ocr, p.2]]
[[Pasted image 20250930042105.png]]
[[指令格式]]  
[[指令寻址方式]]

- #变址寻址的核心    [[变址寻址]] 
	 如果用 `I` 代表变址寄存器，`(I)` 代表变址寄存器的**内容**，`D` 代表形式地址，那么变址寻址的有效地址 `EA` 的计算公式为：
        $EA = (I) + D$
- #间接寻址  
	- 如果 `A` 是指令中的地址字段，那么间接寻址的有效地址 `EA` 计算公式为：
        $EA = (A)$
        这里的 `(A)` 表示取内存地址为 `A` 的单元中的**内容**
#形式地址 
1. 第一步：先变址 
	1. 我们首先执行变址操作。根据变址寻址的定义，我们需要将变址寄存器 `I` 的内容 `(I)` 与形式地址 `D` 相加。
	    *   这一步计算出的结果是一个**中间地址**，我们称之为 `Addr_temp`。
	    *   计算公式为：$Addr\_temp = (I) + D$
	2. 第二步：后间址
		- 对上一步得到的中间地址 `Addr_temp` 执行间接寻址操作
		- 这意味着 `Addr_temp` 并不是最终操作数的地址，而是**存放最终有效地址的那个内存单元的地址**。
		    *   因此，我们需要访问内存地址为 `Addr_temp` 的单元，取出其内容，这个内容才是我们需要的最终有效地址 `EA`。
		    *   用公式表示就是：$EA = (Addr\_temp)$
		    *   将第一步的 `Addr_temp` 代入，我们得到最终的有效地址计算公式：
		        $EA = ((I) + D)$
- 衍生  
	- 先间址后变址
		*   **第一步：先间址 (Indirect First)**
		    *   首先对指令中的形式地址 `D` 进行间接寻址。这意味着 `D` 指向一个内存地址，该地址中存放着一个基地址。
		    *   我们取出这个基地址：$(D)$
		*   **第二步：后变址 (Index Next)**
		    *   然后，将上一步得到的基地址 $(D)$ 与变址寄存器 `I` 的内容 $(I)$ 相加，得到最终的有效地址。
		    *   最终的有效地址公式为：$EA = (D) + (I)$
		
		








![[2016-exam-paper-ocr.pdf#page=3&rect=77,766,520,820|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042111.png]]
- 这道题目考察的是 #计算机组成原理 中两个 #核心寄存器 ：**程序计数器 (PC)** 和 **指令寄存器 (IR)** 的作用和位数确定方法
[[程序计数器PC]] #指令寄存器IR  
1. #程序计数器PC  #程序计数器PC位数的计算 
	1. **PC 的功能:** PC (Program Counter) 的作用是存放**下一条待执行指令的地址**。因此，PC 的位数取决于它需要表示多少个不同的指令地址。
	2.  **地址空间分析:**
	    *   计算机是“按字节编址”，意味着内存中的每一个字节（Byte）都有一个唯一的地址。
	    *   主存总容量为 4GB。我们来计算总共有多少个字节：
	        $4GB = 4 \times 2^{30} \text{Bytes} = 2^2 \times 2^{30} \text{Bytes} = 2^{32} \text{Bytes}$
	    *   这意味着，要唯一标识内存中的每一个字节，需要 32 位的地址。例如，地址从 `00...00` (32个0) 到 `11...11` (32个1)。所以，内存地址寄存器 (MAR) 需要 32 位
	3. “指令按字边界对齐存放”
		1. 字长是 32 位，即 4 字节。
		    *   “按字对齐”意味着每条指令的起始地址必须是 4 的倍数。
		    *   例如，第一条指令地址是 0，第二条是 4，第三条是 8，以此类推。地址不可能是 1, 2, 3, 5, 6, 7 等。
		    *   我们观察这些地址的二进制形式：
		        *   地址 0: `000...0000`
		        *   地址 4: `000...0100`
		        *   地址 8: `000...1000`
		        *   地址 12: `000...1100`
		    *   可以发现，这些地址的**最低两位永远是 `00`**。
		    *   既然 PC 存放的是指令地址，而指令地址的最低两位总是固定的 `00`，那么这两位信息就无需在 PC 中存储。硬件可以在将 PC 的内容发送到地址总线之前，自动在末尾补上两个 `0`。
		    *   因此，PC 实际需要存储的只是地址中变化的部分，即高位的地址。
    *   PC 的位数 = 总地址位数 - 固定的低位数 = $32 - 2 = 30$ 位
    * 另一种思路
	    * 这种方法是计算内存中可以存放多少条指令。
	    *   总内存大小 = $2^{32}$ 字节。
	    *   每条指令大小 = 32 位 = 4 字节。
	    *   可存放的指令数量 = (总内存字节数) / (每条指令的字节数) = $2^{32} / 4 = 2^{32} / 2^2 = 2^{30}$ 条。
	    *   PC 的作用是需要能够指向这 $2^{30}$ 条指令中的任意一条。为了给 $2^{30}$ 个不同的位置进行编号，我们至少需要 $N$ 位，满足 $2^N \ge 2^{30}$。
	    *   因此，最小的 $N$ 是 30。所以 PC 至少需要 30 位
2. #指令寄存器IR  #指令寄存器IR位数的计算 
	1. #IR的功能:  IR (Instruction Register) 的作用是存放**从内存中取出（fetch）的指令本身**。当 CPU 从 PC 指示的地址读取指令后，这条指令会被加载到 IR 中，以供后续的译码和执行。
	*   **位数确定:**
	    *   IR 的大小必须足以容纳一条完整的指令。
	    *   题目明确指出，采用“32 位字长指令字格式”，这意味着每条指令的长度都是 32 位。
	    *   因此，为了完整地保存这条指令，IR 的位数至少需要 32 位。
- 衍生 
	- [[PC-MAR-MDR的关系与区别]] 
	- 变长指令集 
		-  本题是定长指令。如果题目是**变长指令集**（例如，指令长度可以是 16 位、32 位或 48 位），那么：
	        *   IR 的位数必须等于**最长指令**的长度，以确保能容纳任何可能的指令。
	        *   PC 的增量逻辑会变得复杂。执行完一条指令后，PC 不再是简单地 $PC+4$，而是需要根据当前指令的长度来增加，例如 $PC+2$、$PC+4$ 或 $PC+6$（假设按半字对齐）。
	- 内存容量的逆向计算 
		-  本题是定长指令。如果题目是**变长指令集**（例如，指令长度可以是 16 位、32 位或 48 位），那么：
	        *   题目可能会反过来问：一个计算机的 MAR 是 24 位，MDR 是 16 位，按字节编址，那么它的最大寻址空间是多少？
		    *   **解答:** MAR 的位数决定了地址总线的宽度，从而决定了最大寻址空间。24 位的 MAR 可以表示 $2^{24}$ 个不同的地址。因为是按字节编址，所以最大寻址空间就是 $2^{24}$ 字节 = 16 MB。MDR 的 16 位表示数据总线的宽度是 16 位，即字长是 16 位，这影响数据传输效率，但不影响寻址空间大小。

![[2016-exam-paper-ocr.pdf#page=3&rect=75,692,526,770|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042117.png]]
[[数据冒险的解决方案]]
[[流水线冒险]] 
[[“流水线冒险”与“流水线冲突”的区别]]
#写后读RAW 
1. 


![[2016-exam-paper-ocr.pdf#page=3&rect=80,629,523,692|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042123.png]]
[[Pasted image 20250930042131.png]]

#单周期处理器 
[[计算机性能评测的四个指标]] 
#控制信号 
#时钟频率  [[CPU主频]]




![[2016-exam-paper-ocr.pdf#page=3&rect=78,581,513,631|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042137.png]]

[[串行和并行总线的区别]]  
2. #线路复用  
	1. 信号线复用（或称时分复用）是指在不同的时间段内，让同一组物理线路传输不同类型的信息。一个典型的例子就是地址/数据总线复用，即同一组线路先用来传输地址信号，稍后再用来传输数据信号。这样做的好处是显著减少了芯片的引脚数量和电路板的布线复杂度，从而节省了空间和成本
3. #突发传输的主要优势 [[突发传输]]
	1.  突发传输（Burst Transfer）是指在总线上，一次只发送一个起始地址，然后连续传输多个位于连续存储地址的数据块。
4. #总线事务  
	1. #分离事务通信 #总线通信协议  
		1. 分离事务（Split Transaction）是一种先进的总线通信协议。在传统的请求-响应模式中，一个设备（主设备）发起请求（如读内存）后，会一直占用总线，直到另一个设备（从设备）准备好数据并返回。
			1. 如果从设备速度很慢，总线就会被长时间闲置。在分离事务中，主设备发起请求后会立即释放总线，让其他设备可以使用。当从设备准备好数据后，它会重新申请总线，将数据返回给主设备 
			2. 这个过程将一个完整的事务分成了“请求”和“响应”两个独立的子事务，极大地提高了总线在等待慢速设备期间的利用率
#信道利用率 [[数据链路层的信道利用率（有效数据传输速率）]]  

- 衍生 
	-  #总线仲裁  
		- 当总线上有多个主设备（如CPU、DMA控制器）都想使用总线时，需要一种机制来决定谁获得使用权，这就是总线仲裁
	- #总线定时  [[总线定时]]
		- 指总线上信号的同步和时序控制 
	- [[常见的总线标准]]  
		- 考试可能会要求你识别哪些是并行总线，哪些是串行总线，并比较它们的特点 
	- [[总线带宽计算]]  
		- 这是非常经典的计算题。例如：一个32位宽，工作频率为133MHz的PCI总线，其理论峰值带宽是多少？
		    *   计算：$带宽 = \frac{32 \text{ bit}}{8 \text{ bit/B}} \times 133 \times 10^6 \text{ Hz} = 4 \text{ B} \times 133 \times 10^6 \text{ /s} = 532 \times 10^6 \text{ B/s} = 532 \text{ MB/s}$


![[2016-exam-paper-ocr.pdf#page=3&rect=74,520,521,581|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042144.png]]

[[区分中断、异常和系统调用]]
#存储保护错 
1. 发生于 CPU 执行一条指令，试图访问一个它没有权限访问的内存地址时（例如，用户态程序试图写入内核空间）。这个错误的检测发生在指令执行的地址翻译阶段，是**执行该指令的直接结果**，因此源于处理器**内部**
- 衍生 
	- [[中断开销]] 
	1. 中断处理本身是有开销的，称为中断开销（Interrupt Overhead）。如果中断发生得过于频繁，会显著影响系统性能。


![[2016-exam-paper-ocr.pdf#page=3&rect=78,445,476,519|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042159.png]]

#批处理系统  
#多道批处理系统  
A
- 衍生 
	- 操作系统的发展与分类 
		- 批处理系统 (单道 -> 多道) -> 分时系统 -> 实时系统 -> 网络操作系统 -> 分布式操作系统 -> 嵌入式系统 
	- #CPU利用率 的计算 
		- 假设有 $n$ 个程序并发执行，每个程序因 I/O 操作而等待的时间占其总运行时间的比例为 $p$。
	        *   一个程序处于等待状态的概率是 $p$。
	        *   $n$ 个程序**同时**都处于等待状态的概率是 $p^n$ (假设各程序独立)。
	        *   CPU 处于空闲状态的概率就是所有程序都处于等待状态的概率，即 $P_{idle} = p^n$。
	        *   因此，CPU 的利用率（CPU Utilization）为：
	            $U_{CPU} = 1 - P_{idle} = 1 - p^n$
	        *   **示例**：若一个程序有 50% 的时间在等待 I/O (即 $p=0.5$)，当只有 1 个程序时 (单道)，CPU 利用率为 $1 - 0.5^1 = 50\%$. 如果有 4 个程序 (多道)，CPU 利用率将提高到 $1 - 0.5^4 = 1 - 0.0625 = 93.75\%$。
[[进程状态模型]]


![[2016-exam-paper-ocr.pdf#page=3&rect=79,381,518,444|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042208.png]]
#甘特图 

为了使总时间最短，我们应该让各个设备尽可能地“忙碌”起来，减少空闲时间。调度原则如下：
1.  按作业1、作业2、作业3的顺序依次投入输入设备。
2.  一个作业的后一阶段，必须在其前一阶段完成后，并且所需设备空闲时，才能开始。

当作业3的输出任务在第17ms结束时，所有三个作业都已完成。因此，执行完3个作业需要的最少时间是 **17ms**。

- 衍生 
	- #抢占式调度 vs. #非抢占式调度
		-    如果题目允许**抢占**（Preemption），例如一个更高优先级的作业可以中断当前正在CPU上计算的作业，那么调度策略会完全不同，通常会结合优先级、时间片轮转等算法。
		-    对于两个设备（例如只有输入和计算）的 #流式调度 问题，可以使用 #约翰逊算法 来找到最优排序。 
		    *   对于三个或以上设备的问题，它是一个NP-hard问题，没有简单的最优解法，通常会考察一些启发式算法或在简单情况下寻找最优解。





![[2016-exam-paper-ocr.pdf#page=3&rect=80,319,521,383|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042216.png]]

#死锁   
#画图   [[死锁产生的四个条件]]  
1. **分析3个进程是否会死锁：**  #死锁状态的进程 
    *   我们选择 $p_1, p_2, p_3$ 这三个进程。它们的资源需求呈现出一种“环形”的依赖关系：
        *   $p_1$ 和 $p_2$ 共同需要 $R_2$。
        *   $p_2$ 和 $p_3$ 共同需要 $R_3$。
        *   $p_3$ 和 $p_1$ 共同需要 $R_1$。
    *   这种结构是产生循环等待的“温床”。我们可以构造一个导致死锁的资源分配序列：
        1.  系统将资源 $R_1$ 分配给进程 $p_1$。此时 $p_1$ 持有 $R_1$，等待 $R_2$。
        2.  系统将资源 $R_2$ 分配给进程 $p_2$。此时 $p_2$ 持有 $R_2$，等待 $R_3$。
        3.  系统将资源 $R_3$ 分配给进程 $p_3$。此时 $p_3$ 持有 $R_3$，等待 $R_1$。
    *   现在，我们来分析系统的状态：
        *   $p_1$ 持有 $R_1$，正在等待 $R_2$，而 $R_2$ 正被 $p_2$ 持有。
        *   $p_2$ 持有 $R_2$，正在等待 $R_3$，而 $R_3$ 正被 $p_3$ 持有。
        *   $p_3$ 持有 $R_3$，正在等待 $R_1$，而 $R_1$ 正被 $p_1$ 持有。
    *   这形成了一个完美的循环等待链： $p_1 \rightarrow p_2 \rightarrow p_3 \rightarrow p_1$。
    *   此时，这三个进程都无法继续执行，也无法释放资源，系统陷入死锁。由于我们找到了一个由3个进程构成的死锁场景，并且已经排除了1个和2个进程的可能性，因此**处于死锁状态的进程数至少是3**。
	1.  **分析进程 $p_4$ 的作用：**
	    进程 $p_4$ 只需要一个资源 $R_2$。这样的进程永远不会满足“请求和保持”条件（因为它拿到 $R_2$ 后就可以直接运行结束，不需要再等待其他资源），因此 $p_4$ 本身不会成为死锁循环链中的一环。
- 衍生 
	- #哲学家就餐问题  
		- 考点: 这是一个经典的死锁同步问题模型。可能会要求你分析某种解决方案为何会（或不会）产生死锁，或者让你设计一个无死锁的解决方案 
	- [[死锁检测算法]]
		-  **考点:** 系统允许死锁发生，但能通过算法检测到它，并采取措施进行恢复。
		*   **检测方法:** 通常使用**资源分配图 (Resource-Allocation Graph)** 来检测是否存在循环。如果图中出现环路，则可能存在死锁。
		*   **恢复策略:**
		    *   **进程终止:** 强行终止一个或多个死锁进程。
		    *   **资源剥夺:** 从一个或多个进程中抢占资源分配给其他进程。
		*   **例题:** 给出一张 #资源分配图 ，判断图中是否存在死锁。或者，描述一个系统状态，要求你画出资源分配图。
	- #死锁避免  #死锁避免的核心  
		-  **考点:** 在资源分配过程中，使用某种算法（如**银行家算法 (Banker's Algorithm)**）来判断此次分配是否会导致系统进入不安全状态，从而避免进入可能导致死锁的区域。
		- **例题:** 给出系统的总资源数、各进程的最大需求和当前已分配资源，判断当前系统是否处于安全状态，或者某个进程的新请求是否可以被满足。
	    *   例如，给定一个状态，要求你找出一个**安全序列 (Safe Sequence)**。
![[2016-exam-paper-ocr.pdf#page=3&rect=77,227,526,319|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042223.png]]
[[Pasted image 20250930042228.png]]

[[时钟算法]]
#CLOCK算法  
1. 



![[2016-exam-paper-ocr.pdf#page=3&rect=78,35,527,229|2016-exam-paper-ocr, p.3]]
[[Pasted image 20250930042234.png]]


#临界区  
- #让权等待 #同步准则  [[实现互斥的机制]]   #TSL互斥 

#关中断指令  






![[2016-exam-paper-ocr.pdf#page=4&rect=73,709,488,825|2016-exam-paper-ocr, p.4]]
[[Pasted image 20250930042243.png]]








![[Pasted image 20250930042416.png]]
[[Pasted image 20250930042257.png]]
[[工作集模型]] 







![[2016-exam-paper-ocr.pdf#page=4&rect=64,344,534,528|2016-exam-paper-ocr, p.4]]
[[截屏2025-09-30 上午4.24.42.png]]
[[截屏2025-09-30 上午4.24.48.png]]








![[2016-exam-paper-ocr.pdf#page=4&rect=76,269,357,344|2016-exam-paper-ocr, p.4]]
[[截屏2025-09-30 上午4.24.54.png]]





![[2016-exam-paper-ocr.pdf#page=4&rect=75,206,516,272|2016-exam-paper-ocr, p.4]]
[[截屏2025-09-30 上午4.25.03.png]]






![[2016-exam-paper-ocr.pdf#page=4&rect=74,161,473,211|2016-exam-paper-ocr, p.4]]
[[Pasted image 20250930042548.png]]






![[2016-exam-paper-ocr.pdf#page=5&rect=70,553,550,824|2016-exam-paper-ocr, p.5]]
[[Pasted image 20250930042556.png]]







![[2016-exam-paper-ocr.pdf#page=5&rect=75,502,520,552|2016-exam-paper-ocr, p.5]]
[[Pasted image 20250930042605.png]]
[[Pasted image 20250930042622.png]]








![[2016-exam-paper-ocr.pdf#page=5&rect=74,455,524,503|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042634.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=74,405,520,457|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042639.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=75,344,516,406|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042644.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=80,268,521,345|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042650.png]]


![[2016-exam-paper-ocr.pdf#page=5&rect=81,202,515,270|2016-exam-paper-ocr, p.5]]
![[Pasted image 20250930042658.png]]


![[2016-exam-paper-ocr.pdf#page=6&rect=75,633,522,821|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042706.png]]
![[Pasted image 20250930042714.png]]

![[2016-exam-paper-ocr.pdf#page=6&rect=78,568,518,634|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042731.png]]


![[2016-exam-paper-ocr.pdf#page=6&rect=79,479,521,567|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042739.png]]
![[Pasted image 20250930042747.png]]![[Pasted image 20250930042807.png]]

![[2016-exam-paper-ocr.pdf#page=6&rect=75,261,527,480|2016-exam-paper-ocr, p.6]]
![[Pasted image 20250930042852.png]]


![[2016-exam-paper-ocr.pdf#page=7&rect=79,512,521,819|2016-exam-paper-ocr, p.7]]
![[Pasted image 20250930042904.png]]
![[Pasted image 20250930042930.png]]

![[2016-exam-paper-ocr.pdf#page=7&rect=78,390,524,514|2016-exam-paper-ocr, p.7]]
![[Pasted image 20250930042948.png]]
![[Pasted image 20250930042953.png]]

![[2016-exam-paper-ocr.pdf#page=7&rect=74,125,528,390|2016-exam-paper-ocr, p.7]]
![[Pasted image 20250930043006.png]]






