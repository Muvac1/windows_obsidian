![[2017-exam-paper-ocr.pdf#page=1&rect=70,596,549,705|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043154.png]]

[[时间复杂度分析]] 
[[时间复杂度等价]]
**1. 分析代码**

```c
int func(int n) {
    int i=0, sum=0;
    while(sum < n) {
        sum += ++i;
    }
    return i;
}
```

*   **初始化**：`i` 和 `sum` 都从0开始。
*   **循环条件**：循环持续的条件是 `sum < n`。当 `sum >= n` 时，循环终止。
*   **循环体**：`sum += ++i;`。这是一个关键操作。`++i` 是前置自增，意味着先将 `i` 的值加1，然后用新的 `i` 值参与运算。
    *   它等价于：
        ```c
        i = i + 1;
        sum = sum + i;
        ```
2. 
	*   **第1次循环**：`i` 变为1，`sum` = 0 + 1 = 1。
	*   **第2次循环**：`i` 变为2，`sum` = 1 + 2 = 3。
	*   **第3次循环**：`i` 变为3，`sum` = 3 + 3 = 6。
	*   ...
	*   **第k次循环**：`i` 变为 `k`，`sum` 的值是 $1 + 2 + 3 + \dots + k$。
3. $sum = \frac{k(k+1)}{2}$ 
	1. $\frac{k(k+1)}{2} \approx n$ 
	2. $k(k+1) \approx 2n$
		$k^2 + k \approx 2n$
	3. $k^2 \approx 2n$ 
	4. $k \approx \sqrt{2n} = \sqrt{2} \cdot \sqrt{n}$ 
4. 所以，循环的执行次数 `k` 与 $\sqrt{n}$ (即 $n^{1/2}$) 成正比  
5.  B. $O(n^{1/2})$ 

- 衍生    [[时间复杂度分析]]
	- [[++i vs. i++ 的时间复杂度影响]] 
		- 如果原题中的 `sum += ++i;` 改为 `sum += i++;`，时间复杂度会变吗？
			- **结论**：在渐近分析中，$k^2-k$ 和 $k^2+k$ 的主导项都是 $k^2$。因此，求解后得到的复杂度依然是 $O(\sqrt{n})$。在时间复杂度的大O分析层面，这两者没有区别，但这可能作为一个细节题来考察对自增运算符的理解。

![[2017-exam-paper-ocr.pdf#page=1&rect=76,509,503,599|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043159.png]]


[[栈]] 
#函数调用栈    
- 1 错误 
- I. 采用非递归的方式重写递归程序时必须用栈
	- 这个说法的关键在于“必须” (must) 这个词，过于绝对。虽然栈是实现递归转非递归的一种通用且强大的方法，因为它能完美模拟函数调用栈的行为（保存局部变量、返回地址等），但并非所有情况都必须用栈。
*   **反例：**
    1.  #尾递归  尾递归是一种特殊的递归形式，递归调用是函数的最后一步操作。这种递归可以被编译器优化，直接转换成一个简单的循环，完全不需要栈。
    2.  #简单递归 ： 像题目解析中提到的计算斐波那契数列或阶乘，虽然有递归定义，但它们的迭代版本（非递归）只需要几个变量和一个循环就可以实现，并不需要显式地使用一个栈结构。
- 2 正确    
	- II. 函数调用时，系统要用栈保存必要的信息[[堆栈帧]]
	3.  每当一个函数被调用时，系统会创建一个称为“栈帧” 或“活动记录”的数据块，并将其压入一个特定的内存区域，这个区域就是 #调用栈
		1. #栈帧 中保存了函数的参数、局部变量、返回地址 #堆栈帧
		2. [[递归与栈的关系]] 
- 衍生 
	- [[栈的应用]] 




![[2017-exam-paper-ocr.pdf#page=1&rect=75,462,436,509|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043205.png]]

 #稀疏矩阵  [[邻接矩阵，邻接表 ，稀疏图，稠密图]]  
#压缩存储   #不同的压缩存储方式   [[压缩存储]]
三元组表和十字链表是两种专门为压缩存储稀疏矩阵而设计的数据结构。邻接矩阵不属于压缩存储，而二叉链表则用于完全不同的数据类型。因此，正确答案是 **A**  
#三元组表  #十字链表  
- 衍生
	- [[稀疏矩阵的转置运算]]  #转置运算   
		- 原矩阵每一列的非零元个数，然后计算每一列第一个非零元在转置后三元组表中的起始位置。时间复杂度可以优化到 $O(n+t)$。这是面试和考试中的高频考点
	- [[稀疏矩阵的加法和乘法运算]] 
	- [[树和森林的存储结构]] 
	



![[2017-exam-paper-ocr.pdf#page=1&rect=75,424,517,460|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043209.png]]

#结点的度  #非叶结点   #先序序列   [[遍历序列的基本性质]]  [[序列相同的条件]] 
1. 推理过程 
	1. 用 `R` 代表根结点，`L` 代表左子树的遍历序列，`R_sub` 代表右子树的遍历序列。
		*   那么，这棵树的先序序列可以表示为：`R, L, R_sub`
		*   这棵树的中序序列可以表示为：`L, R, R_sub`
		
		*   要使这两个序列相同，即 `R, L, R_sub` = `L, R, R_sub`，我们来比较它们的第一个元素。
		*   在先序序列中，第一个元素永远是根结点 `R`。
		*   在中序序列中，第一个元素是左子树遍历序列 `L` 的第一个元素。
		*   为了让两个序列的第一个元素相同，中序序列的第一个元素也必须是根结点 `R`。这种情况只有在左子树的遍历序列 `L` 为**空**时才会发生。
		
		*   如果左子树为空，那么：
		    *   先序序列变为：`R, R_sub`
		    *   中序序列变为：`R, R_sub`
		    *   此时，两个序列就相同了。
		
		*   这个逻辑是**递归**的。也就是说，对于树中的**任意一个结点**（把它看作一个子树的根），要使其子树的先序和中序遍历相同，这个结点都**不能有左孩子**。
	2. 题目要求是“所有非叶结点须满足的条件”。非叶结点就是有孩子的结点。根据我们的推导，这些结点都不能有左孩子，所以它们只能有右孩子 
		1. 正确答案是 **B. 只有右子树**

	*   **A. 只有左子树：** 如果一个结点 `R` 只有左子树 `L`，那么先序是 `R, L`，中序是 `L, R`。这两个序列显然是相反的，不可能相同（除非树只有一个结点）。
	*   **C. 结点的度均为1：** 这个条件太宽泛。一个结点的度为1，意味着它要么只有左孩子，要么只有右孩子。如果存在一个结点只有左孩子，那么条件就不满足了。所以C是错误的。
	*   **D. 结点的度均为2：** 如果结点的度为2，意味着它既有左孩子又有右孩子，这直接违反了我们推导出的“左子树必须为空”的结论。

- 衍生 
	- [[序列相同的条件]] 
	-  [[根据遍历序列重建二叉树]] 
	- [[二叉树的性质]] 
		- 对于任意一棵非空二叉树，如果叶结点的数量为$n_0$，度为2的结点数量为$n_2$，那么它们之间存在一个恒定的关系：
				$n_0 = n_2 + 1$
	- [[层次遍历]]    
		- 除了深度优先的三种遍历，还有一种广度优先的遍历方式，即层次遍历 ， 通常使用**队列**数据结构来实现

![[Pasted image 20250930043248.png]]
[[Pasted image 20250930043226.png]]
 - 
#后序序列  #二叉树的后序遍历  
1. 后序遍历的规则是：**先遍历左子树，再遍历右子树，最后访问根结点** 
	1. 后序遍历序列的一个显著特点是，序列的最后一个元素一定是整棵树（或子树）的根结点
	2. B 
- 衍生 
	- [[线索二叉树]] 
		- 为了利用二叉树中大量的空指针域，将它们改造为指向结点前驱或后继的线索，从而方便遍历 




![[Pasted image 20251015110858.png]]
[[Pasted image 20250930043324.png]]

[[哈夫曼编码]]  
#字符集
1.  **性质**：哈夫曼编码是 #前缀编码 ，即任何一个字符的编码都不是另一个字符编码的前缀，这保证了编码在解码时不会产生歧义。
2.     `0100` -> 匹配成功！这是字符 **a** 的编码。
    *   剩余序列: `011001001011110101`
    *   `011` -> 匹配成功！这是字符 **g** 的编码。
    *   剩余序列: `001001011110101`
    *   `001` -> 匹配成功！这是字符 **e** 的编码。
    *   剩余序列: `001011110101`
    *   `001` -> 再次匹配成功！这是字符 **e** 的编码。
    *   剩余序列: `011110101`
	将解码出的字符拼接起来，得到的结果是 **`ageeghd`** 

- 衍生 
	- #计算WPL 
		- 在构建完哈夫曼树后，要求计算其带权路径长度。这既考察了建树过程，也考察了对最优性概念的理解 
	- #哈夫曼树的性质  [[哈夫曼树]]  
		- #编码的非唯一性 在构建树时，如果出现两个或以上权重相同的最小节点，选择哪两个进行合并是任意的，这可能导致构造出不同形态的哈夫曼树。 在为分支分配0和1时，左0右1或左1右0都是可以的。
		    *   因此，对于同一组权重，可能存在不同的哈夫曼编码方案，但它们的**WPL一定是相同且最小的**。

![[2017-exam-paper-ocr.pdf#page=1&rect=76,283,531,326|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043328.png]]

#顶点的度      

- [[握手定理（有无向图）]]  
	**无向图:** 所有顶点的度之和等于边数的两倍。 
	$\sum_{i=1}^{n} d(v_i) = 2|E|$

1. 根据握手定理，图中所有顶点的度数之和为：
	$\sum \text{deg}(v) = 2 \times |E| = 2 \times 16 = 32$
2. 计算已知顶点的度数和 
	 3 个度为 4 的顶点，它们的度数和为：$3 \times 4 = 12$
	*   4 个度为 3 的顶点，它们的度数和为：$4 \times 3 = 12$
	*   这些已知顶点的度数总和为：$12 + 12 = 24$
3. 计算剩余顶点的度数和
	1. 所有顶点的总度数和是 32，而已知顶点的度数和是 24。因此，剩下的“其他顶点”的度数总和必须是：
		$32 - 24 = 8$ 
4. 求解最少的顶点数 
	1. 用一些顶点来凑成 8 这个度数和。题目的约束是，这些“其他顶点”的度数都必须小于 3（即度数只能是 0, 1, 2）  
	2. 使顶点的数量**最少**，我们应该让每个新增加的顶点的度数**最大**。在小于 3 的度数中，最大的是 2 
5.   为了让 $x$ 最小，我们应该给这 $x$ 个顶点尽可能高的度数，即都设为 2。
	*   设这 $x$ 个顶点的度数均为 2，它们的度数和为 $2x$。
	*   所以，我们需要满足 $2x = 8$。
	*   解得 $x = 4$。
		* 我们至少需要 4 个“其他顶点”（这4个顶点的度数都为2）才能满足剩余的度数和为 8
6.  计算总顶点数 
	1. 现在把所有顶点数量加起来：
		*   度为 4 的顶点数：3
		*   度为 3 的顶点数：4
		*   其他顶点（度为2）的最少数：4
		*   总的最小顶点数 = $3 + 4 + 4 = 11$
- 衍生 
	- #奇数度顶点的性质 
		- 在任何无向图中，度数为奇数的顶点个数永远是**偶数**
			-  **考题形式：** “一个图有7个顶点，它们的度数分别是1, 2, 3, 3, 4, 4, x，求x的可能值”，或者“判断一个度数序列是否可能构成一个简单图”
	- #有向图的度数定理  
		对于有向图，每个顶点有**入度 (in-degree)** 和**出度 (out-degree)**。
		*   **定理：** 在任何有向图中，所有顶点的入度之和等于所有顶点的出度之和，且它们都等于图的边数。
		*   **公式：** $\sum_{v \in V} \text{deg}^-(v) = \sum_{v \in V} \text{deg}^+(v) = |E|$
	- [[图]] 

![[2017-exam-paper-ocr.pdf#page=1&rect=73,141,450,280|2017-exam-paper-ocr, p.1]]
![[Pasted image 20250930043334.png]]  

[[二分查找]]  
#折半查找判定树  #二叉树入门题目 
假设要构建的树是基于有序序列 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` 
  1.   第一步：为选项中的树节点赋值
	1. 对每个选项的树结构进行 #中序遍历 ，并依次填上 1 到 10 
	2. 中序遍历得到的节点顺序是 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 
2. 第二步：逐一验证每个选项是否符合单一的构建规则
	1.  验证选项 A 
		1. **根节点**: 6
			*   **初始序列**: `[1, 10]`
			*   要得到根节点 6，中间下标的计算必须是：$mid = \lceil \frac{1+10}{2} \rceil = \lceil 5.5 \rceil = 6$
			* 因此，我们假设选项 A 是基于**向上取整**规则构建的，并验证其所有子树 
			    *   **左子树 (节点 3)**: 根为 6，左子树的序列范围是 `[1, 5]`。
			        *   $mid = \lceil \frac{1+5}{2} \rceil = \lceil 3 \rceil = 3$。与图中节点 3 匹配。**规则一致**。
			    *   **右子树 (节点 9)**: 根为 6，右子树的序列范围是 `[7, 10]`。
			        *   $mid = \lceil \frac{7+10}{2} \rceil = \lceil 8.5 \rceil = 9$。与图中节点 9 匹配。**规则一致**。
			    *   **节点 3 的右子树 (节点 5)**: 序列范围是 `[4, 5]`。
			        *   $mid = \lceil \frac{4+5}{2} \rceil = \lceil 4.5 \rceil = 5$。与图中节点 5 匹配。**规则一致**。
			    *   **节点 9 的左子树 (节点 8)**: 序列范围是 `[7, 8]`。
			        *   $mid = \lceil \frac{7+8}{2} \rceil = \lceil 7.5 \rceil = 8$。与图中节点 8 匹配。**规则一致**。
			
			经过验证，选项 A 的所有节点都符合**向上取整**这一单一规则。因此，**A 是一个有效的折半查找判定树**
	2. 验证选项 B
			**根节点**: 6。同样，这要求使用**向上取整**规则。
		*   我们来查找矛盾点（即不符合向上取整规则的地方）。
		    *   **节点 3 的右子树 (节点 5)**: 序列范围 `[4, 5]`。
		        *   $mid = \lceil \frac{4+5}{2} \rceil = 5$。匹配。
		    *   **节点 9 的左子树 (节点 7)**: 序列范围 `[7, 8]`。
		        *   根据向上取整规则，中间值应为 $mid = \lceil \frac{7+8}{2} \rceil = 8$。
		        *   但图 B 中该节点的值是 7，这实际上是向下取整 $mid = \lfloor \frac{7+8}{2} \rfloor = 7$ 的结果。
		*   在构建过程中，既使用了向上取整（如节点5），又使用了向下取整（如节点7），规则不一致。因此，B 错误。
	3. 验证选项 C
		**根节点**: 5
		*   **初始序列**: `[1, 10]`
		*   要得到根节点 5，中间下标的计算必须是：$mid = \lfloor \frac{1+10}{2} \rfloor = \lfloor 5.5 \rfloor = 5$。
		*   因此，我们假设选项 C 是基于**向下取整**规则构建的，并查找矛盾点。
		    *   **节点 2 的右子树 (节点 4)**: 序列范围 `[3, 4]`。
		        *   根据向下取整规则，中间值应为 $mid = \lfloor \frac{3+4}{2} \rfloor = \lfloor 3.5 \rfloor = 3$。
		        *   但图 C 中该节点的值是 4，这实际上是向上取整 $mid = \lceil \frac{3+4}{2} \rceil = 4$ 的结果。
		*   规则不一致。因此，C 错误。
	4. 验证选项 D 
		  **根节点**: 5。同样，这要求使用**向下取整**规则。
		*   **左子树 (节点 3)**: 根为 5，左子树的序列范围是 `[1, 4]`。
		    *   根据向下取整规则，中间值应为 $mid = \lfloor \frac{1+4}{2} \rfloor = \lfloor 2.5 \rfloor = 2$。
		    *   但图 D 中该节点的值是 3。
		*   在第一层子树构建时就出现了矛盾。因此，D 错误。
		
		**结论**: 只有选项 A 完全符合单一的构建规则（向上取整）。
		
- 衍生 
	- #平均查找长度ASL    [[平均查找长度 (ASL)]]
		-  **计算**: $ASL_{成功} = \frac{\sum_{i=1}^{n} C_i}{n}$，其中 $C_i$ 是查找第 $i$ 个元素的比较次数（即该节点所在的层数）。
	    *   **考点**: 给你一棵折半查找判定树，计算其成功查找的平均查找长度。对于本题的树 A，ASL = (1×1 + 2×2 + 4×3 + 3×4) / 10 = 2.9。
	    *   **延伸**: 查找失败的 ASL 计算。这需要考虑外部节点（查找失败时终止的位置）
	-  #最优二叉查找树   
		-  **考点**: 这是一个动态规划的经典问题。可能会要求理解其概念，或者解决一个小规模的最优二叉查找树构建问题。
	- #平衡二叉树AVL  **考点**:
        *   AVL 树的定义（任何节点的左右子树高度差不超过1）及其旋转调整操作（LL, RR, LR, RL）。
        *   红黑树的 5 条性质及其插入/删除时的颜色调整和旋转。
        *   比较不同类型查找树的性能和适用场景。





![[2017-exam-paper-ocr.pdf#page=1&rect=70,86,456,143|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043340.png]]

[[B树和B+树的区别]]  
#B➕树 
B+树 特别适合处理存储在磁盘等外部设备上的 大量数据，特别是需要进行范围查询和精确查找 的场景，  因为每次磁盘的IO成本很高，B+树通过降低树的高度，最大限度的减少了磁盘读取的次数

1. A #编译器中的语法分析   #语法分析  主要是讲源代码字符串转换层一系列的记号，这个过程通常使用 #有限自动机  来实现，他通过 #状态转换 来识别关键字、标识符、运算符等，这个场景与B+树形索引结构关系不大
2. B  关系数据库系统中的索引 #数据库索引  ，数据库的数据量非常庞大， 无法一次性全部加载到磁盘上， #数据库索引的目的 就是为了加速查询 B+树的特性完美契合这个需求
	1. 减少磁盘IO 
	2. 高效的范围查询 
		1. 由于叶子节点是相连的有序链表， 当需要查询一个范围时， 只需定位到起始的叶子节点， 然后沿着链表顺序遍历即可， 无需再从树的根节点开始查找， 效率极高
		2. 因此， B+树是关系型 数据库 （如MySQL 的 innoDB引擎）中最核心和最常用的索引结构
3. C  网络中的 #路由表查询   路由表查找的核心是 #最长前缀匹配  ，虽然可以用树形结构， 但更高效和常用的数据结构是 #字典树Trie树  或其变体， 如 #基数树  
4. D 操作系统的磁盘 #空闲块管理 [[磁盘空闲空间管理]]  
	1.  #空闲链表法   将所有空闲块用链表连接起来
	2. #位图法  用一个二进制位图来表示所有磁盘块， 0代表以占用 ，1 代表空闲
	3. 这些方法实现简单，开销小， 比维护一个复杂的B+树更合适
- 结论： 综合分析， 只有 #关系数据库 中的索引 是 #B➕树的应用场景 
- 衍生 
	- B+树的高度与性能计算 #B➕树的性能
	- [[数据库索引类型]] 
	- [[索引结构的选择B+树vs哈希索引]] 


![[2017-exam-paper-ocr.pdf#page=1&rect=76,31,495,91|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043345.png]]

#归并排序   #插入排序  [[排序算法]]
#归并排序与插入排序对比  [[各类内部排序算法的时间复杂与空间复杂度]]    [[内部排序和外部排序]] 


1. 归并排序的程序代码更短
	1.  #插入排序 实现非常简单， 通常由两层循环构成，外层循环遍历待排序的元素，内层循环为当前元素在已排序部分找到合适的位置并插入。代码简单
	2. #归并排序 基于 #分治思想  ，需要一个递归函数来不断地将数组对半分割，还需要以恶搞额外的合并函数，用于将两个已排序的子数组和 
2. 陈述 II：归并排序的占用空间更少 
	1.   **插入排序**：它是一个 **原地排序 (in-place)** 算法。在排序过程中，它只需要一个额外的变量来临时存储待插入的元素，其所需的额外空间是固定的，与待排序数据量 $n$ 无关。因此，其空间复杂度为 $O(1)$。
	2.   **归并排序**：在合并两个有序子数组时，通常需要一个临时的辅助数组来存放合并后的结果，这个辅助数组的大小与待合并的数据量成正比。对于一个长度为 $n$ 的数组，它需要一个大小为 $n$ 的辅助数组。因此，其空间复杂度为 $O(n)$ 
	3.   **结论**：归并排序占用的空间（$O(n)$）比插入排序（$O(1)$）要**多**。所以陈述 II **错误**
3. 陈述 III：归并排序的运行效率更高
	**时间复杂度 (Time Complexity)** 是衡量算法执行时间随数据规模增长而增长的趋势。这通常是选择排序算法时最重要的考量因素。
	*   **插入排序**：
	    *   最坏情况（数组逆序）：时间复杂度为 $O(n^2)$。
	    *   平均情况：时间复杂度为 $O(n^2)$。
	    *   最好情况（数组已有序）：时间复杂度为 $O(n)$。
	*   **归并排序**：
	    *   无论是最好、最坏还是平均情况，归并排序都需要稳定地执行“分解”和“合并”操作。其时间复杂度始终为 $O(n\log n)$。
	* **比较**：当数据规模 $n$ 很大时，$O(n\log n)$ 的增长速度远慢于 $O(n^2)$。因此，对于大规模、无序的数据，归并排序的运行效率远高于插入排序 
	* **结论**：在通常情况下（尤其是在处理大规模数据时），归并排序的运行效率更高。陈述 III **正确** 



- 衍生 
	- [[各类内部排序算法的时间复杂与空间复杂度]]   
	- 何时选择插入排序？ 
		- 但在某些特定场景下，插入排序反而更具优势：
			*   **数据规模小**：当 $n$ 很小时， $O(n^2)$ 算法的常数项和低阶项可能使其比 $O(n\log n)$ 算法更快。因为归并排序的递归和合并操作有额外的开销。
			*   **数据基本有序**：当数据已经接近有序时，插入排序的时间复杂度接近 $O(n)$，效率非常高。
			*   **混合排序算法**：一些高级排序算法（如 Timsort，Python 的内置排序）会结合使用多种排序。例如，当待排序的子数组规模小于某个阈值时，就切换到插入排序，以提高效率。

لإ


لإ


![[2017-exam-paper-ocr.pdf#page=2&rect=74,770,510,822|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043350.png]]

[[存储器的四种主要存取方式]]    [[存储结构]]
#存储方式对排序算法的影响   #顺序存储   #链式存储     [[顺序存储与链式存储]] 
1.  I. 插入排序 
	1. **访问方式**：在已排序区中，它需要与其前面的元素逐一比较。这种“访问相邻前一个元素”的操作，无论是数组还是链表都可以高效完成。 
	2. **效率变化**：在数组中，找到位置后需要移动元素，这很耗时。在链表中，找到位置后插入节点的操作是$O(1)$，效率更高。但是，查找插入位置的过程无论是数组还是链表，都需要顺序比较，平均时间复杂度都是$O(n)$。因此，对于整个算法而言，总的时间复杂度量级不变，仍然是$O(n^2)$。效率没有降低
2.  II. 选择排序 
	1. **访问方式**：它的主要操作是在未排序区中进行顺序扫描以找到最值。这种顺序扫描对数组和链表都同样适用。 
	2. 效率变化 找到最值后，需要将其与未排序区的第一个元素交换。在数组中，交换是$O(1)$。在链表中，交换两个节点（尤其是非相邻节点）需要修改多个指针，稍微复杂一些，但也可以在$O(1)$时间内完成（如果维护了指向前驱节点的指针）。算法的瓶颈在于$n-1$次扫描，每次扫描的成本是线性的。因此，总的时间复杂度量级不变，仍然是$O(n^2)$。效率没有降低。 
3. 气泡排序 
	1.  **访问方式**：只涉及对**相邻元素**的访问和比较。
		*   **效率变化**：在数组中，访问`A[i]`和`A[i+1]`是$O(1)$。在链表中，访问当前节点和它的后继节点也是$O(1)$。因此，核心操作的效率没有变化。总的时间复杂度量级不变，仍然是$O(n^2)$。效率没有降低。 
4.  IV. 希尔排序 
	1. **访问方式**：希尔排序的关键在于它需要跳跃式地访问元素，例如比较`A[i]`和`A[i+gap]` 
	2.  **效率变化**：在数组中，由于支持随机访问，访问`A[i]`和`A[i+gap]`都是$O(1)$操作。但在链表中，要从第`i`个节点找到第`i+gap`个节点，必须向后遍历`gap`次，这是一个$O(gap)$的操作。这使得内层循环的成本大大增加，导致算法的整体时间效率**显著降低**
5.  V. 堆排序 
	1. **访问方式**：堆通常用数组来实现。因为在完全二叉树中，父节点和子节点的位置存在固定的数学关系。对于一个下标为`i`的节点：
	    *   其父节点下标为 $\lfloor(i-1)/2\rfloor$
	    *   其左子节点下标为 $2i+1$
	    *   其右子节点下标为 $2i+2$
	    这种通过下标计算直接定位到父子节点的方式，完全依赖于数组的**随机访问**特性。
	*   **效率变化**：如果用链表来表示堆，就无法通过下标计算来快速定位父子节点。每次调整堆时，寻找父子节点都需要通过指针遍历，效率远低于数组的$O(1)$访问。因此，堆排序的效率会**显著降低**

- 衍生 
	- [[原地排序]] 
	-  [[数据结构对排序算法的适应性]]  

![[2017-exam-paper-ocr.pdf#page=2&rect=75,708,522,774|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043355.png]]

[[计算机性能评测的四个指标]]  
#指令集体系结构ISA    #CPU执行时间   [[CPU时间占比（CPU利用率）]] 
1. 




![[2017-exam-paper-ocr.pdf#page=2&rect=76,643,527,707|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043359.png]]
[[Pasted image 20250930043403.png]]



#交叉编址 
  #计算周期数 










![[2017-exam-paper-ocr.pdf#page=2&rect=80,509,533,646|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043409.png]]


![[2017-exam-paper-ocr.pdf#page=2&rect=77,476,478,517|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044146.png]]


#寻址方式  [[寻址方法的比较]]  
#下标顺序访问 
#访问方法









![[2017-exam-paper-ocr.pdf#page=2&rect=77,426,527,477|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044151.png]]

#指令字长 
#指令格式  





![[2017-exam-paper-ocr.pdf#page=2&rect=75,354,471,427|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044156.png]]


[[流水线技术]]  
#流水线特性 






![[2017-exam-paper-ocr.pdf#page=2&rect=78,275,463,357|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044202.png]]


#总线与主存技术   #控制存储器   





![[2017-exam-paper-ocr.pdf#page=2&rect=76,226,510,281|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044207.png]]


[[指令流水线与冲突]]  



![[2017-exam-paper-ocr.pdf#page=2&rect=75,177,477,228|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044221.png]]


[[系统总线结构（数据线，地址线，控制总线）]]  


#多总线结构




![[2017-exam-paper-ocr.pdf#page=2&rect=76,128,456,181|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044227.png]]


#数据传送  [[IO接口和IO端口]]  [[IO 结构与控制]]  




![[2017-exam-paper-ocr.pdf#page=2&rect=75,47,344,133|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044233.png]]
[[Pasted image 20250930044239.png]]

#多重中断系统  #中断系统设计的基本原则   

![[Pasted image 20251015111201.png]]
![[2017-exam-paper-ocr.pdf#page=3&rect=68,682,525,822|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044245.png]]

[[磁盘调度算法]]





![[2017-exam-paper-ocr.pdf#page=3&rect=74,608,505,683|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044251.png]]


[[系统调用的过程]]
C
 



![[2017-exam-paper-ocr.pdf#page=3&rect=72,500,527,608|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044257.png]]

#最佳适应算法 
[[动态分区存储管理（动态分区分配算法）]]  
	  **策略**: 遍历整个空闲分区链表，找到**所有**能满足大小要求的分区中，**尺寸最小**的那一个。 
	  #起始地址 





![[2017-exam-paper-ocr.pdf#page=3&rect=77,450,533,505|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044302.png]]


#簇  [[文件分配表FAT]]




![[2017-exam-paper-ocr.pdf#page=3&rect=74,377,415,457|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044309.png]]

#时间片轮转算法  [[常见进程调度算法与优先级关系]]

[





![[2017-exam-paper-ocr.pdf#page=3&rect=73,323,513,381|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044315.png]]


#多道批处理系统  D
 





![[2017-exam-paper-ocr.pdf#page=3&rect=75,238,498,329|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044321.png]]
[[逻辑地址到物理地址的转换]]

#逻辑格式化




![[2017-exam-paper-ocr.pdf#page=3&rect=74,151,528,242|2017-exam-paper-ocr, p.3]][[Pasted image 20250930044405.png]]


[[文件控制块FCB]] 
[[计算所有位数]]  
#描述文件权限的位数 








![[2017-exam-paper-ocr.pdf#page=3&rect=73,67,530,148|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044410.png]]

[[文件描述符、打开文件表和FCB(inode)的关系]] 















![[2017-exam-paper-ocr.pdf#page=4&rect=80,741,499,818|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044415.png]]

#数据读取 
#DMA工作流程  
#数据传输过程   
[[总线与主存技术]]










![[2017-exam-paper-ocr.pdf#page=4&rect=79,692,526,743|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044421.png]]

[[OSI七层模型]]
[[数据封装过程]]
[[TCP-IP 协议栈封装与解封装]]  

#数据传输效率  
#应用层 



![[2017-exam-paper-ocr.pdf#page=4&rect=76,643,516,691|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044425.png]]


[[香农定理]] 
#信噪比SNR   [[信噪比]]




![[2017-exam-paper-ocr.pdf#page=4&rect=76,459,528,642|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044432.png]]
[[IP分组的生命周期]]  [[IP头部略讲]] 
[[以太网帧结构]]  






![[2017-exam-paper-ocr.pdf#page=4&rect=73,421,500,458|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044440.png]]


#判断IP地址的合法性   
#目的IP地址  
#判读源IP地址和目标IP地址  [[IP




![[2017-exam-paper-ocr.pdf#page=4&rect=79,387,506,424|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044451.png]]
[[数据封装过程]]





![[2017-exam-paper-ocr.pdf#page=4&rect=78,339,521,389|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044457.png]]

[[IP子网划分]]  
[[IP地址与子网掩码]]  





![[2017-exam-paper-ocr.pdf#page=4&rect=75,291,526,340|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044502.png]]


#发送窗口   
[[TCP的两个窗口机制]]  




![[2017-exam-paper-ocr.pdf#page=4&rect=73,216,344,301|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044507.png]]
#FTP文件传输协议   

![[2017-exam-paper-ocr.pdf#page=5&rect=70,523,539,830|2017-exam-paper-ocr, p.5]][[Pasted image 20250930044523.png]]
[[表达式转换（前中后缀）]]  
#表达式树   




![[2017-exam-paper-ocr.pdf#page=6&rect=75,617,528,823|2017-exam-paper-ocr, p.6]]
[[Pasted image 20250930044624.png]]
[[Pasted image 20250930044632.png]]

#Prim算法   


![[2017-exam-paper-ocr.pdf#page=7&rect=77,563,539,823|2017-exam-paper-ocr, p.7]]
[[Pasted image 20250930044646.png]]
[[Pasted image 20250930044653.png]]
[[Pasted image 20250930044700.png]]
[[Pasted image 20250930044710.png]]

[[数据类型转换]]  

[[IEEE 754 标准]]  
















![[2017-exam-paper-ocr.pdf#page=7&rect=63,270,551,573|2017-exam-paper-ocr, p.7]]
[[Pasted image 20250930044722.png]]

[[RISC 和CISC的区别]]  
[[指令格式]] 
#机器指令  










![[2017-exam-paper-ocr.pdf#page=7&rect=65,136,536,273|2017-exam-paper-ocr, p.7]]
[[Pasted image 20250930044741.png]]
[








![[2017-exam-paper-ocr.pdf#page=8&rect=70,565,532,824|2017-exam-paper-ocr, p.8]]
[[Pasted image 20250930044751.png]]


[[临界区问题]]  





![[2017-exam-paper-ocr.pdf#page=8&rect=75,127,536,568|2017-exam-paper-ocr, p.8]]
[[Pasted image 20250930044759.png]]
[[Pasted image 20250930044804.png]]

[[后退N帧协议GBN]]    [[数据帧]]  #数据帧   
1.  [[数据帧











