![[2017-exam-paper-ocr.pdf#page=1&rect=70,596,549,705|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043154.png]]

[[时间复杂度分析]] 
[[时间复杂度等价]]
**1. 分析代码**

```c
int func(int n) {
    int i=0, sum=0;
    while(sum < n) {
        sum += ++i;
    }
    return i;
}
```

*   **初始化**：`i` 和 `sum` 都从0开始。
*   **循环条件**：循环持续的条件是 `sum < n`。当 `sum >= n` 时，循环终止。
*   **循环体**：`sum += ++i;`。这是一个关键操作。`++i` 是前置自增，意味着先将 `i` 的值加1，然后用新的 `i` 值参与运算。
    *   它等价于：
        ```c
        i = i + 1;
        sum = sum + i;
        ```
2. 
	*   **第1次循环**：`i` 变为1，`sum` = 0 + 1 = 1。
	*   **第2次循环**：`i` 变为2，`sum` = 1 + 2 = 3。
	*   **第3次循环**：`i` 变为3，`sum` = 3 + 3 = 6。
	*   ...
	*   **第k次循环**：`i` 变为 `k`，`sum` 的值是 $1 + 2 + 3 + \dots + k$。
3. $sum = \frac{k(k+1)}{2}$ 
	1. $\frac{k(k+1)}{2} \approx n$ 
	2. $k(k+1) \approx 2n$
		$k^2 + k \approx 2n$
	3. $k^2 \approx 2n$ 
	4. $k \approx \sqrt{2n} = \sqrt{2} \cdot \sqrt{n}$ 
4. 所以，循环的执行次数 `k` 与 $\sqrt{n}$ (即 $n^{1/2}$) 成正比  
5.  B. $O(n^{1/2})$ 

- 衍生    [[时间复杂度分析]]
	- [[++i vs. i++ 的时间复杂度影响]] 
		- 如果原题中的 `sum += ++i;` 改为 `sum += i++;`，时间复杂度会变吗？
			- **结论**：在渐近分析中，$k^2-k$ 和 $k^2+k$ 的主导项都是 $k^2$。因此，求解后得到的复杂度依然是 $O(\sqrt{n})$。在时间复杂度的大O分析层面，这两者没有区别，但这可能作为一个细节题来考察对自增运算符的理解。

![[2017-exam-paper-ocr.pdf#page=1&rect=76,509,503,599|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043159.png]]


[[栈]] 
#函数调用栈    
- 1 错误 
- I. 采用非递归的方式重写递归程序时必须用栈
	- 这个说法的关键在于“必须” (must) 这个词，过于绝对。虽然栈是实现递归转非递归的一种通用且强大的方法，因为它能完美模拟函数调用栈的行为（保存局部变量、返回地址等），但并非所有情况都必须用栈。
*   **反例：**
    1.  #尾递归  尾递归是一种特殊的递归形式，递归调用是函数的最后一步操作。这种递归可以被编译器优化，直接转换成一个简单的循环，完全不需要栈。
    2.  #简单递归 ： 像题目解析中提到的计算斐波那契数列或阶乘，虽然有递归定义，但它们的迭代版本（非递归）只需要几个变量和一个循环就可以实现，并不需要显式地使用一个栈结构。
- 2 正确    
	- II. 函数调用时，系统要用栈保存必要的信息[[堆栈帧]]
	3.  每当一个函数被调用时，系统会创建一个称为“栈帧” 或“活动记录”的数据块，并将其压入一个特定的内存区域，这个区域就是 #调用栈
		1. #栈帧 中保存了函数的参数、局部变量、返回地址 #堆栈帧
		2. [[递归与栈的关系]] 
- 衍生 
	- [[栈的应用]] 




![[2017-exam-paper-ocr.pdf#page=1&rect=75,462,436,509|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043205.png]]

 #稀疏矩阵  [[邻接矩阵，邻接表 ，稀疏图，稠密图]]  
#压缩存储   #不同的压缩存储方式   [[压缩存储]]
三元组表和十字链表是两种专门为压缩存储稀疏矩阵而设计的数据结构。邻接矩阵不属于压缩存储，而二叉链表则用于完全不同的数据类型。因此，正确答案是 **A**  
#三元组表  #十字链表  
- 衍生
	- [[稀疏矩阵的转置运算]]  #转置运算   
		- 原矩阵每一列的非零元个数，然后计算每一列第一个非零元在转置后三元组表中的起始位置。时间复杂度可以优化到 $O(n+t)$。这是面试和考试中的高频考点
	- [[稀疏矩阵的加法和乘法运算]] 
	- [[树和森林的存储结构]] 
	



![[2017-exam-paper-ocr.pdf#page=1&rect=75,424,517,460|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043209.png]]

#结点的度  #非叶结点   #先序序列   [[遍历序列的基本性质]]  [[序列相同的条件]] 
1. 推理过程 
	1. 用 `R` 代表根结点，`L` 代表左子树的遍历序列，`R_sub` 代表右子树的遍历序列。
		*   那么，这棵树的先序序列可以表示为：`R, L, R_sub`
		*   这棵树的中序序列可以表示为：`L, R, R_sub`
		
		*   要使这两个序列相同，即 `R, L, R_sub` = `L, R, R_sub`，我们来比较它们的第一个元素。
		*   在先序序列中，第一个元素永远是根结点 `R`。
		*   在中序序列中，第一个元素是左子树遍历序列 `L` 的第一个元素。
		*   为了让两个序列的第一个元素相同，中序序列的第一个元素也必须是根结点 `R`。这种情况只有在左子树的遍历序列 `L` 为**空**时才会发生。
		
		*   如果左子树为空，那么：
		    *   先序序列变为：`R, R_sub`
		    *   中序序列变为：`R, R_sub`
		    *   此时，两个序列就相同了。
		
		*   这个逻辑是**递归**的。也就是说，对于树中的**任意一个结点**（把它看作一个子树的根），要使其子树的先序和中序遍历相同，这个结点都**不能有左孩子**。
	2. 题目要求是“所有非叶结点须满足的条件”。非叶结点就是有孩子的结点。根据我们的推导，这些结点都不能有左孩子，所以它们只能有右孩子 
		1. 正确答案是 **B. 只有右子树**

	*   **A. 只有左子树：** 如果一个结点 `R` 只有左子树 `L`，那么先序是 `R, L`，中序是 `L, R`。这两个序列显然是相反的，不可能相同（除非树只有一个结点）。
	*   **C. 结点的度均为1：** 这个条件太宽泛。一个结点的度为1，意味着它要么只有左孩子，要么只有右孩子。如果存在一个结点只有左孩子，那么条件就不满足了。所以C是错误的。
	*   **D. 结点的度均为2：** 如果结点的度为2，意味着它既有左孩子又有右孩子，这直接违反了我们推导出的“左子树必须为空”的结论。

- 衍生 
	- [[序列相同的条件]] 
	-  [[根据遍历序列重建二叉树]] 
	- [[二叉树的性质]] 
		- 对于任意一棵非空二叉树，如果叶结点的数量为$n_0$，度为2的结点数量为$n_2$，那么它们之间存在一个恒定的关系：
				$n_0 = n_2 + 1$
	- [[层次遍历]]    
		- 除了深度优先的三种遍历，还有一种广度优先的遍历方式，即层次遍历 ， 通常使用**队列**数据结构来实现

![[Pasted image 20250930043248.png]]
[[Pasted image 20250930043226.png]]


#后序序列  #二叉树的后序遍历  






![[2017-exam-paper-ocr.pdf#page=1&rect=75,329,483,377|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043324.png]]

[[哈夫曼编码]]  
#字符集


![[2017-exam-paper-ocr.pdf#page=1&rect=76,283,531,326|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043328.png]]

#顶点的度      






![[2017-exam-paper-ocr.pdf#page=1&rect=73,141,450,280|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043334.png]]

[[二分查找]]  
#折半查找判定树   






![[2017-exam-paper-ocr.pdf#page=1&rect=70,86,456,143|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043340.png]]

[[B树和B+树的区别]]  
#B➕树 




![[2017-exam-paper-ocr.pdf#page=1&rect=76,31,495,91|2017-exam-paper-ocr, p.1]]
[[Pasted image 20250930043345.png]]
[[内部排序和外部排序]] 
[[各类内部排序算法的时间复杂与空间复杂度]]  
#归并排序   #插入排序
#归并排序与插入排序对比 




![[2017-exam-paper-ocr.pdf#page=2&rect=74,770,510,822|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043350.png]]

[[存储器的四种主要存取方式]]
#存储方式对排序算法的影响 



![[2017-exam-paper-ocr.pdf#page=2&rect=75,708,522,774|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043355.png]]

[[计算机性能评测的四个指标]]  
#指令集体系结构ISA  





![[2017-exam-paper-ocr.pdf#page=2&rect=76,643,527,707|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043359.png]]
[[Pasted image 20250930043403.png]]



#交叉编址 
  #计算周期数 










![[2017-exam-paper-ocr.pdf#page=2&rect=80,509,533,646|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930043409.png]]


![[2017-exam-paper-ocr.pdf#page=2&rect=77,476,478,517|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044146.png]]


#寻址方式  [[寻址方法的比较]]  
#下标顺序访问 
#访问方法









![[2017-exam-paper-ocr.pdf#page=2&rect=77,426,527,477|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044151.png]]

#指令字长 
#指令格式  





![[2017-exam-paper-ocr.pdf#page=2&rect=75,354,471,427|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044156.png]]


[[流水线技术]]  
#流水线特性 






![[2017-exam-paper-ocr.pdf#page=2&rect=78,275,463,357|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044202.png]]


#总线与主存技术   #控制存储器   





![[2017-exam-paper-ocr.pdf#page=2&rect=76,226,510,281|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044207.png]]


[[指令流水线与冲突]]  



![[2017-exam-paper-ocr.pdf#page=2&rect=75,177,477,228|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044221.png]]


[[系统总线结构（数据线，地址线，控制总线）]]  


#多总线结构




![[2017-exam-paper-ocr.pdf#page=2&rect=76,128,456,181|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044227.png]]


#数据传送  [[IO接口和IO端口]]  [[IO 结构与控制]]  




![[2017-exam-paper-ocr.pdf#page=2&rect=75,47,344,133|2017-exam-paper-ocr, p.2]]
[[Pasted image 20250930044233.png]]
[[Pasted image 20250930044239.png]]

#多重中断系统  #中断系统设计的基本原则   


![[2017-exam-paper-ocr.pdf#page=3&rect=68,682,525,822|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044245.png]]

[[磁盘调度算法]]





![[2017-exam-paper-ocr.pdf#page=3&rect=74,608,505,683|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044251.png]]


[[系统调用的过程]]
C
 



![[2017-exam-paper-ocr.pdf#page=3&rect=72,500,527,608|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044257.png]]

#最佳适应算法 
[[动态分区存储管理（动态分区分配算法）]]  
	  **策略**: 遍历整个空闲分区链表，找到**所有**能满足大小要求的分区中，**尺寸最小**的那一个。 
	  #起始地址 





![[2017-exam-paper-ocr.pdf#page=3&rect=77,450,533,505|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044302.png]]


#簇  [[文件分配表FAT]]




![[2017-exam-paper-ocr.pdf#page=3&rect=74,377,415,457|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044309.png]]

#时间片轮转算法  [[常见进程调度算法与优先级关系]]

[





![[2017-exam-paper-ocr.pdf#page=3&rect=73,323,513,381|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044315.png]]


#多道批处理系统  D
 





![[2017-exam-paper-ocr.pdf#page=3&rect=75,238,498,329|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044321.png]]
[[逻辑地址到物理地址的转换]]

#逻辑格式化




![[2017-exam-paper-ocr.pdf#page=3&rect=74,151,528,242|2017-exam-paper-ocr, p.3]][[Pasted image 20250930044405.png]]


[[文件控制块FCB]] 
[[计算所有位数]]  
#描述文件权限的位数 








![[2017-exam-paper-ocr.pdf#page=3&rect=73,67,530,148|2017-exam-paper-ocr, p.3]]
[[Pasted image 20250930044410.png]]

[[文件描述符、打开文件表和FCB(inode)的关系]] 















![[2017-exam-paper-ocr.pdf#page=4&rect=80,741,499,818|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044415.png]]

#数据读取 
#DMA工作流程  
#数据传输过程   
[[总线与主存技术]]










![[2017-exam-paper-ocr.pdf#page=4&rect=79,692,526,743|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044421.png]]

[[OSI七层模型]]
[[数据封装过程]]
[[TCP-IP 协议栈封装与解封装]]  

#数据传输效率  
#应用层 



![[2017-exam-paper-ocr.pdf#page=4&rect=76,643,516,691|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044425.png]]


[[香农定理]] 
#信噪比SNR   [[信噪比]]




![[2017-exam-paper-ocr.pdf#page=4&rect=76,459,528,642|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044432.png]]
[[IP分组的生命周期]]  [[IP头部略讲]] 
[[以太网帧结构]]  






![[2017-exam-paper-ocr.pdf#page=4&rect=73,421,500,458|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044440.png]]


#判断IP地址的合法性   
#目的IP地址  
#判读源IP地址和目标IP地址  [[IP




![[2017-exam-paper-ocr.pdf#page=4&rect=79,387,506,424|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044451.png]]
[[数据封装过程]]





![[2017-exam-paper-ocr.pdf#page=4&rect=78,339,521,389|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044457.png]]

[[IP子网划分]]  
[[IP地址与子网掩码]]  





![[2017-exam-paper-ocr.pdf#page=4&rect=75,291,526,340|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044502.png]]


#发送窗口   
[[TCP的两个窗口机制]]  




![[2017-exam-paper-ocr.pdf#page=4&rect=73,216,344,301|2017-exam-paper-ocr, p.4]]
[[Pasted image 20250930044507.png]]
#FTP文件传输协议   

![[2017-exam-paper-ocr.pdf#page=5&rect=70,523,539,830|2017-exam-paper-ocr, p.5]][[Pasted image 20250930044523.png]]
[[表达式转换（前中后缀）]]  
#表达式树   




![[2017-exam-paper-ocr.pdf#page=6&rect=75,617,528,823|2017-exam-paper-ocr, p.6]]
[[Pasted image 20250930044624.png]]
[[Pasted image 20250930044632.png]]

#Prim算法   


![[2017-exam-paper-ocr.pdf#page=7&rect=77,563,539,823|2017-exam-paper-ocr, p.7]]
[[Pasted image 20250930044646.png]]
[[Pasted image 20250930044653.png]]
[[Pasted image 20250930044700.png]]
[[Pasted image 20250930044710.png]]

[[数据类型转换]]  

[[IEEE 754 标准]]  
















![[2017-exam-paper-ocr.pdf#page=7&rect=63,270,551,573|2017-exam-paper-ocr, p.7]]
[[Pasted image 20250930044722.png]]

[[RISC 和CISC的区别]]  
[[指令格式]] 
#机器指令  










![[2017-exam-paper-ocr.pdf#page=7&rect=65,136,536,273|2017-exam-paper-ocr, p.7]]
[[Pasted image 20250930044741.png]]
[








![[2017-exam-paper-ocr.pdf#page=8&rect=70,565,532,824|2017-exam-paper-ocr, p.8]]
[[Pasted image 20250930044751.png]]


[[临界区问题]]  





![[2017-exam-paper-ocr.pdf#page=8&rect=75,127,536,568|2017-exam-paper-ocr, p.8]]
[[Pasted image 20250930044759.png]]
[[Pasted image 20250930044804.png]]

[[后退N帧协议GBN]]    [[数据帧]]  #数据帧   
1.  [[数据帧











