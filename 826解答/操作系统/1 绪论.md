![[826历年真题解析-操作系统篇（2024.10.31）.pdf#page=1&rect=21,97,585,681|826历年真题解析-操作系统篇（2024.10.31）, p.1]]![[Pasted image 20251118092003.png]]
![[Pasted image 20251120103156.png]]

1.   [[中断处理机制]]

| **① 关中断**<br>**② 保存断点 (PC值)**<br>**③ 识别中断源并取中断服务程序入口地址**      | 这三个由**硬件自动完成**的动作（即**中断隐指令**），合起来就是CPU对中断请求的“响应”行为。CPU说：“好的，我收到请求了，现在我准备去处理它。” |
| :------------------------------------------------------------ | :----------------------------------------------------------------------------- |
| **④ 保护现场 (通用寄存器等)**<br>**⑤ 中断事件处理 (执行ISR核心代码)**<br>**⑥ 恢复现场** | 这是**软件（中断服务程序ISR）**执行的全部内容。它就是对中断事件的真正“服务”。                                    |

- 衍生 
	- [[硬件压栈的具体内容]]  
	- #中断向量表 / #描述符表的地址计算  
		- #实模式   
			- 中断向量表位于内存最低端。每个表项占4字节（2字节CS，2字节IP）。
			    若中断向量号为 $N$，则中断服务程序的入口地址指针存放在物理地址 $P$ 处：
			    $P=N\times4$
		- #保护模式  
			- 使用中断描述符表（IDT）。IDT的基地址存储在 **IDTR** 寄存器中。每个描述符（Descriptor）通常占8字节。
			    若中断向量号为 $N$，IDT基地址为 $Base_{IDT}$，则该中断对应的描述符地址 $Addr_{desc}$ 为：
			    $Addr_{desc}=Base_{IDT}+N\times8$
	- [[堆栈切换]]  
		- **考点**：为什么中断会导致堆栈切换？
		*   **解释**：为了安全。如果中断处理程序继续使用用户态的堆栈，恶意用户可以通过修改栈内容导致内核崩溃或提权。因此，X86硬件在特权级提升时强制切换到TSS中指定的内核栈。



![[Pasted image 20251118092024.png]]

**推导逻辑如下：**      [[上下文切换]]  
*   **什么是“断点”？** 在操作系统上下文切换（Context Switch）的语境下，所谓的“断点”并非调试器里的断点，而是指当前进程或线程**暂停执行时的状态**。这个状态包括但不限于：程序计数器（$PC$或$EIP$）、栈指针（$SP$或$ESP$）以及通用寄存器。
*   **为什么要保存？** 操作系统的并发性要求进程必须能够被“挂起”并在未来某个时刻“恢复”。如果不仅行保存，当 CPU 切换回来时，它不知道上一条指令执行到了哪里，也不知道栈的数据结构如何，程序就无法继续运行。
*   **结论：** `switch_to` 函数的核心作用虽然是切换，但其内部实现的第一步必须是**保存当前进程的上下文（保存断点）**，然后才是**恢复目标进程的上下文**。因此，“不必保存断点”是绝对错误的。

[[switch_to的工作原理]]  
-  衍生 
	- 硬件与软件的分工   
		*   **问：** 在发生中断或系统调用导致切换时，哪些状态是硬件自动保存的？哪些是软件（OS）保存的？
		*   **点：**
		    *   **硬件（CPU）**：通常会自动压入$SS$,$ESP$,$EFLAGS$,$CS$,$EIP$（从用户态切到内核态时）。
		    *   **软件（OS `trap` 函数）**：需要保存通用寄存器（$eax$,$ecx$等）来构建完整的 TrapFrame。
		    *   **软件（OS `switch_to` 函数）**：在进程调度切换时，主要负责保存“被调用者保存（Callee-saved）”的寄存器。
	- 切换的开销    [[进程切换与线程切换的区别]]
	-  #内核栈的变化    
		-   **问：** `switch_to` 执行过程中，$ESP$是如何变化的？
		*   **点：** 
		    1.  进入函数时，$ESP$指向进程 A 的内核栈。
		    2.  执行 `mov [eax], esp`（保存旧栈指针）。
		    3.  执行 `mov esp, [edx]`（加载新栈指针）。
		    4.  此时$ESP$指向了进程 B 的内核栈。
		    *   考点在于理解指令流没有断，但操作的数据栈换了。  
	   [[上下文切换]]
	*   上下文切换一定发生在内核态吗？（是的，因为只有内核有权限操作PCB和执行特权指令来修改CPU关键寄存器）。
	- 从用户态进入内核态的方式有哪些？（系统调用、中断、异常）。这两者与上下文切换的关系是什么？（它们是触发上下文切换的**前提**，但本身不完全等同于上下文切换）



![[Pasted image 20251118092031.png]]



![[Pasted image 20251118092046.png]]![[Pasted image 20251118092057.png]]![[Pasted image 20251118092102.png]]![[Pasted image 20251118092108.png]]![[Pasted image 20251118092116.png]]![[Pasted image 20251118092124.png]]![[Pasted image 20251118092129.png]]![[Pasted image 20251118092134.png]]![[Pasted image 20251118092138.png]]![[Pasted image 20251118092146.png]]![[Pasted image 20251118092152.png]]![[Pasted image 20251118092158.png]]![[Pasted image 20251118092206.png]]![[Pasted image 20251118092217.png]]![[Pasted image 20251118092239.png]]![[Pasted image 20251118092246.png]]![[Pasted image 20251118092252.png]]