![[912历年真题解析-组成原理篇（2024.12.2）.pdf#page=10&rect=17,377,579,808|912历年真题解析-组成原理篇（2024.12.2）, p.10]]

1. 这道题主要考察计算机组成原理中的[[流水线技术]]   [[流水线]]   [[流水线性能分析]]  
	1. 流水线时钟周期$T_{clk}$   
		1. 公式为：$T_{clk} = \max(T_{stage\_i}) + T_{reg}$
			1. 其中，$T_{stage\_i}$ 是第 $i$ 个流水段的组合逻辑延迟 ，$T_{reg}$ 是 #流水线寄存器 （题目中的“寄存器”或“锁存器”）的延迟  
	2. #流水线延迟    
		1. 指单条指令从进入流水线到执行完成所需要的总时间。对于一个 $k$ 级的流水线，其延迟为：
		    公式为：$Latency = k \times T_{clk}$   
	3. #流水线吞吐率   
		1. 指单位时间内流水线能够完成的指令数量，是衡量流水线性能的重要指标。理想情况下，当流水线“充满”后，每个时钟周期都能完成一条指令。
		    公式为：$Throughput = \frac{1}{T_{clk}}$
		    吞吐率的单位通常是 GIPS 
2. 我们整理一下已知条件：
	*   组合逻辑部件延迟：A=40ps, B=20ps, C=35ps, D=15ps, E=15ps, F=25ps。
	*   总逻辑延迟 = $40+20+35+15+15+25 = 150ps$。
	*   寄存器延迟 $T_{reg} = 10ps$。
-  (1) 4级流水线设计
1. **目标**：构建一个4级流水线，需要插入 $4-1=3$ 个寄存器。为了使流水线性能最好（即时钟周期最短），我们应该尽量让每个流水段的逻辑延迟大致相等。  
	1. 分析  
		1. 总逻辑延迟为150ps，分成4段，理想情况下每段的逻辑延迟为 $150/4 = 37.5ps$。我们根据这个理想值来划分逻辑部件：
			*   A (40ps) 本身就接近37.5ps，可以单独作为一段。
			*   B (20ps) + C (35ps) = 55ps。
			*   D (15ps) + E (15ps) = 30ps。
			*   F (25ps)。
2. 只是一个粗略的划分，我们需要尝试不同的组合。题解中给出的方案是：在AB之间、BC之间、DE之间插入寄存器。我们来分析这种划分方式：
	*   **段1**: 逻辑部件 A。逻辑延迟 $T_{stage1} = 40ps$。
	*   **段2**: 逻辑部件 B。逻辑延迟 $T_{stage2} = 20ps$。
	*   **段3**: 逻辑部件 C + D。逻辑延迟 $T_{stage3} = 35ps + 15ps = 50ps$。
	*   **段4**: 逻辑部件 E + F。逻辑延迟 $T_{stage4} = 15ps + 25ps = 40ps$。
3. 计算时钟周期  
	1. 时钟周期由最长的逻辑段决定。
		$T_{clk} = \max(40, 20, 50, 40) + T_{reg} = 50ps + 10ps = 60ps$
		这个最长的段就是由C和D组成的逻辑段，与题解“最长的流水段为C+D+锁存器=60ps”的描述一致。  
4. 计算延迟和吞吐率  
	1. 延迟  
		1. $Latency = k \times T_{clk} = 4 \times 60ps = 240ps$
	2. 最大吞吐率
	    $Throughput = \frac{1}{T_{clk}} = \frac{1}{60ps} = \frac{1}{60 \times 10^{-12}s} \approx 16.67 \times 10^9 \text{ Instructions/s} = 16.67 \text{GIPS}$
- (2) 达到最大吞吐率的设计  
1. 目标  ：要达到最大吞吐率，根据公式 $Throughput = 1/T_{clk}$，就是要使**时钟周期 $T_{clk}$ 最小化**。  
	1. 时钟周期 $T_{clk} = \max(T_{stage\_i}) + T_{reg}$。要使其最小，就必须使最长的逻辑段延迟 $\max(T_{stage\_i})$ 最小。
		#逻辑部件 是不可再分的，其中延迟最长的单个部件是A（40ps）。因此，任何流水段的逻辑延迟都不可能小于40ps（除非A本身被分成一段）。所以，$\max(T_{stage\_i})$ 的理论最小值就是最长的那个不可分部件的延迟，即40ps    
2. 设计流水线  
	1. 以40ps为上限来划分逻辑段，只要一个组合的延迟超过40ps，就必须插入寄存器。
		*   **段1**: A (40ps)。延迟为40ps，达到上限，必须在此之后插入寄存器。
		*   **段2**: B (20ps)。延迟为20ps。
		*   **段3**: C (35ps)。延迟为35ps。
		*   **段4**: D (15ps)。延迟为15ps。
		*   **段5**: E (15ps) + F (25ps) = 40ps。延迟为40ps。
	2. 这样，我们得到了一个5级流水线，各段的逻辑延迟分别为 {40ps, 20ps, 35ps, 15ps, 40ps}。寄存器被插在了A之后(AB之间)、B之后(BC之间)、C之后(CD之间)、D之后(DE之间)。
3. 计算时钟周期  
	1. $T_{clk} = \max(40, 20, 35, 15, 40) + T_{reg} = 40ps + 10ps = 50ps$
		这个最长的段是由A或者E+F组成的逻辑段，与题解“最长的流水段为A+锁存器=50ps”的描述一致。 
4. 计算延迟和吞吐率  
	1. 延迟   
		1. $Latency = k \times T_{clk} = 5 \times 50ps = 250ps$  
	2. 最大吞吐率  
		1. $Throughput = \frac{1}{T_{clk}} = \frac{1}{50ps} = \frac{1}{50 \times 10^{-12}s} = 20 \times 10^9 \text{ Instructions/s} = 20 \text{GIPS}$  
- 衍生    
	- #流水线加速比 
		- 考题可能会问，相比于不使用流水线的单周期处理器，该流水线的加速比是多少？
		    *   单周期处理器执行一条指令的时间 $T_{non-pipeline} = \text{总逻辑延迟} + \text{寄存器延迟} = 150ps + 10ps = 160ps$。
		    *   流水线处理 $n$ 条指令的时间 $T_{pipeline} = (k + n - 1) \times T_{clk}$。
		    *   当 $n$ 很大时，加速比 $S \approx \frac{T_{non-pipeline}}{T_{clk}}$。
		    *   例如，对于问题(2)中的5级流水线，其理想加速比为 $S \approx \frac{160ps}{50ps} = 3.2$
	- 流水线冲突 
		- 考题可能会给出一个指令序列，让你找出其中存在的冲突，并说明如何通过**暂停（Stall）**、数据前推（Forwarding）或分支预测（Branch Prediction）等技术来解决 
	- 流水线效率和开销
		-  **开销 (Overhead)**: 主要是指流水线寄存器的延迟。如果将流水线分得过细（例如，每1ps就插入一个寄存器），寄存器延迟的占比会越来越大，反而可能降低性能。考题可能让你分析流水线级数和性能的非线性关系。


![[Pasted image 20251117105754.png]]
[[Pasted image 20251117105801.png]]
[[处理器设计思想]]    
[[mips指令集简写]] 
-  这道题考察  #三种经典的处理器设计思想 ：单周期（Single-Cycle）、多周期（Multi-Cycle）和流水线（Pipelined）设计  
1. 单周期处理器  
	1.   **核心思想**: 每条指令都在一个时钟周期内完成。
	    *   **时钟周期**: 必须设置为**最长指令**的执行时间，因为时钟周期要能容纳下最复杂、路径最长的那条指令（通常是`lw`指令）。
	    *   **性能**: CPI (Cycles Per Instruction) 恒为1，但时钟频率很低，因为周期太长。
2. 多周期处理器
	1. **核心思想**: 将一条指令的执行过程划分为多个（通常是3-5个）基本步骤，每个步骤在一个时钟周期内完成。不同指令执行所需的步骤数可以不同  
		1. 时钟周期  
			1. 由**最长的功能单元/步骤**的延迟决定。例如，如果内存访问最慢，时钟周期就由内存访问时间决定  
		2. 性能  
			1. 时钟频率比单周期高，但CPI大于1。不同指令的CPI不同，例如`lw`需要5个周期，`j`可能只需要2个周期 
3. 流水线处理器 
	1. 核心思想  
		1.  将指令执行过程划分为多个阶段（Stage），让多条指令的不同阶段在同一时刻重叠执行，像工厂流水线一样  
	2. 时钟周期  
		1. 由**最长的流水线阶段**的延迟决定。为了让流水线顺畅流动，所有阶段的耗时必须统一，这个统一的时间就是时钟周期 
	3. 性能 
		1.  理想情况下，CPI趋近于1，并且时钟频率较高（取决于最长阶段），因此吞吐率（Throughput）极高。但会遇到数据冒险、控制冒险等问题  
- 题目参数梳理  
	*   内存（指令/数据）读/写延迟: $t_{mem}=10ns$
	*   ALU延迟: $t_{ALU}=6ns$
	*   寄存器堆（Register File）读延迟: $t_{RFread}=3ns$
	*   寄存器堆（Register File）写延迟: $t_{RFwrite}=1ns$
	*   流水线寄存器/PC 输出延迟: $t_{latch}=2ns$
-  (1) 按单周期设计，计算指令延迟  
	1. `lw`指令的执行路径如下：
	2.  **取指 (IF)**: 从PC寄存器输出地址，到指令存储器读取指令。
	    *   路径：PC -> 指令存储器
	    *   延迟：$t_{PCout} + t_{mem} = 2ns + 10ns = 12ns$
	3.  **译码/读寄存器 (ID)**: 读取基址寄存器（rs）。
	    *   路径：寄存器堆读
	    *   延迟：$t_{RFread} = 3ns$
	4.  **执行 (EX)**: ALU计算有效地址（基址 + 立即数偏移量）。
	    *   路径：ALU
	    *   延迟：$t_{ALU} = 6ns$
	5.  **访存 (MEM)**: 从ALU计算出的地址去数据存储器读取数据。
	    *   路径：数据存储器
	    *   延迟：$t_{mem} = 10ns$
	6.  **写回 (WB)**: 将从内存读出的数据写入目标寄存器（rt）。
	    *   路径：寄存器堆写
	    *   延迟：$t_{RFwrite} = 1ns$
	将这些串行路径的延迟相加，得到`lw`指令的总延迟：
	$T_{single-cycle} = t_{PCout} + t_{mem\_IF} + t_{RFread} + t_{ALU} + t_{mem\_MEM} + t_{RFwrite}$
	$T_{single-cycle} = 2ns + 10ns + 3ns + 6ns + 10ns + 1ns = 32ns$
- **结论**: 在单周期设计中，时钟周期为32ns。由于所有指令都占用一个完整的时钟周期，所以**任何指令的延迟都是32ns**。
- (2) 按多周期设计，最长和最短的指令延迟分别是多少？  
1. 最长的操作是内存访问，需要10ns 
	1.  但是，答案的解析采用了一种更接近流水线阶段划分的思路来计算时钟周期，即把**一个阶段内所有串行操作的延迟**（包括锁存器延迟）加起来，取最大值。我们按照这个思路来推导：
		1. IF阶段  
			1. PC输出 -> 读指令存储器 -> 锁存到下一级。延迟 = $t_{PCout} + t_{mem} + t_{latch} = 2ns + 10ns + 2ns = 14ns$
		2. ID阶段  
			1. 读寄存器 -> 锁存。延迟 = $t_{RFread} + t_{latch} = 3ns + 2ns = 5ns$  
		3. EX阶段  
			1. ALU计算 -> 锁存。延迟 = $t_{ALU} + t_{latch} = 6ns + 2ns = 8ns$  
		4. MEM阶段  
			1. 读/写数据存储器 -> 锁存。延迟 = $t_{mem} + t_{latch} = 10ns + 2ns = 12ns$  
		5. WB阶段  
			1. 写寄存器 -> 锁存。延迟 = $t_{RFwrite} + t_{latch} = 1ns + 2ns = 3ns$
 2. 最长的阶段是IF阶段，为14ns。所以多周期设计的时钟周期 $T_{multi-cycle} = 14ns$
	1. 最长指令  
		1. `lw`指令，需要经历IF, ID, EX, MEM, WB共5个阶段  
			1. 所需时钟周期数: 5
		    *   指令延迟: $5 \times T_{multi-cycle} = 5 \times 14ns = 70ns$ 
	2. 最短指令  
		1. `j` (jump) 指令。它只需要两个阶段：  
			1.  **IF**: 取指令。
		    2.  **ID**: 译码并直接计算出跳转地址更新PC。
			    *   所需时钟周期数: 2
			    *   指令延迟: $2 \times T_{multi-cycle} = 2 \times 14ns = 28ns$



![[Pasted image 20251117105811.png]]



![[Pasted image 20251117105819.png]]



![[Pasted image 20251117105827.png]]



![[Pasted image 20251117105834.png]]



![[Pasted image 20251117105844.png]]



![[Pasted image 20251117105851.png]]



![[Pasted image 20251117105859.png]]



![[Pasted image 20251117105935.png]]



![[Pasted image 20251117105945.png]]



![[Pasted image 20251117105951.png]]



![[Pasted image 20251117105957.png]]



![[Pasted image 20251117110010.png]]



![[Pasted image 20251117110108.png]]









![[Pasted image 20251117110114.png]]



![[Pasted image 20251117110120.png]]



![[Pasted image 20251117110126.png]]



![[Pasted image 20251117110130.png]]



![[Pasted image 20251117110150.png]]



![[Pasted image 20251117153556.png]]



![[Pasted image 20251117154301.png]]



![[Pasted image 20251117154305.png]]



![[Pasted image 20251117154319.png]]



![[Pasted image 20251117154327.png]]



![[Pasted image 20251117154335.png]]



![[Pasted image 20251117154344.png]]



![[Pasted image 20251117154526.png]]



![[Pasted image 20251117154537.png]]



![[Pasted image 20251117154546.png]]



![[Pasted image 20251117154554.png]]



![[Pasted image 20251117154611.png]]



![[Pasted image 20251117154639.png]]



![[Pasted image 20251117155947.png]]



![[Pasted image 20251117155955.png]]



![[Pasted image 20251117160003.png]]



![[Pasted image 20251117160011.png]]



![[Pasted image 20251117160018.png]]



![[Pasted image 20251117160032.png]]



![[Pasted image 20251117160050.png]]



![[Pasted image 20251117160058.png]]



![[Pasted image 20251117160104.png]]



![[Pasted image 20251117160109.png]]



![[Pasted image 20251117160115.png]]



![[Pasted image 20251117160121.png]]



![[Pasted image 20251117160127.png]]



![[Pasted image 20251117160134.png]]



![[Pasted image 20251117160142.png]]