![[912历年真题解析-组成原理篇（2024.12.2）.pdf#page=10&rect=17,377,579,808|912历年真题解析-组成原理篇（2024.12.2）, p.10]]

1. 这道题主要考察计算机组成原理中的[[流水线技术]]   [[流水线]]   [[流水线性能分析]]  
	1. 流水线时钟周期$T_{clk}$   
		1. 公式为：$T_{clk} = \max(T_{stage\_i}) + T_{reg}$
			1. 其中，$T_{stage\_i}$ 是第 $i$ 个流水段的组合逻辑延迟 ，$T_{reg}$ 是 #流水线寄存器 （题目中的“寄存器”或“锁存器”）的延迟  
	2. #流水线延迟    
		1. 指单条指令从进入流水线到执行完成所需要的总时间。对于一个 $k$ 级的流水线，其延迟为：
		    公式为：$Latency = k \times T_{clk}$   
	3. #流水线吞吐率   
		1. 指单位时间内流水线能够完成的指令数量，是衡量流水线性能的重要指标。理想情况下，当流水线“充满”后，每个时钟周期都能完成一条指令。
		    公式为：$Throughput = \frac{1}{T_{clk}}$
		    吞吐率的单位通常是 GIPS 
2. 我们整理一下已知条件：
	*   组合逻辑部件延迟：A=40ps, B=20ps, C=35ps, D=15ps, E=15ps, F=25ps。
	*   总逻辑延迟 = $40+20+35+15+15+25 = 150ps$。
	*   寄存器延迟 $T_{reg} = 10ps$。
-  (1) 4级流水线设计
1. **目标**：构建一个4级流水线，需要插入 $4-1=3$ 个寄存器。为了使流水线性能最好（即时钟周期最短），我们应该尽量让每个流水段的逻辑延迟大致相等。  
	1. 分析  
		1. 总逻辑延迟为150ps，分成4段，理想情况下每段的逻辑延迟为 $150/4 = 37.5ps$。我们根据这个理想值来划分逻辑部件：
			*   A (40ps) 本身就接近37.5ps，可以单独作为一段。
			*   B (20ps) + C (35ps) = 55ps。
			*   D (15ps) + E (15ps) = 30ps。
			*   F (25ps)。
2. 只是一个粗略的划分，我们需要尝试不同的组合。题解中给出的方案是：在AB之间、BC之间、DE之间插入寄存器。我们来分析这种划分方式：
	*   **段1**: 逻辑部件 A。逻辑延迟 $T_{stage1} = 40ps$。
	*   **段2**: 逻辑部件 B。逻辑延迟 $T_{stage2} = 20ps$。
	*   **段3**: 逻辑部件 C + D。逻辑延迟 $T_{stage3} = 35ps + 15ps = 50ps$。
	*   **段4**: 逻辑部件 E + F。逻辑延迟 $T_{stage4} = 15ps + 25ps = 40ps$。
3. 计算时钟周期  
	1. 时钟周期由最长的逻辑段决定。
		$T_{clk} = \max(40, 20, 50, 40) + T_{reg} = 50ps + 10ps = 60ps$
		这个最长的段就是由C和D组成的逻辑段，与题解“最长的流水段为C+D+锁存器=60ps”的描述一致。  
4. 计算延迟和吞吐率  
	1. 延迟  
		1. $Latency = k \times T_{clk} = 4 \times 60ps = 240ps$
	2. 最大吞吐率
	    $Throughput = \frac{1}{T_{clk}} = \frac{1}{60ps} = \frac{1}{60 \times 10^{-12}s} \approx 16.67 \times 10^9 \text{ Instructions/s} = 16.67 \text{GIPS}$
- (2) 达到最大吞吐率的设计  
1. 目标  ：要达到最大吞吐率，根据公式 $Throughput = 1/T_{clk}$，就是要使**时钟周期 $T_{clk}$ 最小化**。  
	1. 时钟周期 $T_{clk} = \max(T_{stage\_i}) + T_{reg}$。要使其最小，就必须使最长的逻辑段延迟 $\max(T_{stage\_i})$ 最小。
		#逻辑部件 是不可再分的，其中延迟最长的单个部件是A（40ps）。因此，任何流水段的逻辑延迟都不可能小于40ps（除非A本身被分成一段）。所以，$\max(T_{stage\_i})$ 的理论最小值就是最长的那个不可分部件的延迟，即40ps    
2. 设计流水线  
	1. 以40ps为上限来划分逻辑段，只要一个组合的延迟超过40ps，就必须插入寄存器。
		*   **段1**: A (40ps)。延迟为40ps，达到上限，必须在此之后插入寄存器。
		*   **段2**: B (20ps)。延迟为20ps。
		*   **段3**: C (35ps)。延迟为35ps。
		*   **段4**: D (15ps)。延迟为15ps。
		*   **段5**: E (15ps) + F (25ps) = 40ps。延迟为40ps。
	2. 这样，我们得到了一个5级流水线，各段的逻辑延迟分别为 {40ps, 20ps, 35ps, 15ps, 40ps}。寄存器被插在了A之后(AB之间)、B之后(BC之间)、C之后(CD之间)、D之后(DE之间)。
3. 计算时钟周期  
	1. $T_{clk} = \max(40, 20, 35, 15, 40) + T_{reg} = 40ps + 10ps = 50ps$
		这个最长的段是由A或者E+F组成的逻辑段，与题解“最长的流水段为A+锁存器=50ps”的描述一致。 
4. 计算延迟和吞吐率  
	1. 延迟   
		1. $Latency = k \times T_{clk} = 5 \times 50ps = 250ps$  
	2. 最大吞吐率  
		1. $Throughput = \frac{1}{T_{clk}} = \frac{1}{50ps} = \frac{1}{50 \times 10^{-12}s} = 20 \times 10^9 \text{ Instructions/s} = 20 \text{GIPS}$  
- 衍生    
	- #流水线加速比 
		- 考题可能会问，相比于不使用流水线的单周期处理器，该流水线的加速比是多少？
		    *   单周期处理器执行一条指令的时间 $T_{non-pipeline} = \text{总逻辑延迟} + \text{寄存器延迟} = 150ps + 10ps = 160ps$。
		    *   流水线处理 $n$ 条指令的时间 $T_{pipeline} = (k + n - 1) \times T_{clk}$。
		    *   当 $n$ 很大时，加速比 $S \approx \frac{T_{non-pipeline}}{T_{clk}}$。
		    *   例如，对于问题(2)中的5级流水线，其理想加速比为 $S \approx \frac{160ps}{50ps} = 3.2$
	- 流水线冲突 
		- 考题可能会给出一个指令序列，让你找出其中存在的冲突，并说明如何通过**暂停（Stall）**、数据前推（Forwarding）或分支预测（Branch Prediction）等技术来解决 
	- 流水线效率和开销
		-  **开销 (Overhead)**: 主要是指流水线寄存器的延迟。如果将流水线分得过细（例如，每1ps就插入一个寄存器），寄存器延迟的占比会越来越大，反而可能降低性能。考题可能让你分析流水线级数和性能的非线性关系。


![[Pasted image 20251117105754.png]]
[[Pasted image 20251117105801.png]]
[[MIPS处理器微架构(单周期,多周期,流水线)]]    
[[mips指令集简写]] 
-  这道题考察  #三种经典的处理器设计思想 ：单周期（Single-Cycle）、多周期（Multi-Cycle）和流水线（Pipelined）设计  
1. 单周期处理器  
	1.   **核心思想**: 每条指令都在一个时钟周期内完成。
	    *   **时钟周期**: 必须设置为**最长指令**的执行时间，因为时钟周期要能容纳下最复杂、路径最长的那条指令（通常是`lw`指令）。
	    *   **性能**: CPI (Cycles Per Instruction) 恒为1，但时钟频率很低，因为周期太长。
2. 多周期处理器
	1. **核心思想**: 将一条指令的执行过程划分为多个（通常是3-5个）基本步骤，每个步骤在一个时钟周期内完成。不同指令执行所需的步骤数可以不同  
		1. 时钟周期  
			1. 由**最长的功能单元/步骤**的延迟决定。例如，如果内存访问最慢，时钟周期就由内存访问时间决定  
		2. 性能  
			1. 时钟频率比单周期高，但CPI大于1。不同指令的CPI不同，例如`lw`需要5个周期，`j`可能只需要2个周期 
3. 流水线处理器 
	1. 核心思想  
		1.  将指令执行过程划分为多个阶段（Stage），让多条指令的不同阶段在同一时刻重叠执行，像工厂流水线一样  
	2. 时钟周期  
		1. 由**最长的流水线阶段**的延迟决定。为了让流水线顺畅流动，所有阶段的耗时必须统一，这个统一的时间就是时钟周期 
	3. 性能 
		1.  理想情况下，CPI趋近于1，并且时钟频率较高（取决于最长阶段），因此吞吐率（Throughput）极高。但会遇到数据冒险、控制冒险等问题  
- 题目参数梳理  
	*   内存（指令/数据）读/写延迟: $t_{mem}=10ns$
	*   ALU延迟: $t_{ALU}=6ns$
	*   寄存器堆（Register File）读延迟: $t_{RFread}=3ns$
	*   寄存器堆（Register File）写延迟: $t_{RFwrite}=1ns$
	*   流水线寄存器/PC 输出延迟: $t_{latch}=2ns$
-  (1) 按单周期设计，计算指令延迟  
	1. `lw`指令的执行路径如下：
	2.  **取指 (IF)**: 从PC寄存器输出地址，到指令存储器读取指令。
	    *   路径：PC -> 指令存储器
	    *   延迟：$t_{PCout} + t_{mem} = 2ns + 10ns = 12ns$
	3.  **译码/读寄存器 (ID)**: 读取基址寄存器（rs）。
	    *   路径：寄存器堆读
	    *   延迟：$t_{RFread} = 3ns$
	4.  **执行 (EX)**: ALU计算有效地址（基址 + 立即数偏移量）。
	    *   路径：ALU
	    *   延迟：$t_{ALU} = 6ns$
	5.  **访存 (MEM)**: 从ALU计算出的地址去数据存储器读取数据。
	    *   路径：数据存储器
	    *   延迟：$t_{mem} = 10ns$
	6.  **写回 (WB)**: 将从内存读出的数据写入目标寄存器（rt）。
	    *   路径：寄存器堆写
	    *   延迟：$t_{RFwrite} = 1ns$
	将这些串行路径的延迟相加，得到`lw`指令的总延迟：
	$T_{single-cycle} = t_{PCout} + t_{mem\_IF} + t_{RFread} + t_{ALU} + t_{mem\_MEM} + t_{RFwrite}$
	$T_{single-cycle} = 2ns + 10ns + 3ns + 6ns + 10ns + 1ns = 32ns$
- **结论**: 在单周期设计中，时钟周期为32ns。由于所有指令都占用一个完整的时钟周期，所以**任何指令的延迟都是32ns**。
- (2) 按多周期设计，最长和最短的指令延迟分别是多少？  
1. 最长的操作是内存访问，需要10ns 
	1.  但是，答案的解析采用了一种更接近流水线阶段划分的思路来计算时钟周期，即把**一个阶段内所有串行操作的延迟**（包括锁存器延迟）加起来，取最大值。我们按照这个思路来推导：
		1. IF阶段  
			1. PC输出 -> 读指令存储器 -> 锁存到下一级。延迟 = $t_{PCout} + t_{mem} + t_{latch} = 2ns + 10ns + 2ns = 14ns$
		2. ID阶段  
			1. 读寄存器 -> 锁存。延迟 = $t_{RFread} + t_{latch} = 3ns + 2ns = 5ns$  
		3. EX阶段  
			1. ALU计算 -> 锁存。延迟 = $t_{ALU} + t_{latch} = 6ns + 2ns = 8ns$  
		4. MEM阶段  
			1. 读/写数据存储器 -> 锁存。延迟 = $t_{mem} + t_{latch} = 10ns + 2ns = 12ns$  
		5. WB阶段  
			1. 写寄存器 -> 锁存。延迟 = $t_{RFwrite} + t_{latch} = 1ns + 2ns = 3ns$
 2. 最长的阶段是IF阶段，为14ns。所以多周期设计的时钟周期 $T_{multi-cycle} = 14ns$
	1. 最长指令  
		1. `lw`指令，需要经历IF, ID, EX, MEM, WB共5个阶段  
			1. 所需时钟周期数: 5
		    *   指令延迟: $5 \times T_{multi-cycle} = 5 \times 14ns = 70ns$ 
	2. 最短指令  
		1. `j` (jump) 指令。它只需要两个阶段：  
			1.  **IF**: 取指令。
		    2.  **ID**: 译码并直接计算出跳转地址更新PC。
			    *   所需时钟周期数: 2
			    *   指令延迟: $2 \times T_{multi-cycle} = 2 \times 14ns = 28ns$
	-  关于`j`指令周期的说明 
		- 为什么是2个周期而不是3个？在标准的 #多周期MIPS 实现中，`j`和`beq`指令的 #目标地址 计算和PC更新都在ID/Control阶段完成，不需要经过 #算术逻辑单元ALU  。因此`j`指令在第2个周期结束时就能更新PC，下一条指令就可以从新地址开始取指。所以2个周期是标准答案。答案中提到的“按三个周期算是42ns”是考虑到了某些简化的模型可能会把PC更新放到EX阶段，这是一种保守或非优化的实现  
	- **结论**: 最长指令是`lw`，延迟为**70ns**。最短指令是`j`，延迟为**28ns**。
- (3) 按五级流水线设计，处理器频率最高能到多少？  
1. 流水线设计中，时钟周期由**最长的流水线阶段**的延迟决定。这个计算我们在问题(2)中已经完成了  
	*   IF阶段延迟: 14ns
	*   ID阶段延迟: 5ns
	*   EX阶段延迟: 8ns
	*   MEM阶段延迟: 12ns
	*   WB阶段延迟: 3ns
2. 最长的阶段是IF阶段，其延迟为14ns。为了保证流水线能同步工作，时钟周期必须至少为14ns。
	$T_{pipeline} = \max(14, 5, 8, 12, 3) = 14ns$  
	1. 处理器最高频率是时钟周期的倒数：
		$f_{max} = \frac{1}{T_{pipeline}} = \frac{1}{14ns} = \frac{1}{14 \times 10^{-9} s}$
		$f_{max} = \frac{10^9}{14} Hz \approx 71.43 \times 10^6 Hz = 71.43 MHz$
	2. **结论**: 处理器频率最高能达到约**71.4MHz**。
- 衍生 
	- 性能分析与比较  
		-  计算执行一段包含多种指令的程序的总时间。公式为：$T_{total} = N_{instructions} \times CPI_{avg} \times T_{clock}$。你需要能计算出在单周期、多周期和流水线设计下，各自的平均CPI和总执行时间，并进行比较  
		- 加速比计算：例如，流水线相对于单周期的加速比是多少？  
	- #流水线冒险   [[流水线冒险]] 
	- #数据通路与控制  
		-  要求你画出单周期、多周期或流水线的数据通路图。
	    *   分析在执行某条特定指令时，数据通路中哪些线路是有效的，各个控制信号（如`RegWrite`, `ALUSrc`, `MemRead`等）的值是什么。



![[Pasted image 20251117105811.png]]
- 其核心在于**增加流水线段数不一定能提高CPU频率**。CPU的频率取决于流水线 中最慢的那个段（stage）的执行时间  [[CPU主频]]
1. 前提条件：    [[流水线性能分析]]    [[计算机性能评测的四个指标]]   #CPU频率  #时钟频率  [[MIPS处理器微架构(单周期,多周期,流水线)]]    
	1. 有五个子操作 A, B, C, D, E，它们的执行时间分别为： 
    *   A = 30ps
    *   B = 10ps
    *   C = 40ps
    *   D = 40ps
    *   E = 40ps
		*   流水线段与段之间的锁存器（latch）延迟为 5ps
2. #流水线时钟周期的计算公式 为
	$T_{clk} = \max(\text{各段的执行时间}) + \text{锁存器延迟}$
	
	**CPU频率的计算公式为：**
	$f = 1/T_{clk}$
3. 情况 (1): 将 A 和 B 合并为一段，C, D, E 各自为一段，总共4段流水线  
	1. 第一段 (A+B) 的时间 = $30\text{ps} + 10\text{ps} = 40\text{ps}$
		*   第二段 (C) 的时间 = $40\text{ps}$
		*   第三段 (D) 的时间 = $40\text{ps}$
		*   第四段 (E) 的时间 = $40\text{ps}$
		*   所有段中，最长的时间（瓶颈）是 $40\text{ps}$。
		*   因此，时钟周期 $T_{clk} = 40\text{ps} + 5\text{ps} = 45\text{ps}$。
		*   CPU 频率 $f = 1/45\text{ps} = 1/(45 \times 10^{-12} \text{s}) \approx 22.22 \text{GHz}$。
4. 情况 (2): 将 A, B, C, D, E 各自划分为一段，总共5段流水线  
	1. 第一段 (A) 的时间 = $30\text{ps}$
		*   第二段 (B) 的时间 = $10\text{ps}$
		*   第三段 (C) 的时间 = $40\text{ps}$
		*   第四段 (D) 的时间 = $40\text{ps}$
		*   第五段 (E) 的时间 = $40\text{ps}$
		*   所有段中，最长的时间（瓶颈）依然是 $40\text{ps}$（由C, D, E段决定）。
		*   因此，时钟周期 $T_{clk} = 40\text{ps} + 5\text{ps} = 45\text{ps}$。
		*   CPU 频率 $f = 1/45\text{ps} \approx 22.22 \text{GHz}$。
5. 结论 
	1. 从4段流水线增加到5段流水线，CPU的频率并没有改变。这是因为增加的划分（将A+B拆开）并没有解决真正的瓶颈——最慢的C, D, E段。因此，“提高流水线的段数**可**提高CPU的频率”这个说法不是绝对的，只有当增加段数能够**有效缩短最长段的执行时间**时，才能提高CPU频率。所以原命题为假  
- 衍生 
	- 流水线性能计算  
		- 吞吐率计算
			- 计算在 $k$ 段流水线上执行 $n$ 条指令的实际吞TP。总时间为 $T_{pipeline}=(k+n-1) \times T_{clk}$，吞吐率为 $TP=n/T_{pipeline}$。
		*  加速比计算
		    * 衡量流水线相对于非流水线执行的性能提升。
		        $S=\frac{T_{non-pipeline}}{T_{pipeline}}$
		        其中，非流水线执行总时间 $T_{non-pipeline} = n \times (\sum_{i=1}^{k} \Delta t_i)$
	- #流水线划分的原则   
		- 段划分的平衡性  
			- 理想的流水线设计应使每个段的执行时间尽可能相等。如果各段执行时间相差悬殊，则最长段会成为整个流水线的瓶颈，导致其他较快的段处于等待状态，造成硬件资源浪费 
		- 如何有效提高频率 
			- 考题可能会问，在上述例子中，如何修改才能有效提高CPU频率？答案是：需要将最长的段（C, D或E，40ps）进一步细分。例如，如果C可以被拆分为两个20ps的子段C1和C2，那么最长段就变成了30ps（A段），CPU频率就会得到提升。   
	- 流水线冒险 
		- 这是流水线技术中的核心难点，也是高频考点。指因流水线中指令的重叠执行而可能出现的错误结果。
		    *   **结构冒险：** 因硬件资源冲突（如只有一个存储器端口）导致指令无法按时执行。
		    *   **数据冒险：** 后续指令需要用到前面尚未完成指令的计算结果（如 `ADD R1, R2, R3` 后紧跟 `SUB R4, R1, R5`）。
		    *   **控制冒险：** 由分支、跳转等指令引起，导致流水线无法确定下一条要取指的指令地址。

![[Pasted image 20251117105819.png]]
![[Pasted image 20251117105827.png]]
- 我们先分析题目给出的数据：  \   [[MIPS处理器微架构(单周期,多周期,流水线)]]     
	*   各阶段延迟: IF=250ps, ID=180ps, EX=150ps, MEM=300ps, WB=200ps。
	*   寄存器延迟: 输入(写)10ps, 输出(读)10ps。   
- (1) 按照单周期、多周期、流水线设计，时钟周期最短为？请给出你的计算过程  
	- (1) 单周期   
		- **时钟周期**：由最长指令的完整执行时间决定。在`addu`, `lw`, `j`中，`lw`（加载指令）会用到所有5个阶段，所以它是最长的  
			- 计算  
				- 时钟周期等于`lw`指令顺序执行所有阶段的时间总和。
				    $T_{single} = T_{IF} + T_{ID} + T_{EX} + T_{MEM} + T_{WB}$
				    $T_{single} = 250 + 180 + 150 + 300 + 200 = 1080ps$
			- **结论**：单周期设计的时钟周期为 **1080ps**。图片中的分析是正确的，并且指出了PC不是通用寄存器，其延迟不应额外计算，这也是对的
	- (2) 多周期  
		- 时钟周期  
			- 由最耗时的单个功能阶段决定。我们需要在IF, ID, EX, MEM, WB中找到最长的一个。  
		- **计算**：
		    $T_{multi} = \max(T_{IF}, T_{ID}, T_{EX}, T_{MEM}, T_{WB})$
		    $T_{multi} = \max(250, 180, 150, 300, 200) = 300ps$
		- **结论**：多周期设计的时钟周期为 **320ps**  
	- (3) 流水线
		- **时钟周期**：与多周期设计类似，由最长的流水线阶段延迟决定（同样可能需要加上锁存器延迟）
			- $T_{pipeline} = \max(\text{各阶段延迟}) + T_{latch\_delay}$
			    $T_{pipeline} = \max(250, 180, 150, 300, 200) + 10 = 300 + 10 = 310ps$ 
			- **结论**：流水线设计的时钟周期为 **320ps** (同样，采纳图片结论以便后续推导)。  
- (2) 按照单周期、多周期、流水线设计，最短的指令延迟为？  
	- (1) 单周期  
		- 指令延迟：所有指令的延迟都等于时钟周期，因为每条指令都占用一整个长周期。
			*   **计算**：$Latency_{min} = T_{single} = 1080ps$
			*   **结论**：最短指令延迟为 **1080ps**。
	-  (2) 多周期 
		- 指令延迟  
			- 需要找到执行周期数最少的指令。
		    *   `lw`：需要5个周期 (IF, ID, EX, MEM, WB)。
		    *   `addu`：需要4个周期 (IF, ID, EX, WB)，跳过MEM阶段。
		    *   `j`：需要2个周期 (IF, ID)。在ID阶段计算出跳转地址并更新PC，指令执行即结束。
		*   **计算**：最短的指令是`j`，需要2个时钟周期。
			$Latency_{j} = CPI_{j} \times T_{multi}$
			$Latency_{j} = 2 \times 320ps = 640ps$	
		- **结论**：多周期设计下，最短指令延迟为 **640ps**。
	- (3) 流水线  
		- **指令延迟**：在理想流水线（无冲突）中，**任何一条**指令从进入流水线（IF阶段）到离开流水线（WB阶段结束），都需要经过所有5个阶段
		- 计算  
		    $Latency_{any\_instruction} = \text{流水线级数} \times T_{pipeline}$
		    $Latency_{any\_instruction} = 5 \times 320ps = 1600ps$
		- **结论**：流水线设计下，（最短）指令延迟为 **1600ps**。这对应了图片中蓝色框的答案。要注意区分延迟（Latency）和吞吐率。流水线的优势在于其高吞吐率（理想情况下每个周期产出一条指令），而不是缩短单条指令的延迟  	
- 衍生 
	- 流水线冲突  
	- 性能评估  
		- 加速比  衡量流水线相对于非流水线性能提升的指标。
	        $S = \frac{T_{non-pipeline}}{T_{pipeline}}$
	- [[流水线优化]]   
![[Pasted image 20251204174901.png]]
[[Pasted image 20251117105834.png]]
- 题的目的是找出与`lw`指令功能实现**无关**的信息传递路径。`lw`指令的作用是从数据存储器（内存）中读取一个字（word）的数据，并将其加载到指定的寄存器中  
1. 



![[Pasted image 20251204174908.png]]
[[Pasted image 20251117105844.png]]


![[Pasted image 20251204174916.png]]
[[Pasted image 20251117105851.png]]


![[Pasted image 20251204174931.png]]
[[Pasted image 20251117105859.png]]
[[Pasted image 20251117105935.png]]






![[Pasted image 20251204174953.png]]
[[Pasted image 20251117105945.png]]


![[Pasted image 20251204175003.png]]
[[Pasted image 20251117105951.png]]


![[Pasted image 20251204175011.png]]
[[Pasted image 20251117105957.png]]


![[Pasted image 20251204175021.png]]
[[Pasted image 20251117110010.png]]


![[Pasted image 20251204175128.png]]
[[Pasted image 20251117110108.png]]








![[Pasted image 20251204175135.png]]
[[Pasted image 20251117110114.png]]


![[Pasted image 20251204175143.png]]
[[Pasted image 20251117110120.png]]


![[Pasted image 20251204175151.png]]
[[Pasted image 20251117110126.png]]


![[Pasted image 20251204175158.png]]
[[Pasted image 20251117110130.png]]


![[Pasted image 20251204175206.png]]
[[Pasted image 20251117110150.png]]



![[Pasted image 20251204175215.png]]
[[Pasted image 20251117153556.png]]


![[Pasted image 20251204175227.png]]
[[Pasted image 20251117154301.png]]



![[Pasted image 20251204175236.png]]
[[Pasted image 20251117154305.png]]
[[Pasted image 20251117154319.png]]
[[Pasted image 20251117154327.png]]
[[Pasted image 20251117154335.png]]


![[Pasted image 20251204175300.png]]
[[Pasted image 20251117154344.png]]



![[Pasted image 20251204175311.png]]
[[Pasted image 20251117154526.png]]


![[Pasted image 20251204175503.png]]
[[Pasted image 20251117154537.png]]
[[Pasted image 20251117154546.png]]





![[Pasted image 20251204175520.png]]
[[Pasted image 20251117154554.png]]
![[Pasted image 20251204175913.png]]、








![[912历年真题解析-组成原理篇（2024.12.2）.pdf#page=19&rect=9,493,593,748|912历年真题解析-组成原理篇（2024.12.2）, p.19]]
![[Pasted image 20251117154611.png]]



![[Pasted image 20251117154639.png]]



![[Pasted image 20251117155947.png]]



![[Pasted image 20251117155955.png]]



![[Pasted image 20251117160003.png]]



![[Pasted image 20251117160011.png]]



![[Pasted image 20251117160018.png]]


![[Pasted image 20251204180446.png]]
[[Pasted image 20251117160032.png]]
[[Pasted image 20251117160050.png]]


![[Pasted image 20251204180513.png]]
[[Pasted image 20251117160058.png]]


![[Pasted image 20251204180523.png]]
[[Pasted image 20251117160104.png]]



![[Pasted image 20251117160109.png]]



![[Pasted image 20251117160115.png]]



![[Pasted image 20251117160121.png]]



![[Pasted image 20251117160127.png]]



![[Pasted image 20251117160134.png]]



![[Pasted image 20251117160142.png]]