![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=7&rect=20,732,583,809|826历年真题解析-数据结构篇（包括算法题）-12.15, p.7]]

1. #有序向量       两个有序向量（数组）合并为一个有序向量，通常使用 #双指针法 。比较两个向量当前的元素，将较小者放入结果数组，指针后移。每个元素只会被访问和复制一次。假设两个向量长度分别为$m$和$n$，总时间复杂度为$O(m+n)$。因为$m+n$代表数据规模，这属于**线性时间**。前半句正确。
2. #有序列表    将两个有序链表（列表）合并。同样使用 #双指针法 。比较两个链表头结点的元素，将较小者“摘下”或链接到结果链表的尾部，指针后移。这个过程只涉及指针的修改和节点的遍历，每个节点也只处理一次。总时间复杂度同样为$O(m+n)$，也是**线性时间**   
 向量（Vector）还是列表（List）   
3. **结论：** 无论是向量（Vector）还是列表（List），二路归并都可以在线性时间内完成。因此，题目说“有序列表不能”是错误的。  


- 衍生
	- 插入与删除的操作细节  （高频考点）  
		- **考点：** 考察指针修改的**顺序**。在插入节点时，必须先连接新节点与前后节点，最后再打断/修改原有节点之间的连接，否则会导致链表断裂（找不到后续节点）。
			*   **公式化记忆：** 假设在节点$p$之前插入新节点$x$（双向链表）：
			    1.  $x\to pred = p\to pred$
			    2.  $x\to succ = p$
			    3.  $p\to pred\to succ = x$ （这一步必须在第1步之后）
			    4.  $p\to pred = x$
			    时间复杂度均为$O(1)$。
-  总结
	这道题的陷阱在于让考生误以为链表的指针操作会增加时间复杂度。实际上，链表的指针操作非常高效，归并排序正是链表的强项之一（尤其是空间利用上）。  


![[Pasted image 20251119073742.png]]