![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=8&rect=23,578,578,808|826历年真题解析-数据结构篇（包括算法题）-12.15, p.8]]

![[Pasted image 20251126150418.png]]  
1. 根据组合数学原理，$n$个不同节点构成的二叉搜索树的种类数等于第$n$个 #卡特兰数 。卡特兰数的通项公式为：  [[卡特兰数常见的应用场景]] 
$$C_n=\frac{(2n)!}{n!(n+1)!}$$
	或者写作组合数形式： 
2. $n=5$，我们将数值代入公式计算：  
	1. $C_5=\frac{(2\times5)!}{5!(5+1)!}=\frac{10!}{5!6!}$  
3. 展开阶乘   
	1. $C_5=\frac{10\times9\times8\times7\times6\times5!}{5!\times(6\times5\times4\times3\times2\times1)}$
4. 最终计算  
	1. $C_5=3\times2\times7=42$  
- 衍生 
	- 进出栈序列（ #栈混洗 ）
		- **问题描述**：有$n$个元素依次入栈，求合法的出栈序列有多少种？
		*   **公式**：$C_n=\frac{1}{n+1}\binom{2n}{n}$
		*   **例子**：3个元素入栈，出栈序列有$C_3=5$种。这是最常见的变体。 
	* 括号匹配问题  
		*  **问题描述**：有$n$个左括号和$n$个右括号，这些括号能组成多少种合法的括号序列？（即任意前缀中左括号数量$\ge$右括号数量）。
		*   **公式**：$C_n$
		*   **例子**：$n=3$时，`((()))`, `()()()`, `(()())`, `(())()`, `()(())` 共5种。

![[Pasted image 20251126150431.png]]
[[Pasted image 20251119074051.png]]
1. 2019个叶节点的 #真二叉树 数目  
	1. 对于真二叉树（Full Binary Tree，又称 #严格二叉树 ，即每个节点要么是叶子，要么有两个子节点），如果叶子节点的数量为$n$，那么其构成的形态数目等于第$n-1$项卡特兰数，记为$C_{n-1}$。
	    在本题中，$n=2019$，所以真二叉树的数目为$C_{2019-1}=C_{2018}$  
2. 2018对括号组成的合法表达式数目  
	1. 这是卡特兰数最经典的定义之一。$n$对括号组成的合法匹配序列的数目等于第$n$项卡特兰数，记为$C_n$。
	    在本题中，$n=2018$，所以合法括号序列的数目为$C_{2018}$。  
3.  **结论**：
	左边的数目是$C_{2018}$，右边的数目也是$C_{2018}$。两者实际上是**相等**的。因此，题目中声称“数目少于”是错误的，答案为**错误($\times$)**。  
- 总结
	这道题考察的是考生是否知道**真二叉树的叶子数**与**卡特兰数**下标的对应关系（需减1），以及**括号匹配**与**卡特兰数**下标的对应关系（不减1）。记住$n$个节点的二叉树数量是$C_n$，而$n$个叶子的真二叉树数量是$C_{n-1}$，这是解题的关键陷阱。    

![[Pasted image 20251119074059.png]]
1.   **括号匹配问题**：
    $n$对括号组成的合法表达式数量，对应的是第$n$个卡特兰数，记为$C_n$。
    题目中给出了$2018$对括号，因此合法表达式的数量为$C_{2018}$。
2. #真二叉树 的计数问题 
	真二叉树（也称完满二叉树）是指所有节点的度要么为0（叶子节点），要么为2（内部节点）的二叉树。
    对于真二叉树，有一个重要的结论：**具有$k$个叶子节点的真二叉树的形态数量，等于第$k-1$个卡特兰数，即$C_{k-1}$。**
3. 题目要求真二叉树的数量等于$2018$对括号组成的合法表达式数量。
	即要求：
	$真二叉树数量 = 括号表达式数量$
	$C_{k-1} = C_{2018}$
4. 根据卡特兰数的一一对应关系，下标必须相等：
	$k - 1 = 2018$
	$k = 2019$
	因此，叶子节点的个数$k$为**2019**。答案选 **(B)**。  
![[Pasted image 20251119074105.png]]
- 这道题的核心在于建立“ #栈混洗”与“ #合法括号序列”之间的等价关系    
	- 分析右半部分（括号） [[栈混洗]]
		- 2024 个括号意味着有$2024\div2=1012$对括号。
		    在组合数学中，由$n$对括号构成的合法表达式的数量，等于第$n$项卡特兰数，记为$C_n$。
		    这里$n=1012$，所以合法表达式的数量为$C_{1012}$。
	- 分析左半部分（栈混洗） 
		- 题目问由多少个元素构成的栈混洗序列数量与上述相等。
	    设元素的个数为$x$。
	    对于$x$个不同元素进栈，其合法的出栈序列（栈混洗）的总数，也恰好等于第$x$项卡特兰数$C_x$。
- **建立等式：**
    题目要求两者数量“一样多”，即要求：
    $C_x=C_{1012}$
    显然，这意味着$x=1012$。
**结论：** 需要$1012$个元素构成的栈混洗序列。  

- 为什么栈混洗和括号匹配是等价的？  
	- 我们可以建立一个一一映射（Bijection）：
		*   **栈混洗：** 有$n$个元素。我们将“入栈”操作看作是一个左括号$($，“出栈”操作看作是一个右括号$)$。
		*   **限制条件：** 在任何时刻，出栈的次数不能超过入栈的次数（因为空栈不能弹出元素），且最终入栈次数等于出栈次数。
		*   这完全等价于：在括号序列中，从左往右数，右括号的数量在任何位置都不能超过左括号的数量，且左右括号总数相等。
		
		因此，$n$个元素的栈混洗方案数 $=$ $n$对括号的合法排列数 $=$ $C_n$。


![[Pasted image 20251119074120.png]]

这是一道关于 #逆波兰表达式RPN  也称为**后缀表达式**的题目。    [[逆波兰表达式RPN]] 
1. #逆波兰表达式的计算规则  
	1. 我们需要使用一个**栈（Stack）**数据结构。
		1.  从左到右扫描表达式。
		2.  遇到**数字**：压入栈中。
		3.  遇到**运算符**：从栈中弹出所需数量的操作数（通常是2个），进行运算，将结果压回栈中。
2. **针对本题的（修正性）推导：**
	设未知运算符为 $?$。
	表达式为：`0 ! * 2 2 * 6 + ^ 18 8 ? 9 / *`  
	1. 我们可以将表达式分为两部分来看：左侧部分和右侧部分，最后通过一个 `*` 连接  
		1. 第一步：分析左侧部分 `0 ! * 2 2 * 6 + ^`  
			1.  `0`：入栈。栈：$[0]$  
			2.  `!`：阶乘运算（单目）。$0!=1$。栈：$[1]$  
			3. `*`：**此处是题目回忆错误点**。乘法需要两个操作数，但栈中只有一个 $1$。为了继续推导，我们假设这里原本是一个能让逻辑通顺的数字或操作，或者假设左侧部分最终计算出一个基准值，记为 $A$。  
				1. 根据常见考题套路（如 $2^{10}=1024$），我们看后面的部分：
				    *   `2 2 *` $\rightarrow$ $2\times2=4$。
				    *   `6 +` $\rightarrow$ $4+6=10$。
				    *   `^` $\rightarrow$ 幂运算。
				    *   如果前面的基数是 $2$，那么 $2^{10}=1024$。这是一个在计算机考题中非常常见的数字。
		2. 第二步：分析右侧部分 `18 8 ? 9 /`  
			1. 此时栈中已有左侧的结果 $A$（假设为 1024）  
				*   `18`：入栈。
				*   `8`：入栈。
				*   `?`：这是我们要找的运算符。弹出 8 和 18，计算 $18?8$。设结果为 $B$。栈：$[A, B]$。
				*   `9`：入栈。栈：$[A, B, 9]$。
				*   `/`：弹出 9 和 $B$，计算 $B/9$。设结果为 $C$。栈：$[A, C]$。
		3. 第三步：最终运算 `*`  
			2. `*`：弹出 $C$ 和 $A$，计算 $A \times C$。
				*   题目给出最终结果为 **2016**。 
	2. 逆向求解：  
		1. 方程为：$A \times ((18 ? 8) / 9) = 2016$  
	3. 假设左侧部分 $A$ 是 $1024$（基于 $2^{10}$ 的推测），那么 $1024 \times C = 2016$，得出 $C \approx 1.96$。在整数运算的逆波兰题中，这通常意味着数字记忆有误  
3. 如果这是一道正常的题目，逻辑可能是这样的：左边算出 $2016$，右边算出 $1$，最终 $2016 \times 1 = 2016$。要让 `18 8 ? 9 /` 等于 1，若 $?$ 是 `+`，$(18+8)/9 = 26/9 \approx 2$；若 $?$ 是 `-`，$(18-8)/9 = 10/9 = 1$。所以如果是求结果不变，减法可能更合理。但既然答案给的是 `/`，说明原题的数字可能是类似 `72 8 / 9 /` ($72/8=9, 9/9=1$) 这样的组合。  
- 衍生的考点  
	- 中缀表达式转后缀表达式   #中缀转后缀  
		-   **考点：** 给定如 $a+b*c+(d*e+f)*g$ 的普通表达式，要求转换为后缀表达式。
			*   **方法：** 同样利用栈，但这次栈用来存运算符。
			    *   遇到数字直接输出。
			    *   遇到左括号 $($ 入栈。
			    *   遇到右括号 $)$ 弹出栈顶直到遇到 $($。
			    *   遇到运算符，比较优先级。若当前运算符优先级 $\le$ 栈顶运算符，则弹出栈顶输出，重复比较；否则入栈。
	- #表达式树的遍历     
		- **考点：** 给出一棵二叉树，叶子节点是操作数，内部节点是运算符。
		*   **公式/关系：**
		    *   **前序遍历 (Pre-order Traversal)** $\rightarrow$ **波兰表达式 (前缀)**
		    *   **中序遍历 (In-order Traversal)** $\rightarrow$ **中缀表达式** (需加括号)
		    *   **后序遍历 (Post-order Traversal)** $\rightarrow$ **逆波兰表达式 (后缀)**
		    *   例如：对于树结构，根节点为 $+$，左子树为 $a$，右子树为 $b$，后序遍历即为 $a b +$。
	*   #栈的操作深度  
		-   **考点：** 在计算某个逆波兰表达式的过程中，栈内元素个数的最大值是多少？
			*   **示例：** 对于 $1 \ 2 \ 3 \ * \ +$，
			    *   Push 1 (深度1)
			    *   Push 2 (深度2)
			    *   Push 3 (深度3)
			    *   Pop 2,3 Calc *, Push 6 (深度2)
			    *   Pop 1,6 Calc +, Push 7 (深度1)
			    *   最大深度为 3
	- #前缀表达式  
		- **考点：** 运算符在操作数之前。
		*   **计算方法：** 从**右向左**扫描，遇到数字入栈，遇到运算符弹出栈顶两个数计算（注意操作数顺序与RPN相反），结果入栈。
		*   **公式表示：** 类似 $+ a b$ 表示 $a+b$。

![[Pasted image 20251126150506.png]]
[[Pasted image 20251119074419.png]]
[[Pasted image 20251119074507.png]]
[[逆波兰表达式RPN]]  

1. 第一步：计算前半部分  
	1.  $0!$：$0$的阶乘是$1$。栈：$[1]$
	2.  $1$：入栈。栈：$[1, 1]$
	3.  $+$：弹出$1, 1$，计算$1+1=2$。栈：$[2]$
	4.  $2$：入栈。栈：$[2, 2]$
	5.  $3!$：$3$的阶乘是$6$。栈：$[2, 2, 6]$
	6.  $4$：入栈。栈：$[2, 2, 6, 4]$
	7.  $+$：弹出$4, 6$，计算$6+4=10$。栈：$[2, 2, 10]$
	8.  $^{\wedge}$（乘方）：弹出$10, 2$，计算$2^{10}=1024$。栈：$[2, 1024]$
	9.  $*$：弹出$1024, 2$，计算$2*1024=2048$。栈：$[2048]$
2. 第二步：计算中间部分  
	1. 此时栈底已经是$2048$，我们继续处理后面的数字：
		1. $5$：入栈。栈：$[2048, 5]$
		2. $6!$：$6$的阶乘是$720$。栈：$[2048, 5, 720]$
		3. $7$：入栈。栈：$[2048, 5, 720, 7]$
		4. $*$：弹出$7, 720$，计算$720*7=5040$。栈：$[2048, 5, 5040]$
		5. $8!$：$8$的阶乘是$40320$。栈：$[2048, 5, 5040, 40320]$
3. 第三步：处理未知运算符 ?  
	1. 此时遇到了未知运算符$?$。根据规则，它作用于栈顶的两个数。
		设$x=5040?40320$。
		执行后，栈变为：$[2048, 5, x]$
4. 第四步：继续后续运算并建立方程 
	1. $/$：弹出$x, 5$，计算$5/x$。栈：$[2048, 5/x]$
	2. $-$：弹出$5/x, 2048$，计算$2048 - 5/x$。栈：$[2048 - 5/x]$
	3. $9$：入栈。栈：$[2048 - 5/x, 9]$
	4. $+$：弹出$9, (2048 - 5/x)$，计算$2048 - 5/x + 9$。
5. 第五步：求解  
	1. 题目给出最终结果为$2017$，因此建立方程：
		$2048 - \frac{5}{x} + 9 = 2017$
		$2057 - \frac{5}{x} = 2017$
		$\frac{5}{x} = 40$
		$x = \frac{5}{40} = \frac{1}{8}$
	回到第三步，我们需要找到一个运算符$?$，使得：
	$5040 \ ? \ 40320 = \frac{1}{8}$
	
	观察数字关系：
	$5040 \times 8 = 40320$
	所以，$5040 \div 40320 = \frac{5040}{40320} = \frac{1}{8}$
	
	因此，**? 处的运算符为除号（/）**。对应选项 **(D)**。



![[Pasted image 20251126150502.png]]

[[Pasted image 20251119074513.png]]
- 考察**编译原理**与**数据结构**结合的一个经典工程权衡问题  
1. 答案的核心在于**“执行频率”**。在计算机程序中，一个表达式往往不是只计算一次，而是写在循环、函数中被成千上万次地调用  
	1. 建立一个简单的成本模型来理解：
		设$C_{conv}$为将中缀表达式转换为逆波兰式的成本，$C_{infix}$为直接解析并计算中缀表达式的成本，$C_{rpn}$为计算逆波兰式的成本。
		已知$C_{rpn}<C_{infix}$（因为逆波兰式不需要判断优先级和括号），且$C_{conv}\approx C_{infix}$    [[逆波兰式（ 后缀表达式RPN）的求值算法]]  
	2. **如果只计算 1 次：**
	    *   常规方式成本：$1\times C_{infix}$
	    *   逆波兰方式成本：$C_{conv}+1\times C_{rpn}$
	    *   此时两者差别不大，甚至常规方式略优
	3.  **如果计算 $N$ 次（例如在循环中）：**
	    *   常规方式成本：$N\times C_{infix}$（每次都要重新解析优先级、括号）。
	    *   逆波兰方式成本：$C_{conv}+N\times C_{rpn}$（只转换一次，后面全是纯粹的堆栈运算）。
	    *   当$N$很大时，由于$C_{rpn}$远小于$C_{infix}$，逆波兰方式的**总体效率**会显著高于常规方式。
	4. **总结：** 转换的意义在于“一次编译（转换），多次运行（求值）”，消除了重复计算时的优先级解析开销  
		[[常规表达式（中缀表达式）]]   [[表达式转换（前中后缀）]]
- 衍生 
	- [[中缀转后缀的手工转换]]  
		- **题型：** 给定一个中缀表达式，写出其对应的逆波兰式。 
	- 栈的操作过程与深度  
		- **题型：** 给定一个后缀表达式，问在求值过程中，栈内元素的变化，或者栈的最大深度是多少。
			**示例：** 计算后缀表达式$1\ 2\ 3\ +\ \times$。
			1.  扫描$1$：栈$[1]$
			2.  扫描$2$：栈$[1,2]$
			3.  扫描$3$：栈$[1,2,3]$（此时栈深最大为3）
			4.  扫描$+$：弹出$3,2$，算$2+3=5$，压入$5$。栈$[1,5]$
			5.  扫描$\times$：弹出$5,1$，算$1\times5=5$，压入$5$。栈$[5]$
	- 表达式树（二叉树）的遍历  
		- **题型：** 表达式与二叉树的相互转换。
			**知识点：**
			*   **中序遍历**一棵表达式树 $\approx$ **中缀表达式**（需加括号）。
			*   **后序遍历**一棵表达式树 $=$ **后缀表达式**（逆波兰式）。
			*   **前序遍历**一棵表达式树 $=$ **前缀表达式**（波兰式）。
			**公式：** 若根节点是运算符$\theta$，左子树为$L$，右子树为$R$，则逆波兰式为$L\ R\ \theta$
	- 前缀表达式（波兰式）  
		- **题型：** 与逆波兰式类似，但运算符在操作数之前。
			**求值逻辑：** **从右向左**扫描，或者用两个栈。
			**示例：** 中缀$A+B$对应的前缀是$+AB$。



![[Pasted image 20251126150535.png]][[Pasted image 20251119074518.png]]


[[c++运算符优先级]]   
 [[逆波兰式（ 后缀表达式RPN）的求值算法]]  
逆波兰式也叫后缀表达式，其计算规则是：**从左到右扫描表达式，遇到数字就压入栈中，遇到运算符就弹出栈顶的两个操作数进行计算（最后弹出的数为左操作数，先弹出的为右操作数），并将结果重新压入栈中**  
1. 我们按照这个规则逐步计算表达式：
	$0!1+23!4+^\wedge \times 56!7 \times 8! ? / - 9 +$
2. 第一步：计算前半部分 $0!1+23!4+^\wedge \times$  
	1. $0!$：$0$的阶乘是$1$。栈：$[1]$
	2.  $1$：入栈。栈：$[1, 1]$
	3.  $+$：弹出$1, 1$，计算$1+1=2$。栈：$[2]$
	4.  $2$：入栈。栈：$[2, 2]$
	5.  $3!$：$3$入栈算阶乘为$6$。栈：$[2, 2, 6]$
	6.  $4$：入栈。栈：$[2, 2, 6, 4]$
	7.  $+$：弹出$4, 6$，计算$6+4=10$。栈：$[2, 2, 10]$
	8.  $^\wedge$（乘方）：弹出$10$（指数）和$2$（底数），计算$2^{10}=1024$。栈：$[2, 1024]$
	9.  $\times$：弹出$1024, 2$，计算$2\times1024=2048$。栈：$[2048]$
3. 第二步：计算中间部分 $56!7 \times 8! ?$  
	栈底保留了$2048$。
	1.  $5$：入栈。栈：$[2048, 5]$
	2.  $6!$：$6$入栈算阶乘为$720$。栈：$[2048, 5, 720]$
	3.  $7$：入栈。栈：$[2048, 5, 720, 7]$
	4.  $\times$：弹出$7, 720$，计算$720\times7=5040$。栈：$[2048, 5, 5040]$
	5.  $8!$：$8$入栈算阶乘为$40320$。栈：$[2048, 5, 5040, 40320]$
	6.  $?$：这是我们要填的运算符。它将作用于栈顶的两个数$5040$和$40320$。
	    设 $x = 5040 ? 40320$。
	    计算后栈变为：$[2048, 5, x]$
4. 第三步：计算后半部分 $/ - 9 +$ 并求解   
	1.  $/$：弹出$x, 5$，计算$5/x$。栈：$[2048, \frac{5}{x}]$
	2.  $-$：弹出$\frac{5}{x}, 2048$，计算$2048 - \frac{5}{x}$。栈：$[2048 - \frac{5}{x}]$
	3.  $9$：入栈。栈：$[2048 - \frac{5}{x}, 9]$
	4.  $+$：计算$(2048 - \frac{5}{x}) + 9$
5. 第四步：建立方程  
	1. 题目给出最终结果为$2017$，因此：
		$2048 - \frac{5}{x} + 9 = 2017$
		$2057 - \frac{5}{x} = 2017$
		$\frac{5}{x} = 2057 - 2017$
		$\frac{5}{x} = 40$
		$x = \frac{5}{40} = \frac{1}{8}$
6. 第五步：确定运算符 
	1. 我们需要找到一个运算符$?$，使得：
		$5040 ? 40320 = \frac{1}{8}$
		
		观察数字关系：$40320 \div 5040 = 8$，即$5040 \times 8 = 40320$。
		显然，$5040 \div 40320 = \frac{5040}{40320} = \frac{1}{8}$。
	1. 因此，**$?$ 处的运算符应为除号**  
- 衍生 
	- 栈的最大深度  
		- **考法**：在计算某个逆波兰式的过程中，栈中最多同时存在多少个元素？
	    *   **分析**：在本题中，计算到$8!$入栈时，栈内元素为$[2048, 5, 5040, 40320]$，深度达到4。  
	* 非法表达式判断  
		*  **考法**：给出一个字符串，判断其是否为合法的逆波兰式。
	    *   **判据**：最终栈内只能剩下一个元素；运算过程中栈内元素数量必须满足运算符需求（例如遇到双目运算符时栈内至少要有2个数）。 



![[Pasted image 20251126150542.png]]
[[Pasted image 20251119074534.png]]
1. 第一步：按运算优先级加括号    #中缀转后缀  
	1. 原则：优先级高的先算。顺序是：阶乘(!) > 乘方(^) > 乘除(× /) > 加减(+ -)  
		1. **处理最高优先级（阶乘 !）：**
		    `((0!) + 1) × 2 ^ ((3!) + 4) - ((5!) / 6 + (7 - (8 - 9)))`
		2.  **处理括号内的加减和最内层运算：**
		    `(((0!) + 1)) × 2 ^ (((3!) + 4)) - ((5!) / 6 + (7 - (8 - 9)))`
		3.  **处理乘方（^）：** *注：乘方优先级高于乘法*
		    `(((0!) + 1)) × (2 ^ (((3!) + 4))) - ...`
		4.  **处理乘除（× /）：**
		    左边乘法部分：`((((0!) + 1)) × (2 ^ (((3!) + 4))))`
		    右边除法部分：`(((5!) / 6))`
		5.  **处理加减（+ -）：**
		    右边加法部分：`((((5!) / 6)) + (7 - (8 - 9)))`
		    **整体减法（最外层）：**
		    `(( 左边整体 ) - ( 右边整体 ))`
	2. **完全加括号后的最终逻辑结构：**
	`((((0!) + 1) × (2 ^ ((3!) + 4))) - (((5!) / 6) + (7 - (8 - 9))))`  
2. 第二步：运算符后移（转后缀的核心）  
	1. 将运算符移到紧邻的**右括号**外面。
		*   `0! + 1` 变 `0! 1 +`
		*   `3! + 4` 变 `3! 4 +`
		*   `2 ^ (...)` 变 `2 (...) ^`
		*   左边整体相乘： `... ×`
		*   `5! / 6` 变 `5! 6 /`
		*   `8 - 9` 变 `8 9 -`
		*   `7 - ...` 变 `7 ... -`
		*   右边整体相加： `... +`
		*   最后中间的减号： `左边 右边 -`
3. 第三步：去括号  
	1. 把括号全部去掉，剩下的就是逆波兰表达式：
		**`0! 1 + 2 3! 4 + ^ × 5! 6 / 7 8 9 - - + -`**
	




![[Pasted image 20251126150551.png]]
[[Pasted image 20251119074542.png]]
[[Pasted image 20251119074546.png]]
#逆波兰式（后缀表达式RPN求值算法）  
	借助一个栈（Stack），从左向右扫描表达式。遇到数字就压入栈中；遇到运算符，就从栈顶弹出相应数量的操作数进行计算（最后弹出的为左操作数，最先弹出的为右操作数），并将结果压回栈中。
[[逆波兰式（ 后缀表达式RPN）的求值算法]]
1. 给定的表达式为：
	`0 ! 1 2 + 3 4 + ? + 5 ! 6 7 + 8 - 9 * + -`
	
	我们设未知运算符 `?` 的运算结果为 $X$（即设 $3 \ ? \ 7 = X$），逐步推导栈的变化：
	
	1.  **`0`**: 入栈。栈：$[0]$
	2.  **`!`**: 单目运算符（阶乘）。弹出 $0$，计算 $0! = 1$，压入 $1$。栈：$[1]$
	3.  **`1`**: 入栈。栈：$[1, 1]$
	4.  **`2`**: 入栈。栈：$[1, 1, 2]$
	5.  **`+`**: 弹出 $2$ 和 $1$，计算 $1+2=3$，压入 $3$。栈：$[1, 3]$
	6.  **`3`**: 入栈。栈：$[1, 3, 3]$
	7.  **`4`**: 入栈。栈：$[1, 3, 3, 4]$
	8.  **`+`**: 弹出 $4$ 和 $3$，计算 $3+4=7$，压入 $7$。栈：$[1, 3, 7]$
	9.  **`?`**: 未知运算符。弹出 $7$ 和 $3$。此时运算为 $3 \ ? \ 7$。我们将这个结果记为 $X$。压入 $X$。栈：$[1, X]$
	10. **`+`**: 弹出 $X$ 和 $1$，计算 $1+X$，压入 $1+X$。栈：$[1+X]$
	11. **`5`**: 入栈。栈：$[1+X, 5]$
	12. **`!`**: 弹出 $5$，计算 $5! = 120$，压入 $120$。栈：$[1+X, 120]$
	13. **`6`**: 入栈。栈：$[1+X, 120, 6]$
	14. **`7`**: 入栈。栈：$[1+X, 120, 6, 7]$
	15. **`+`**: 弹出 $7$ 和 $6$，计算 $6+7=13$，压入 $13$。栈：$[1+X, 120, 13]$
	16. **`8`**: 入栈。栈：$[1+X, 120, 13, 8]$
	17. **`-`**: 弹出 $8$ 和 $13$，计算 $13-8=5$，压入 $5$。栈：$[1+X, 120, 5]$
	18. **`9`**: 入栈。栈：$[1+X, 120, 5, 9]$
	19. **`*`**: 弹出 $9$ 和 $5$，计算 $5 \times 9=45$，压入 $45$。栈：$[1+X, 120, 45]$
	20. **`+`**: 弹出 $45$ 和 $120$，计算 $120+45=165$，压入 $165$。栈：$[1+X, 165]$
	21. **`-`**: 弹出 $165$ 和 $(1+X)$。注意顺序：栈底的是左操作数。计算 $(1+X) - 165$。
	    最终表达式的值为：$X + 1 - 165 = X - 164$。

	**解方程：**
	题目已知最终结果为 $2023$，所以：
	$X - 164 = 2023$
	$X = 2023 + 164$
	$X = 2187$
	**确定运算符：**
	回顾步骤9，我们知道 $X$ 是由 $3$ 和 $7$ 通过运算符 `?` 计算得来的，即：
	$3 \ ? \ 7 = 2187$
	
	我们需要在题目给出的运算符（+, -, *  , /, ^）中寻找符合条件的：
	*   $3+7=10$
	*   $3-7=-4$
	*   $3*7=21$
	*   $3/7 \approx 0.42$
	*   $3^7 = 3 \times 3 \times 3 \times 3 \times 3 \times 3 \times 3 = 2187$
因此，被遮挡的运算符是 **乘方（^）**
- 衍生 
	- 复杂运算符的处理  
		- **考法**：加入右结合运算符（如幂运算 $2^3^4$）或单目运算符（如负号、阶乘、逻辑非）。本题中就出现了单目运算符 `!`，需要注意它只消耗栈顶的一个元素  

![[Pasted image 20251126150601.png]]
[[Pasted image 20251119074554.png]]

- 这道题考察的是栈的特性以及 #栈混洗的计数问题  
1. **输入序列**：MAMAMIA
	*   **目标输出序列**：MAMAMIA
	*   **操作限制**：栈是后进先出（LIFO）的结构。只能进行入栈（push，题解中记为 j）和出栈（pop，题解中记为 c）操作
2. 观察序列中的字符 **'I'**。
	*   输入中，'I' 是第 6 个字符。
	*   输出中，'I' 也是第 6 个字符。
	*   由于 'I' 在整个序列中是唯一的，这意味着在处理 'I' 时，栈必须处于一种特定的状态。具体来说，为了输出 'I'，我们必须先将 'I' 入栈，然后立即出栈（因为输出序列中 'I' 紧接着前面的 'M'，且后面紧跟 'A'）。
	*   这意味着问题可以被 **'I'** 分割成两个独立的部分：
	    1.  前半部分：输入 **MAMAM** $\rightarrow$ 输出 **MAMAM**
	    2.  后半部分：输入 **A** $\rightarrow$ 输出 **A**
3. 后半部分分析  
	1.  输入 'A'，输出 'A'。
		*   只有一种操作方式：入栈、出栈。即 $jc$。
		*   因此，总方案数取决于前半部分 **MAMAM** 有多少种合法的出栈方式。
4.  前半部分分析（核心难点）  
	1. 我们需要找出输入 $M_1A_2M_3A_4M_5$ 能够得到输出 $M_1A_2M_3A_4M_5$（字符匹配即可，下标用于区分位置）的所有操作序列。
	
		我们通过枚举所有可能的“入栈-出栈”组合来计数。记 $j$ 为入栈，$c$ 为出栈。
	
	*   **情况 1：完全顺序（Serial）**
	    *   每个元素入栈后立即出栈。
	    *   序列：$jcjcjcjcjc$
	    *   解释：$M$进$M$出，$A$进$A$出...
	    *   对应题解中的 (1)。
	
	*   **情况 2：局部嵌套（Nest 1-3）**
	    *   前三个字符 $MAM$ 形成嵌套（即 $M$进$A$进$M$进，然后 $M$出$A$出$M$出），后面两个字符顺序处理。
	    *   序列：$jjjcccjcjc$
	    *   解释：处理完前三个得到 MAM，栈空，再处理后两个。
	    *   对应题解中的 (2)。
	
	*   **情况 3：局部嵌套（Nest 3-5）**
	    *   前两个字符顺序处理，后三个字符 $MAM$ 形成嵌套。
	    *   序列：$jcjcjjjccc$
	    *   解释：先输出 MA，栈空，再对剩下的 MAM 进行嵌套操作。
	    *   对应题解中的 (3)。
	
	*   **情况 4：局部嵌套（Nest 2-4）**
	    *   第一个 $M$ 顺序处理，中间的 $AMA$ 形成嵌套，最后一个 $M$ 顺序处理。
	    *   序列：$jcjjjcccjc$
	    *   解释：$M$出，然后 $A$进$M$进$A$进 $\rightarrow$ $A$出$M$出$A$出，最后 $M$进$M$出。
	    *   对应题解中的 (4)。
	
	*   **情况 5：完全嵌套（Full Nest）**
	    *   所有 5 个字符全部入栈，然后全部出栈。
	    *   序列：$jjjjjccccc$
	    *   解释：栈内变为 $M_1A_2M_3A_4M_5$，出栈顺序为 $M_5A_4M_3A_2M_1$，字符序列依然是 MAMAM。
	    *   对应题解中的 (5)。
	
	*   **情况 6：交错嵌套 A（Interleaved 1）**
	    *   先入栈 $M_1A_2M_3$，出栈 $M_3$（得M），此时栈剩 $M_1A_2$。
	    *   接着入栈 $A_4$，出栈 $A_4$（得A）。
	    *   接着入栈 $M_5$，出栈 $M_5$（得M）。
	    *   最后出栈 $A_2$（得A），出栈 $M_1$（得M）。
	    *   序列：$jjjcjcjccc$
	    *   对应题解中的 (6)。
	
	*   **情况 7：交错嵌套 B（Interleaved 2）**
	    *   先入栈 $M_1A_2M_3$，出栈 $M_3$（得M），此时栈剩 $M_1A_2$。
	    *   接着出栈 $A_2$（得A），此时栈剩 $M_1$。
	    *   接着入栈 $A_4M_5$，出栈 $M_5$（得M），出栈 $A_4$（得A）。
	    *   最后出栈 $M_1$（得M）。
	    *   序列：$jjjccjjccc$
	    *   对应题解中的 (7)。
	
	**总结：**
	前半部分共有 7 种方案，后半部分有 1 种方案。
	总方案数 = $7\times1=7$ 种。
	[[卡特兰数常见的应用场景]]     
		如果输入序列是 $1,2,3,\dots,n$（即所有元素互不相同），要求输出序列也是某种特定的排列，或者问有多少种可能的输出序列，这通常与卡特兰数有关。
			卡特兰数的通项公式为：
			$C_n=\frac{1}{n+1}\binom{2n}{n}=\frac{(2n)!}{(n+1)!n!}$
	  *   例如，若输入是 ABC，输出有多少种可能？答案是 $C_3=5$ 种。
	*   **注意**：本题不能直接套用卡特兰数公式，因为输入序列中有**重复元素**（M 和 A 重复出现）。重复元素使得某些在不同元素情况下非法的出栈序列变得合法（因为 $M_1$ 和 $M_3$ 看起来是一样的），或者限制了某些特定的匹配。本题必须通过具体场景的具体分析（如上述枚举）来解决
-  衍生  
	-  判断出栈序列的合法性  
		- **题目形式**：给定输入序列 $1,2,3,4,5$，判断下列哪个**不是**合法的出栈序列？
			*   **核心技巧**：对于出栈序列中的任意两个数 $i$ 和 $j$，如果 $i$ 在 $j$ 之前出现且 $i<j$，则在 $i$ 和 $j$ 之后出现的所有小于 $j$ 的数必须以**降序**排列。
			*   **通俗理解**：如果你先输出了一个较大的数（意味着它后面的数都已入栈），那么比它小的那些数一定还在栈里，只能从大到小依次出来
	- 包含重复元素的栈混洗  
		- **题目形式**：如本题，输入 AAB，求合法的输出序列有哪些？
			*   **解法**：需要手动模拟。
			    *   输入 AAB。
			    *   可能输出：
			        *   AAB (进A出A, 进A出A, 进B出B)
			        *   ABA (进A, 进A出A, 进B出B, 出A)
			        *   BAA (进A, 进A, 进B, 出B, 出A, 出A)
			    *   这类题目通常考察细致的逻辑推演能力。
	-   #栈的应用场景 #栈的应用 [[栈的应用]]
		- **表达式求值**：中缀表达式转后缀表达式。
		*   **括号匹配**：判断字符串中的括号是否成对合法闭合。
		*   **函数递归调用**：计算机底层使用栈来保存函数调用的上下文。





![[Pasted image 20251126150606.png]]
[[Pasted image 20251119074601.png]]

- 主要考察对栈的“后进先出”（LIFO, Last In First Out）特性的理解，以及在有重复元素情况下的出栈序列计数  
1. 观察序列中的特殊字符 **'I'**。
	输入中 'I' 是第6个字符，输出中 'I' 也是第6个字符。由于栈的特性，要输出 'I'，必须先让 'I' 进栈。而在 'I' 进栈之前，它前面的 $M_1 A_1 M_2 A_2 M_3$ 必须已经处理完毕（要么已经出栈，要么还在栈底）。
	但在输出序列中，'I' 之前恰好是 $M A M A M$。这意味着在处理 'I' 之前，我们必须完成“输入 MAMAM $\rightarrow$ 输出 MAMAM”的过程，且栈必须清空（或者剩下的元素不能阻挡 'I' 的输出，但这里 'I' 紧接着就要输出，且后面只剩一个 'A'，所以处理 'I' 时栈必须为空，或者只包含后续不需要优先输出的元素。考虑到输出顺序完全一致，处理 'I' 时栈必须为空，否则无法按序输出前面的 MAMAM）
2. 处理完 'I' 后（进栈立即出栈），剩下的输入是 'A'，输出也是 'A'，只有 1 种方式（进栈出栈）  
	1. 因此，问题的核心简化为：**有多少种进出栈方案，使得输入 "MAMAM" 能够输出 "MAMAM"？** 
-  我们采用**枚举法（分类讨论）**，根据“哪一个输入的 M 对应输出的第一个 M”来分类：
	**目标输出：** $M \ A \ M \ A \ M$
	**输入流：** $M_1, A_1, M_2, A_2, M_3$
1. 情况一：输出的第一个 M 是输入的 $M_1$   
	1. 操作：$M_1$ 进，$M_1$ 出。
		剩余任务：输入 $A_1 M_2 A_2 M_3 \rightarrow$ 输出 $A M A M$。
		*   **子情况 1.1：输出的第一个 A 是输入的 $A_1$**
		    *   操作：$A_1$ 进，$A_1$ 出。
		    *   剩余：$M_2 A_2 M_3 \rightarrow M A M$。
		    *   这里又有两种可能：
		        *   (1) 顺序进出：$M_2$ 进出，$A_2$ 进出，$M_3$ 进出。序列：`jc jc jc`。
		        *   (2) 嵌套：$M_2, A_2, M_3$ 进，$M_3, A_2, M_2$ 出。序列：`jjjccc`。
		    *   **小计：2种** (对应图中方案 1, 3)
		1. **子情况 1.2：输出的第一个 A 是输入的 $A_2$**
		    *   操作：$A_1$ 进（压栈），$M_2$ 进（压栈），$A_2$ 进，然后 $A_2$ 出。
		    *   此时栈中为 $[A_1, M_2]$。
		    *   接着输出 M：栈顶 $M_2$ 出。
		    *   接着输出 A：栈顶 $A_1$ 出。
		    *   最后 $M_3$ 进出。
		    *   **小计：1种** (对应图中方案 4)
		2. **情况一总计：3种**
2. 情况二：输出的第一个 M 是输入的 $M_2$  
	1. 操作：$M_1, A_1, M_2$ 依次进栈，然后 $M_2$ 出栈。
		此时栈内状态：$[M_1, A_1]$（$A_1$ 在栈顶）。
		剩余输入：$A_2, M_3$。
		剩余输出：$A \ M \ A \ M$。
	2. **子情况 2.1：利用栈顶的 $A_1$ 作为下一个输出 A**
	    *   操作：$A_1$ 出栈。
	    *   此时栈内：$[M_1]$。需要输出 M。
	    *   **分支 2.1.1：利用栈顶 $M_1$ 输出 M**
	        *   操作：$M_1$ 出栈。栈空。
	        *   剩余 $A_2, M_3 \rightarrow A M$（顺序进出）。
	        *   **小计：1种** (对应图中方案 2)
	    *   **分支 2.1.2：保留栈顶 $M_1$，利用 $M_3$ 输出 M**
	        *   操作：$A_2$ 进，$M_3$ 进。此时栈：$[M_1, A_2, M_3]$。
	        *   出栈顺序必须是 $M_3, A_2, M_1$。正好对应输出 $M, A, M$。
	        *   **小计：1种** (对应图中方案 7)
	3.  **子情况 2.2：不使用栈顶 $A_1$，利用输入的 $A_2$ 作为下一个输出 A**
	    *   操作：$A_2$ 进， $A_2$ 出。
	    *   此时栈内：$[M_1, A_1]$。需要输出 M。
	    *   栈顶是 $A_1$，不匹配 M，必须进栈 $M_3$。
	    *   操作：$M_3$ 进，$M_3$ 出。
		*   此时栈内：$[M_1, A_1]$。依次出栈 $A_1, M_1$ 对应输出 $A, M$。
	    *   **小计：1种** (对应图中方案 6)
	**情况二总计：3种**
3. 情况三：输出的第一个 M 是输入的 $M_3$  
	操作：一直进栈直到 $M_3$。
	$M_1, A_1, M_2, A_2, M_3$ 进。
	此时栈：$[M_1, A_1, M_2, A_2, M_3]$。
	出栈只能是：$M_3, A_2, M_2, A_1, M_1$。
	输出序列为 $M A M A M$，完全符合。
	**情况三总计：1种** (对应图中方案 5)
**最终统计：**
$3 (\text{情况一}) + 3 (\text{情况二}) + 1 (\text{情况三}) = 7$ 种。

所以答案选 **(D)**。

- 衍生 
	- 卡特兰数  
		- 如果输入序列是 $n$ 个**不重复**的元素（如 1, 2, 3... n），那么合法的出栈序列总数由卡特兰数公式给出：
        $C_n = \frac{1}{n+1}\binom{2n}{n}$
	    *   **注意**：本题不能直接套用卡特兰数公式，因为要求输出序列必须是特定的 "MAMAMIA"，而不是任意合法的排列。本题本质上是一个受限的路径计数问题  
	* 出栈序列的合法性  
		* 对于一个给定的输入序列，并非所有的输出序列都是可能的。例如输入 1,2,3，绝对不可能输出 3,1,2（因为3出栈后，2在1上面，必须先出2）。
	    *   本题增加了难度，因为元素有重复（M和A多次出现），使得同一个输出字符可能对应输入中不同的位置，从而产生了多种合法的操作序列  



![[Pasted image 20251126150612.png]]
[[Pasted image 20251119074607.png]]

- 题目考察的是利用栈进行表达式求值的过程，特别是针对一种 #非法表达式 ，如何根据 #算符优先法 的逻辑来推导结果
1. 题目给出的表达式是 `(12)3+!4*+5`。我们需要维护两个栈：  [[算符优先法]]
	*   **操作数栈 (OPND)**：存放数字。
	*   **运算符栈 (OPTR)**：存放运算符
2. **核心规则：**
	*   遇到数字：直接入操作数栈。
	*   遇到运算符：与运算符栈栈顶元素比较优先级。
	    *   若当前运算符优先级 **高于** 栈顶，则入栈。
	    *   若当前运算符优先级 **低于或等于** 栈顶，则弹出栈顶运算符进行计算，将结果压入操作数栈，重复比较。
	*   **优先级顺序**（由高到低）：`!` (阶乘) > `*` (乘法) > `+` (加法)。`(` 和 `)` 用于改变优先级或界定范围。
3.  **处理 `(12)`**：
    *   `(` 入运算符栈。
    *   `12` 入操作数栈。
    *   `)` 出现，匹配并弹出运算符栈顶的 `(`。此时操作数栈中有 $[12]$。
    *   *注：这里 `(12)` 并没有触发运算，只是把 12 放进去了。*
4. **处理 `3`**：
    *   `3` 直接入操作数栈。此时操作数栈中有 $[12, 3]$。
5. **处理 `+`**：
    *   栈顶是空（或起始符），`+` 入运算符栈。此时运算符栈 $[+]$。
  6. **处理 `!`**：
    *   `!` 入运算符栈（假设它是单目运算符，或者等待后续操作数）。此时运算符栈 $[+, !]$。
7. **处理 `4`**：
    *   `4` 入操作数栈。此时操作数栈 $[12, 3, 4]$。
8.  **处理 `*`**：
    *   当前是 `*`，栈顶是 `!`。
    *   **比较优先级**：$! > *$。
    *   **执行 `!`**：弹出 `!`，取出操作数栈顶的 $4$。计算 $4! = 24$。将 $24$ 压入操作数栈。
    *   此时操作数栈：$[12, 3, 24]$。运算符栈：$[+]$。
    *   **再次比较**：当前 `*`，栈顶 `+`。$* > +$。
    *   `*` 入栈。此时运算符栈 $[+, *]$。
9.  **处理 `+` (第二个加号)**：
    *   当前是 `+`，栈顶是 `*`。
    *   **比较优先级**：$+ < *$。
    *   **执行 `*`**：弹出 `*`，取出操作数栈顶的两个数 $24$ 和 $3$。计算 $3 \times 24 = 72$。将 $72$ 压入操作数栈。
    *   此时操作数栈：$[12, 72]$。运算符栈：$[+]$。
    *   **再次比较**：当前 `+`，栈顶 `+`。优先级相同（通常左结合，视作栈顶高）。
    *   **执行 `+` (第一个加号)**：弹出栈顶 `+`，取出操作数栈顶的 $72$ 和 $12$。计算 $12 + 72 = 84$。将 $84$ 压入操作数栈。
    *   此时操作数栈：$[84]$。运算符栈为空。
    *   当前 `+` 入栈。此时运算符栈 $[+]$。
10.  **处理 `5`**：
    *   `5` 入操作数栈。此时操作数栈 $[84, 5]$。
11.  **结束求值**：
    *   表达式结束，弹出剩余运算符 `+`。
    *   计算 $84 + 5 = 89$。
    *   最终结果为 **89**。

- 衍生 
	- 后缀表达式求值  
		-  给出一个后缀表达式（如 `12 3 4 ! * + 5 +`），问计算结果。
	    *   **考点**：后缀求值只需要一个操作数栈，不需要运算符栈，遇到数字入栈，遇到符号就计算 
	* 栈的深度分析
		* 问在计算过程中，栈（操作数栈或运算符栈）达到的**最大深度**是多少。
	    *   例如本题中，操作数栈最多时有3个元素 $(12, 3, 4)$，最大深度为3 
	* 特殊运算符的处理  
		* 加入幂运算 $^$（通常是右结合的，即 $2^3^2 = 2^{(3^2)}$），或者取模 $\%$
**公式示例：**
如果考点涉及后缀表达式求值，对于序列 $A, B, +$，计算逻辑为：
$$Result = A + B$$
如果涉及阶乘，对于序列 $A, !$，计算逻辑为：
$$Result = A!$$


![[Pasted image 20251126150618.png]]
[[Pasted image 20251119074614.png]]

#双向链表 的首端和末端进行插入（push）和删除（pop）操作的时间复杂度 [[双向链表]] 


- **情况一：将链表头部（Head）作为栈顶**
    *   **Push（入栈）**：在头部插入一个节点。只需要修改新节点与原头节点的指针指向，不需要移动其他元素。操作次数是常数，时间复杂度为$O(1)$。
    *   **Pop（出栈）**：删除头节点。只需要将头指针指向下一个节点，并断开原头节点的连接。操作次数是常数，时间复杂度为$O(1)$。

*   **情况二：将链表尾部（Tail）作为栈顶**
    *   **Push（入栈）**：在尾部追加一个节点。因为有尾指针（Tail），可以直接访问末尾，修改指针即可。时间复杂度为$O(1)$。
    *   **Pop（出栈）**：删除尾节点。这是关键点。在**单向链表**中，删除尾节点需要$O(n)$的时间，因为需要遍历整个链表找到倒数第二个节点来更新尾指针。但在**双向链表**中，尾节点存有指向前驱节点（倒数第二个节点）的指针`prev`。因此，我们可以直接通过`Tail->prev`找到新的尾节点，并在常数时间内完成删除。时间复杂度为$O(1)$。

- **结论**：无论选择哪一端作为栈顶，基于双向链表实现的栈，其`push`和`pop`操作的时间复杂度均为$O(1)$。因此题目说法正确 

- 衍生 
	- 基于“动态数组”（Vector/ArrayList）实现栈   #动态数组实现栈  [[栈]]
		- 如果题目中的“列表”指的是Python中的`list`或C++中的`std::vector`（底层是连续内存的数组）：
			*   **将末端作为栈顶**：
			    *   `push`：通常是$O(1)$（均摊复杂度，Amortized Complexity）。
			    *   `pop`：$O(1)$。
			*   **将首端作为栈顶**：
			    *   `push`：需要将所有现有元素向后移动一位，时间复杂度为$O(n)$。
			    *   `pop`：需要将所有剩余元素向前移动一位，时间复杂度为$O(n)$。
			*   **结论**：基于数组实现栈，必须选择**末端**作为栈顶才能保证效率。
	- 基于“单向链表”（Singly Linked List）实现栈  #单向链表实现栈 
		如果底层结构是单链表（只有`next`指针，通常有`head`指针，可能有`tail`指针）：
		*   **将头部（Head）作为栈顶**：
		    *   `push`（头插法）：$O(1)$。
		    *   `pop`（头删法）：$O(1)$。
		    *   **适合实现栈。**
		*   **将尾部（Tail）作为栈顶**：
		    *   `push`：如果有`tail`指针，是$O(1)$；如果没有，是$O(n)$。
		    *   `pop`：即使有`tail`指针，也是$O(n)$。因为删除尾节点后，需要将`tail`指针更新为倒数第二个节点，而单链表无法直接访问前驱，必须从头遍历。
		    *   **不适合实现栈。**
	- 队列（Queue）的实现  #队列的实现  [[队列的实现]] 
		- **基于双向链表**：队首出队$O(1)$，队尾入队$O(1)$。非常适合。
		*   **基于数组**：如果在数组头部删除，通常是$O(n)$。为了实现$O(1)$，需要使用**循环数组（Circular Buffer）**技术，维护`front`和`rear`两个索引。 

![[Pasted image 20251126150625.png]]
[[Pasted image 20251119074621.png]]
函数调用栈 和 递归  #调用栈  #函数调用栈  
1.  **理解调用栈原理：** 程序在执行函数调用时，使用“栈”这种数据结构。当函数$f$被调用时，它的栈帧（包含局部变量、参数等）被压入栈顶；当函数返回时，栈帧被弹出。
2.  **寻找反例（间接递归）：** 我们需要找到一种情况，使得同一个函数在栈中出现多次，但中间夹杂了别的函数。
    *   假设有两个函数：函数$f$和函数$g$。
    *   **第一步：** 主程序调用$f(n)$。此时调用栈为：$[f(n)]$。
    *   **第二步：** 函数$f(n)$内部调用了$g(n)$。此时调用栈为：$[f(n), g(n)]$（栈顶是$g$）。
    *   **第三步：** 函数$g(n)$内部又调用了$f(n-1)$。此时调用栈为：$[f(n), g(n), f(n-1)]$。
3.  **结论：** 此时栈中同时存在两个$f$的栈帧（分别对应$f(n)$和$f(n-1)$），但它们中间隔着一个$g(n)$。因此，它们并不是“紧邻排列”的。

所以，题目的表述是错误的，答案为**False ($\times$)**。

- 衍生 
	- #栈溢出  
		- **考点：** 如果递归层数太深（例如死循环递归或递归基准条件$Base Case$写错），会导致栈帧不断压入，最终耗尽分配给栈的内存空间。
		*   **公式/概念：** 栈的深度通常与递归深度成正比。如果递归深度为$N$，空间复杂度通常为$O(N)$ 
	- 空间复杂度计算  #递归算法的复杂度分析    [[递归深度]]  
		- **考点：** 递归算法的空间复杂度主要取决于递归调用的最大深度（即栈的高度）。
		*   **例子：** 对于斐波那契数列的普通递归实现$Fib(n)=Fib(n-1)+Fib(n-2)$，虽然调用次数是指数级的，但最大栈深度是$O(n)$。
	* #尾递归优化  
		* **考点：** 如果一个函数的最后一步操作仅仅是调用自身（没有其他运算），编译器可以进行优化，复用当前的栈帧而不是创建新的栈帧。
		*   **意义：** 经过尾递归优化的递归函数，其空间复杂度可以从$O(n)$降低到$O(1)$，且不会发生栈溢出（但在某些语言如Python与Java中默认不支持此优化）。  
	* 栈帧的具体内容  
		*  **考点：** 可能会问你栈帧里具体存了什么？
		    *   **返回地址（Return Address）：** 函数执行完后该回到哪里继续执行。
		    *   **参数（Parameters）：** 传递给函数的变量。
		    *   **局部变量（Local Variables）：** 函数内部定义的变量。
	-  递归转非递归  
		-   **考点：** 任何递归程序都可以转化为非递归（迭代）程序。通常需要程序员手动维护一个**栈（Stack）**数据结构来模拟系统的调用栈行为。
- # 总结
- 这道题通过一个简单的判断，考察了你对**间接递归**存在的认知，以及对**调用栈**物理结构的理解。记住：**同名函数在栈中不一定相邻，中间可能隔着“第三者” 



![[Pasted image 20251119081354.png]]![[Pasted image 20251119081405.png]] 