![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=8&rect=23,578,578,808|826历年真题解析-数据结构篇（包括算法题）-12.15, p.8]]

![[Pasted image 20251126150418.png]]  
1. 根据组合数学原理，$n$个不同节点构成的二叉搜索树的种类数等于第$n$个 #卡特兰数 。卡特兰数的通项公式为：  [[卡特兰数常见的应用场景]] 
$$C_n=\frac{(2n)!}{n!(n+1)!}$$
	或者写作组合数形式： 
2. $n=5$，我们将数值代入公式计算：  
	1. $C_5=\frac{(2\times5)!}{5!(5+1)!}=\frac{10!}{5!6!}$  
3. 展开阶乘   
	1. $C_5=\frac{10\times9\times8\times7\times6\times5!}{5!\times(6\times5\times4\times3\times2\times1)}$
4. 最终计算  
	1. $C_5=3\times2\times7=42$  
- 衍生 
	- 进出栈序列（ #栈混洗 ）
		- **问题描述**：有$n$个元素依次入栈，求合法的出栈序列有多少种？
		*   **公式**：$C_n=\frac{1}{n+1}\binom{2n}{n}$
		*   **例子**：3个元素入栈，出栈序列有$C_3=5$种。这是最常见的变体。 
	* 括号匹配问题  
		*  **问题描述**：有$n$个左括号和$n$个右括号，这些括号能组成多少种合法的括号序列？（即任意前缀中左括号数量$\ge$右括号数量）。
		*   **公式**：$C_n$
		*   **例子**：$n=3$时，`((()))`, `()()()`, `(()())`, `(())()`, `()(())` 共5种。

![[Pasted image 20251126150431.png]]
[[Pasted image 20251119074051.png]]
1. 2019个叶节点的 #真二叉树 数目  
	1. 对于真二叉树（Full Binary Tree，又称 #严格二叉树 ，即每个节点要么是叶子，要么有两个子节点），如果叶子节点的数量为$n$，那么其构成的形态数目等于第$n-1$项卡特兰数，记为$C_{n-1}$。
	    在本题中，$n=2019$，所以真二叉树的数目为$C_{2019-1}=C_{2018}$  
2. 2018对括号组成的合法表达式数目  
	1. 这是卡特兰数最经典的定义之一。$n$对括号组成的合法匹配序列的数目等于第$n$项卡特兰数，记为$C_n$。
	    在本题中，$n=2018$，所以合法括号序列的数目为$C_{2018}$。  
3.  **结论**：
	左边的数目是$C_{2018}$，右边的数目也是$C_{2018}$。两者实际上是**相等**的。因此，题目中声称“数目少于”是错误的，答案为**错误($\times$)**。  
- 总结
	这道题考察的是考生是否知道**真二叉树的叶子数**与**卡特兰数**下标的对应关系（需减1），以及**括号匹配**与**卡特兰数**下标的对应关系（不减1）。记住$n$个节点的二叉树数量是$C_n$，而$n$个叶子的真二叉树数量是$C_{n-1}$，这是解题的关键陷阱。    

![[Pasted image 20251119074059.png]]
1.   **括号匹配问题**：
    $n$对括号组成的合法表达式数量，对应的是第$n$个卡特兰数，记为$C_n$。
    题目中给出了$2018$对括号，因此合法表达式的数量为$C_{2018}$。
2. #真二叉树 的计数问题 
	真二叉树（也称完满二叉树）是指所有节点的度要么为0（叶子节点），要么为2（内部节点）的二叉树。
    对于真二叉树，有一个重要的结论：**具有$k$个叶子节点的真二叉树的形态数量，等于第$k-1$个卡特兰数，即$C_{k-1}$。**
3. 题目要求真二叉树的数量等于$2018$对括号组成的合法表达式数量。
	即要求：
	$真二叉树数量 = 括号表达式数量$
	$C_{k-1} = C_{2018}$
4. 根据卡特兰数的一一对应关系，下标必须相等：
	$k - 1 = 2018$
	$k = 2019$
	因此，叶子节点的个数$k$为**2019**。答案选 **(B)**。  
![[Pasted image 20251119074105.png]]
- 这道题的核心在于建立“ #栈混洗”与“ #合法括号序列”之间的等价关系    
	- 分析右半部分（括号）
		- 2024 个括号意味着有$2024\div2=1012$对括号。
		    在组合数学中，由$n$对括号构成的合法表达式的数量，等于第$n$项卡特兰数，记为$C_n$。
		    这里$n=1012$，所以合法表达式的数量为$C_{1012}$。
	- 分析左半部分（栈混洗） 
		- 题目问由多少个元素构成的栈混洗序列数量与上述相等。
	    设元素的个数为$x$。
	    对于$x$个不同元素进栈，其合法的出栈序列（栈混洗）的总数，也恰好等于第$x$项卡特兰数$C_x$。
- **建立等式：**
    题目要求两者数量“一样多”，即要求：
    $C_x=C_{1012}$
    显然，这意味着$x=1012$。
**结论：** 需要$1012$个元素构成的栈混洗序列。  

- 为什么栈混洗和括号匹配是等价的？  
	- 我们可以建立一个一一映射（Bijection）：
		*   **栈混洗：** 有$n$个元素。我们将“入栈”操作看作是一个左括号$($，“出栈”操作看作是一个右括号$)$。
		*   **限制条件：** 在任何时刻，出栈的次数不能超过入栈的次数（因为空栈不能弹出元素），且最终入栈次数等于出栈次数。
		*   这完全等价于：在括号序列中，从左往右数，右括号的数量在任何位置都不能超过左括号的数量，且左右括号总数相等。
		
		因此，$n$个元素的栈混洗方案数 $=$ $n$对括号的合法排列数 $=$ $C_n$。


![[Pasted image 20251119074120.png]]
这是一道关于 #逆波兰表达式 也称为**后缀表达式**的题目。  
1. #逆波兰表达式的计算规则  
	1. 我们需要使用一个**栈（Stack）**数据结构。
		1.  从左到右扫描表达式。
		2.  遇到**数字**：压入栈中。
		3.  遇到**运算符**：从栈中弹出所需数量的操作数（通常是2个），进行运算，将结果压回栈中。
    



![[Pasted image 20251126150506.png]]
[[Pasted image 20251119074419.png]]
[[Pasted image 20251119074507.png]]

![[Pasted image 20251126150502.png]]

[[Pasted image 20251119074513.png]]



![[Pasted image 20251126150535.png]][[Pasted image 20251119074518.png]]

[[c++运算符优先级]]   
![[Pasted image 20251126150542.png]]
[[Pasted image 20251119074534.png]]


![[Pasted image 20251126150551.png]]
[[Pasted image 20251119074542.png]]
[[Pasted image 20251119074546.png]]


![[Pasted image 20251126150601.png]]
[[Pasted image 20251119074554.png]]


![[Pasted image 20251126150606.png]]
[[Pasted image 20251119074601.png]]

 像Z
![[Pasted image 20251126150612.png]]
[[Pasted image 20251119074607.png]]


![[Pasted image 20251126150618.png]]
[[Pasted image 20251119074614.png]]


![[Pasted image 20251126150625.png]]
[[Pasted image 20251119074621.png]]



![[Pasted image 20251119081354.png]]![[Pasted image 20251119081405.png]] 