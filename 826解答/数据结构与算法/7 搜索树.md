![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=23&rect=19,675,571,809|826历年真题解析-数据结构篇（包括算法题）-12.15, p.23]]

![[Pasted image 20251214145830.png]]
- 二叉搜索树（Binary Search Tree, BST）的定义决定了节点的大小关系：
	对于树中的任意节点$N$，其左子树中所有节点的值都**小于**$N$的值，其右子树中所有节点的值都**大于**$N$的值    
- 推导步骤  
	1.  假设我们正在寻找BST中**最大**的节点。
	2.  如果一个节点有右孩子，根据BST的性质，右孩子的值一定大于该节点的值。因此，只要存在右孩子，当前节点就绝对不是最大的。
	3.  为了找到最大值，我们需要一直沿着右指针（Right Pointer）向下遍历。
	4.  遍历终止的条件是：当前节点没有右孩子（即`current->right == NULL`）。此时，没有比当前节点更大的值了。

- **唯一确定的结论是：二叉搜索树中最大的节点一定没有右孩子。** 如果必须在考试中选一个（通常这类题目会有上下文或隐含假设树不为空且非单节点），(A) 和 (D) 描述的场景都满足“最大”的条件，但从集合包含关系来看，只需满足$right=NULL$即可 


- 衍生
	- 最小节点的位置 
		- 与最大节点对称，**二叉搜索树中最小的节点一定没有左孩子**。它可能有右孩子，也可能没有，但绝对没有左孩子 
	- 查找、插入、删除的时间复杂度
		BST的操作效率取决于树的高度$h$。
		*   **最好/平均情况：** 树比较平衡，高度$h \approx \log_2 n$。时间复杂度为$O(\log n)$。
		*   **最坏情况：** 树退化成链表（例如插入序列本身就是有序的 1, 2, 3, 4, 5）。此时树的高度$h=n$。时间复杂度退化为$O(n)$
	- #节点的删除（难点）   #节点删除操作 
		- 如果删除题目中提到的“最大节点”，情况比较简单，因为它最多只有一个左孩子，直接用左孩子顶替它的位置即可。
			但在一般情况下，删除一个节点$N$有三种情况：
			1.  **叶子节点：** 直接删除。
			2.  **仅有一个孩子：** 该孩子直接替代节点$N$。
			3.  **既有左孩子又有右孩子：** 
			    *   通常用$N$的**直接前驱**（左子树中的最大值）或**直接后继**（右子树中的最小值）来替代$N$，然后删除那个前驱或后继节点。
			    *   *注：结合本题，左子树的最大值一定没有右孩子；右子树的最小值一定没有左孩子。这保证了递归删除的简化。*
	- BST 的判定与构建  
		-  **判定：** 给定一个二叉树，判定它是否为BST。
		    *   *方法：* 进行中序遍历，检查结果是否严格单调递增。
		*   **构建：** 给定一个序列，不同的插入顺序可能生成不同的BST形态，但如果给定的是中序遍历序列，无法唯一确定一棵BST（需要结合先序或后序）。
			


![[Pasted image 20251214145841.png]]
[[Pasted image 20251119105518.png]]
1. 第一步：理解题目约束   
	1. 题目要求构建一棵二叉搜索树， #关键码 为$\{0, 1, \dots, 10\}$，共$n=11$个节点。  [[关键码]] 
		约束条件是：**所有节点的度都是偶数**。
		在二叉树中，节点的度只能是0、1或2。既然必须是偶数，说明节点的度只能是**0**（叶子节点）或**2**（内部节点）。这种树被称为**满二叉树**（Full Binary Tree）或**严格二叉树**
2. 第二步：分析节点数量特征
	在满二叉树中，如果节点总数为$n$，那么$n$必然是一个奇数。
	本题中$n=11$，符合奇数条件。
	根节点的度必须为2（除非$n=1$），这意味着根节点一定同时拥有左子树和右子树。
	假设左子树有$i$个节点，右子树有$j$个节点，那么满足：
	$i + j = n - 1$（因为根节点占用1个）。
	由于左子树和右子树本身也必须满足“所有节点度为偶数”，所以$i$和$j$也必须是奇数。
	
3. **第三步：建立递推公式**
	设$T(n)$为$n$个节点满足条件的树的数量。
	根据BST的性质，根节点选定后，左右子树的节点数也就确定了。我们可以枚举左子树的节点数量$i$（$i$必须为奇数），则右子树节点数量为$n-1-i$。
	公式为：
	$T(n) = \sum_{i \in \{1, 3, \dots, n-2\}} T(i) \times T(n-1-i)$

4. 第四步：具体计算（ #动态规划   /自底向上）
	我们需要计算$T(11)$。根据上图的解法，我们要从$T(1)$开始推导：
	
	1.  **$T(1)=1$**：只有1个根节点，度为0，符合条件。
	2.  **$T(3)$**：$1+1+1=3$，根节点占1个，左右各分1个。
	    $T(3) = T(1) \times T(1) = 1 \times 1 = 1$
	3.  **$T(5)$**：$5-1=4$个节点分给左右。组合有$(1,3)$和$(3,1)$。
	    $T(5) = T(1)T(3) + T(3)T(1) = 1\times1 + 1\times1 = 2$
	4.  **$T(7)$**：$7-1=6$个节点分给左右。组合有$(1,5), (3,3), (5,1)$。
	    $T(7) = T(1)T(5) + T(3)T(3) + T(5)T(1) = 1\times2 + 1\times1 + 2\times1 = 5$
	5.  **$T(9)$**：$9-1=8$个节点分给左右。组合有$(1,7), (3,5), (5,3), (7,1)$。
	    $T(9) = T(1)T(7) + T(3)T(5) + T(5)T(3) + T(7)T(1)$
	    $= 1\times5 + 1\times2 + 2\times1 + 5\times1 = 14$
	6.  **$T(11)$**：$11-1=10$个节点分给左右。组合有$(1,9), (3,7), (5,5), (7,3), (9,1)$。
	    $T(11) = T(1)T(9) + T(3)T(7) + T(5)T(5) + T(7)T(3) + T(9)T(1)$
	    $= 1\times14 + 1\times5 + 2\times2 + 5\times1 + 14\times1$
	    $= 14 + 5 + 4 + 5 + 14 = 42$

4. [[卡特兰数常见的应用场景]]    
	1. 卡特兰数是组合数学中一个常出现在各种计数问题中的数列。
		*   **通项公式**：第$k$个卡特兰数$C_k = \frac{1}{k+1}\binom{2k}{k}$。
		*   **数列前几项**：1, 1, 2, 5, 14, 42, 132...
		*   **本题映射**：
		    本题中$n$个节点的满二叉树的数量，实际上对应于第$k$个卡特兰数，其中$n = 2k + 1$。
		    对于$n=11$，我们有$11 = 2k + 1 \Rightarrow 2k=10 \Rightarrow k=5$。
		    计算$C_5$：
		    $C_5 = \frac{1}{5+1}\binom{10}{5} = \frac{1}{6} \times \frac{10 \times 9 \times 8 \times 7 \times 6}{5 \times 4 \times 3 \times 2 \times 1} = \frac{1}{6} \times 252 = 42$
- 衍生
	- 出栈序列问题   
		*   有$k$个元素依次进栈，求所有可能的合法出栈序列的个数。
	    *   对应公式：$C_k$。若本题问5个元素进栈的出栈序列数，答案也是42。
	- 普通二叉树形态计数  
		- 给定$k$个节点，能构成多少种不同形态的二叉树？
	    *   对应公式：$C_k$。
	    *   *注意区别*：本题是“11个节点的满二叉树”，等价于“5个内部节点（度为2）的二叉树”，也就是等价于“5个节点的普通二叉树”的形态数
	- 括号匹配问题  
		- 有$k$对括号，求有多少种合法的括号匹配序列（如`((()))`合法，`())`不合法）。
	    *   对应公式：$C_k$。
- **总结建议：**
	如果考试中遇到这种“递归拆分”或者“左右匹配”的计数问题，且前几项结果是1, 2, 5, 14...，可以直接联想**卡特兰数**。对于本题，记住$n$个节点的满二叉树对应的卡特兰数下标是$k=(n-1)/2$。  

![[Pasted image 20251214183439.png]]
[[Pasted image 20251119105527.png]]

AVL 树是一种自平衡二叉搜索树，它通过旋转操作来维持平衡（任意节点的左右子树高度差绝对值不超过 1）。当树失去平衡时，根据失衡节点与插入/删除位置的关系，分为四种情况：
[[平衡二叉树的旋转]] 
1.  **LL 型（单旋）：** 在左子树的左侧插入。只需一次 **右旋**。
2.  **RR 型（单旋）：** 在右子树的右侧插入。只需一次 **左旋**。
3.  **LR 型（双旋）：** 在左子树的右侧插入。需要 **先左旋，后右旋**。
4.  **RL 型（双旋）：** 在右子树的左侧插入。需要 **先右旋，后左旋**。
- 题目中的“两次旋转调整”正是指上述的 **LR 型** 或 **RL 型**，因为这两种情况在逻辑上和实现上都需要进行两次基础的旋转操作才能恢复平衡。  
1. 需要分析“添加”和“删除”操作是否都可能触发双旋。

	*   **关于添加节点（Insertion）：**
	    当我们将新节点插入到由“左孩子的右子树”导致失衡（LR情况）或“右孩子的左子树”导致失衡（RL情况）时，必须执行双旋。
	    *   **结论：** 添加节点 **可能** 发生两次旋转（双旋）。
	
	*   **关于删除节点（Deletion）：**
	    删除节点后，树的某一边高度降低，导致另一边过高。如果较高的那一边子树呈现“内侧重”（例如：作为左子树时，其右孩子比左孩子高），恢复平衡时同样需要进行双旋（LR 或 RL）。
	    *   **结论：** 删除节点也 **可能** 发生两次旋转（双旋）。

	**综上所述，添加和删除操作都有可能触发双旋，因此答案是 (A)。**

- 衍生 
	- #旋转次数的上限   
		- 这是 #AVL树与红黑树 对比时的核心考点。
			*   **插入操作（Insert）：**
			    一旦发现失衡，只需要进行一次调整（单旋或双旋）即可使整棵树恢复平衡。
			    *   旋转次数：常数级，最多 **2** 次（即一次双旋）。
			    *   时间复杂度：$O(\log n)$。
			*   **删除操作（Delete）：**
			    删除节点导致失衡，进行旋转调整后，可能会导致父节点所在子树的高度变矮，从而引起更高层祖先节点的失衡。这种失衡可能一直向上传播到根节点。
			    *   旋转次数：**可能需要多次调整**，最坏情况下需要 $O(\log n)$ 次旋转。
			    *   **注意：** 如果题目问的是“哪种操作可能导致全树进行多次（指不同层级）的再平衡”，答案是 **仅删除**。但本题问的是“两次旋转”，且答案包含插入，因此特指“双旋”这个动作。
		- [[AVL树vs红黑树]]  
		- 平衡因子的计算
			AVL 树的平衡因子 $BF$ 定义为左子树高度减去右子树高度（或反之）。
			公式：$BF=H_{left}-H_{right}$，且 $|BF|\le 1$。
		- 若考题变为“哪个操作可能导致 #级联旋转 （即调整完当前节点，父节点又失衡）”，则答案应选 **(B) 仅删除**。 




![[Pasted image 20251214221211.png]]
[[Pasted image 20251119105636.png]]

- 考查的是 **平衡二叉树（AVL树）** 在特定插入顺序（顺序插入）下的性质  
1. **核心结论：**
	向初始为空的AVL树中按递增顺序插入节点时，AVL树会始终保持“最紧凑”的状态（即尽可能接近满二叉树或完全二叉树的状态）。  
- 计算步骤 
1.  **明确高度定义：** 题目规定“只有一个根节点的二叉树高度为0”。这意味着高度是基于“边”的计数，或者说是层数减1。
    *   第1层（根）：高度 $0$
    *   第2层：高度 $1$
    *   ...
    *   高度为 $h$ 的满二叉树，其节点总数公式为 $N=2^{h+1}-1$。
2. **寻找数值区间：** 我们需要插入的节点总数是 $N=2016$。我们来计算满二叉树的节点数阈值：
    *   当高度 $h=9$ 时，满二叉树节点数为 $2^{9+1}-1=1023$。
    *   当高度 $h=10$ 时，满二叉树节点数为 $2^{10+1}-1=2047$。
3. **判定高度：**
    *   当插入第 $1$ 到第 $1023$ 个节点时，树填满了高度为 $0$ 到 $9$ 的所有位置。此时树的高度是 $9$。
    *   当插入第 $1024$ 个节点时，原有的高度为 $9$ 的满二叉树无法容纳，必须开启新的一层，树的高度瞬间变为 $10$。
    *   随后的节点（直到第 $2047$ 个）都会填在第 $10$ 层（高度为10）。
    *   因为 $1023<2016\le2047$，所以包含 $2016$ 个节点的AVL树，其高度必定为 **10**。

- **结论：** 答案选择 **(C)**。 

- 衍生 
	- (1) 平衡二叉树（AVL树）的定义  
		- AVL树是一种自平衡的二叉搜索树。它的特点是：对于树中的任意一个节点，其左子树和右子树的高度差（平衡因子）的绝对值不超过1。
			*   为了维持这个性质，每当插入新节点破坏平衡时，树会通过 **旋转（Rotation）** 操作（如左旋、右旋）来重新平衡。 
	*  (2) 顺序插入与“满二叉树”定理 
		* 我们讨论AVL树时，常考查其“最坏情况”（即节点最少、高度最高的情况，类似斐波那契数列）。但这道题考查的是“最好情况” 
			* **通俗理解：**
				虽然普通的二叉搜索树（BST）在顺序插入时会退化成一条链表（高度为 $N-1$），但AVL树会自动旋转。在顺序插入的情况下，AVL树的填充效率极高，它会一层一层地填满。因此，顺序插入AVL树得到的树高度为 $\lfloor\log_2N\rfloor$
	- AVL树的高度最少与其对应的节点数  
		- **问题：** 给定节点数 $n$，求AVL树的最小高度（或给定高度求最大节点数）。
			**分析：** 也就是本题考查的情况。当AVL树接近完全二叉树/满二叉树时，高度最小。
			**公式：**
			若根节点高度为0，高度为 $h$ 的AVL树最多拥有的节点数（即满二叉树）：
			$N_{max}=2^{h+1}-1$
			反之，若有 $n$ 个节点，其最小高度为：
			$h_{min}=\lfloor\log_2n\rfloor$
	- AVL树的高度最大与其对应的节点数（高频考点）   [[AVL树的高度与结点数关系]]
		- **问题：** 构造一棵高度为 $h$ 的AVL树，至少需要多少个节点？
			**分析：** 这是为了让树尽可能“稀疏”，每一层都刚好满足平衡因子的临界条件。这构成了 **斐波那契（Fibonacci）** 类型的递归关系。
			**公式：**
			设 $N_h$ 为高度为 $h$ 的AVL树的最少节点数：
			*   $N_0=1$ （只有根）
			*   $N_1=2$ （根 + 一个子节点）
			*   $N_h=N_{h-1}+N_{h-2}+1$
			这个公式非常重要，常用于反推：给定节点数，求AVL树的最大可能高度
	- 旋转操作的类型
		**问题：** 在顺序插入 $1,2,3,4,5$ 的过程中，发生了几次旋转？是什么类型的旋转？
		**分析：**
		*   插入1, 2: 不旋转。
		*   插入3: 此时结构为 $1-2-3$（右偏），需要进行 **RR旋转（左单旋）**，变为以2为根，1、3为左右孩子的满树。
		*   对于顺序插入，主要涉及的是调整右子树高度的旋转。
	- 完全二叉树的判定  
		- **问题：** 顺序插入AVL树生成的树是否一定是完全二叉树？
			**分析：** 题目图片中的结论是：当节点数为 $2^{h+1}-1$ 时，是 **满二叉树**。但在中间过程中（比如本题2016个节点），它虽然高度是最小的，但其叶子节点的分布并不一定严格符合“完全二叉树”定义（即最后一层叶子不一定全部靠左排列，可能会有空隙，这取决于具体的旋转时机），但其高度一定被压缩在 $\lfloor\log_2n\rfloor$。不过在考研选择题语境下，通常将其视为完全二叉树的性质来估算高度。
	- #旋转操作的类型  
		**问题：** 在顺序插入 $1,2,3,4,5$ 的过程中，发生了几次旋转？是什么类型的旋转？
		**分析：**
		*   插入1, 2: 不旋转。
		*   插入3: 此时结构为 $1-2-3$（右偏），需要进行 **RR旋转（左单旋）**，变为以2为根，1、3为左右孩子的满树。
		*   对于顺序插入，主要涉及的是调整右子树高度的旋转。 
	* 完全二叉树的判定  
		* **问题：** 顺序插入AVL树生成的树是否一定是完全二叉树？
			**分析：** 题目图片中的结论是：当节点数为 $2^{h+1}-1$ 时，是 **满二叉树**。但在中间过程中（比如本题2016个节点），它虽然高度是最小的，但其叶子节点的分布并不一定严格符合“完全二叉树”定义（即最后一层叶子不一定全部靠左排列，可能会有空隙，这取决于具体的旋转时机），但其高度一定被压缩在 $\lfloor\log_2n\rfloor$。不过在考研选择题语境下，通常将其视为完全二叉树的性质来估算高度

![[Pasted image 20251214221218.png]]
[[Pasted image 20251119110342.png]]


- 考察的是 **AVL 树（平衡二叉搜索树）的构造过程** 以及  #满二叉树    
1.  核心机制：  [[镜像对称]] 
	1.  **递增序列插入（如 1, 2, 3...）：** 每次新节点都插入在最右侧。树会不断向右生长，导致右重左轻，频繁触发 **左旋（Left Rotation）** 操作。
	*   **递减序列插入（如 n, n-1, n-2...）：** 每次新节点都插入在最左侧。树会不断向左生长，导致左重右轻，频繁触发 **右旋（Right Rotation）** 操作。
2. 充分性证明 ($n=2^k-1 \Rightarrow$ 两棵树相同)  
	1. 当节点数量 $n$ 满足 $n=2^k-1$ 时，这就对应一棵 #满二叉树    
		1. 对于确定的 $n$ 个节点，能够构成的“高度平衡”且“填满每一层”的二叉搜索树的**形态是唯一的**。
			*   无论你是按递增顺序插入并通过左旋调整，还是按递减顺序插入并通过右旋调整，最终为了保持 AVL 的平衡性质（任意节点左右子树高度差不超过1），且节点数恰好填满所有层，最终一定会收敛到那个唯一的满二叉树形态。
			*   因为形态唯一且键值集合固定，根据二叉搜索树的性质，这棵树是唯一的。
			*   **结论：** 充分性成立。
3. 必要性证明 (两棵树相同 $\Rightarrow n=2^k-1$)  
	1. 假设 $n \neq 2^k-1$，说明这棵树的最后一层没有填满  
		1. **递增插入**时，由于数据从小到大进入，树倾向于把较小的数据留在左侧/底层，较大的数据刚插入时在右侧，调整后重心可能会略微偏左或偏右（取决于具体的旋转算法实现），但关键是**空缺的节点位置**和**递减插入**时往往不同。
		*   举个反例：$n=2$ (即 $2^2-1$ 不成立)。
		    *   递增插入 (1, 2)：1是根，2是右孩子（或者旋转后2是根，1是左孩子，取决于实现细节，但在标准AVL中，插入1, 2不会旋转，根是1）。
		    *   递减插入 (2, 1)：2是根，1是左孩子。
		    *   结果：根节点不同，树不相同。
		*   再举例 $n=4$：
		    *   递增 (1, 2, 3, 4)：AVL 树倾向于填满左侧，根节点通常是 3 (左子树 1,2; 右子树 4) 或者 2 (左 1; 右 3,4)。
		    *   递减 (4, 3, 2, 1)：结构会与递增的情况呈镜像。如果 $n$ 不是满二叉树的节点数，这种镜像会导致树的结构（哪边多一个节点）相反，或者根节点的值不同。
		*   只有当树是**满二叉树**时，结构才具备完全的对称性，且没有“最后一层空缺位置”的问题，从而使得正向和反向构造的结果一致。
		*   **结论：** 必要性成立。

- 衍生 
	- AVL 树的最少节点数  
		- **问题：** 构造一棵高度为 $h$ 的 AVL 树，至少需要多少个节点？
		*   **公式：** 递推公式 $N(h) = N(h-1) + N(h-2) + 1$，其中 $N(0)=0, N(1)=1$。
		*   **关联：** 这类似于斐波那契数列。考研常考计算具体高度（如 $h=5$）时的最少节点数
	- 完全二叉树 vs 满二叉树  
		- **问题：** 区分 $n$ 个节点的完全二叉树（Complete Binary Tree）和满二叉树。
		*   **点拨：** 本题中 $n=2^k-1$ 特指满二叉树。如果题目换成“完全二叉树”，上述结论不一定成立 
	* 插入序列与树的形态  
		*  **问题：** 给定一个序列，判断构造成的 BST 或 AVL 树的根节点是谁？
		*   **例子：** 序列 (1, 2, 3, 4, 5) 构造 AVL 树。
	    *   过程：1-2-3 (RR不平衡，左旋，2为根) -> 插入4 -> 插入5 (RR不平衡，以4为轴左旋) ...
		    *   这类题目要求考生能手画旋转过程。
	 - #有序元素依次插入AVL树的时间复杂度  
		 - **问题：** 将 $n$ 个有序元素依次插入 AVL 树的时间复杂度是多少？
		*   **答案：** 虽然每次插入是 $O(\log n)$，总时间是 $O(n \log n)$。但如果是普通 BST 插入有序序列，会退化成链表，时间是 $O(n^2)$。这也是为什么要用 AVL 树的原因。
	* BST 的唯一性 
		* **问题：** 什么样的 #二叉排序树BST 是唯一的？
		*   **答案：** 给定具体的结构（如本题中的满二叉树形态）和具体的键值集合，二叉排序树是唯一的。如果只给定键值集合（如前序遍历、后序遍历），树不唯一




![[Pasted image 20251214221227.png]]
[[Pasted image 20251119110351.png]]

- **推导核心逻辑：**
	在AVL树中插入一个节点，虽然查找插入位置和回溯更新高度的路径长度是$O(\log n)$，但是**实际触发旋转（Rebalancing/局部重构）的操作次数至多只有1次（即$O(1)$）**    
1. 左侧代码
	1. 请看图片左侧 `AVL<T>::insert` 的代码片段。
    *   在 `for` 循环中，代码从插入位置 `_hot` 向上回溯查找失衡节点 `g`。
    *   一旦发现失衡 (`if ( ! AvlBalanced( *g ) )`)，会执行旋转操作 `rotateAt(...)`。
    *   **关键点：** 旋转操作后紧接着有一个 **`break;`** 语句。
    *   **原理解析：** 代码注释中写道：“//g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整结束”。这意味着，插入导致的失衡一旦在最低的失衡节点被修复，修复后的子树高度会变回插入前的高度。因此，更高的祖先节点不会察觉到高度变化，也就不会继续失衡。所以，插入操作的重构次数是常数级$O(1)$。

*   **右侧代码 (Remove) - 作为对比:** 请看图片右侧 `AVL<T>::remove` 的代码片段。
    *   在删除操作的循环中，执行完 `rotateAt(...)` 后，**没有** `break` 语句。
    *   注释写道：“//可能需做过$\Omega(\log n)$次调整”。
    *   **原理解析：** 删除节点导致失衡，旋转修复后，该子树的高度可能会降低。这种高度的降低可能会导致其父节点（祖先）出现新的失衡。这种“失衡传播”可能会一直向上延伸到根节点。因此，删除操作可能需要进行$O(\log n)$次重构。

**结论：**
插入操作引发的结构调整（旋转）是$O(1)$的，而不是$O(\lg n)$。题目混淆了“插入”和“删除”的最坏情况，或者是混淆了“总时间复杂度$O(\log n)$”与“重构次数$O(1)$”的区别。

- 衍生  
	- #AVL树vs红黑树  [[AVL树vs红黑树]]
		-   **插入操作：**
		    *   AVL树：旋转$O(1)$次。
		    *   红黑树：旋转$O(1)$次（但可能伴随$O(\log n)$次颜色调整）。
		*   **删除操作：**
		    *   AVL树：旋转$O(\log n)$次。
		    *   红黑树：旋转$O(1)$次（至多3次旋转，但需$O(\log n)$次颜色调整）。
		*   **平衡性与性能：**
		    *   AVL树更“严格”平衡（高度差不超过1），查找效率略高于红黑树，适合**查找多、插入删除少**的场景。
		    *   红黑树平衡条件较弱，插入删除时的恢复开销略低（尤其是删除时的旋转次数少），适合**插入删除频繁**的场景（如C++ STL中的`std::map`和`std::set`）。
	- [[AVL树的高度与结点数关系]]
		- 考察AVL树的最少节点数。
		*   高度为$h$的AVL树，包含的最少节点数$N_h$满足递推公式：
		    $N_h=N_{h-1}+N_{h-2}+1$
		*   这与斐波那契数列密切相关（$N_h\approx Fib(h+2)-1$）。由此可推导出AVL树的高度$h$被限制在$O(\log n)$以内，约为$1.44\log_2 n$。


![[Pasted image 20251214221236.png]]
![[Pasted image 20251214221248.png]]
![[Pasted image 20251215013355.png]]
[[Pasted image 20251119110356.png]]
[[Pasted image 20251119110548.png]]
[[Pasted image 20251119110556.png]]

- 主要考察的是 **AVL树（平衡二叉搜索树）** 在删除节点后的恢复平衡操作，以及一种被称为“3+4重构”（统一旋转）的代码实现逻辑   #很复杂  
1. 第一问：如何确定 $g, p, v$？  
	1. AVL树删除节点后，可能会导致树的高度失衡。我们需要找到“最先失衡”的祖先节点，并对其进行旋转调整  
	2. 推导逻辑  
		1. 寻找 $g$   
		    *   删除操作发生在某个位置，我们将该位置的父节点记为 `_hot`。
		    *   **向上回溯**：从 `_hot` 开始，沿着 `parent` 指针向上遍历祖先节点。
		    *   **检查失衡**：每向上一步，计算当前节点的平衡因子（左子树高度 - 右子树高度）。只要发现某节点的平衡因子绝对值 $|BF| > 1$，该节点就是我们要找的 $g(x)$（最低失衡节点）。在算法中，这通常通过 $O(\log n)$ 的时间复杂度内完成。
		2. 寻找 $p$  
			*   $g$ 失衡是因为某一边太矮（因为删除了节点），或者说另一边**太高**。
		    *   为了恢复平衡，我们需要操作“太高”的那一边。
		    *   因此，$p$ 必然是 $g$ 的**高度更高**的那个孩子（即：若删除发生在 $g$ 的左侧子树，$p$ 必为 $g$ 的右孩子，反之亦然）。
		3. 寻找 $v$   
			*   $v$ 是 $p$ 的孩子。我们需要在 $p$ 的两个孩子中选择一个来辅助旋转。
		    *   **原则**：选择高度更高的那个孩子。
		    *   **特殊情况（Tie-breaking）**：如果 $p$ 的两个孩子**高度相等**，为了使后续操作更简单（优先使用单旋转而不是双旋转），我们选择与 $p$ “同向”的孩子。
		        *   如果 $p$ 是 $g$ 的左孩子，且 $p$ 的两孩子等高，则 $v$ 选 $p$ 的左孩子（构成 Zig-Zig）。
		        *   如果 $p$ 是 $g$ 的右孩子，且 $p$ 的两孩子等高，则 $v$ 选 $p$ 的右孩子（构成 Zag-Zag）。
2. 第二问与第三问：“3+4”重构（统一旋转）  
	2. [[平衡二叉树的旋转]]分为四种（LL, RR, LR, RL 或称 Zig-Zig, Zag-Zag, Zig-Zag, Zag-Zig）。为了简化代码，引入了 `connect34` 统一重构方法    
3. **核心原理**：
	无论哪种旋转情况，涉及的三个核心节点（$g, p, v$）和四棵子树（$T_0, T_1, T_2, T_3$）在**旋转后**的中序遍历顺序（从左到右）是固定的。
	*   **3个节点排序**：设这三个节点按键值大小排序后为 $a < b < c$。
	*   **4棵子树排序**：按中序遍历顺序为 $T_0, T_1, T_2, T_3$。
	*   **最终形态**：$b$ 成为新的子树根节点，$a$ 是 $b$ 的左孩子，$c$ 是 $b$ 的右孩子；$T_0, T_1$ 分别是 $a$ 的左右子树，$T_2, T_3$ 分别是 $c$ 的左右子树。
4. 表格推导（以第三问表格为例）  
	1. 我们需要根据 $g, p, v$ 的相对位置，确定谁是最小的 $a$，谁是中间的 $b$，谁是最大的 $c$，以及子树的归属。 
	2. **情况 #1: Zig-Zig (同为左孩子)**
    *   结构：$g$ 在顶，$p$ 是 $g$ 的左孩子，$v$ 是 $p$ 的左孩子。
    *   大小关系：$v < p < g$。
    *   **映射**：$a=v, b=p, c=g$。
    *   **子树**：
        *   $v$ 的左子树是 $T_0$ ($v \to lc$)
        *   $v$ 的右子树是 $T_1$ ($v \to rc$)
        *   $p$ 的右子树是 $T_2$ ($p \to rc$)
        *   $g$ 的右子树是 $T_3$ ($g \to rc$)
    *   *对照表格 #1 行，完全一致。*

	*   **情况 #2: Zig-Zag (p是左，v是右)**
	    *   结构：$g$ 在顶，$p$ 是 $g$ 的左孩子，$v$ 是 $p$ 的右孩子。
	    *   大小关系：$p < v < g$。
	    *   **映射**：$a=p, b=v, c=g$。
	    *   **子树**：
	        *   $p$ 的左子树是 $T_0$ ($p \to lc$)
	        *   $v$ 的左子树是 $T_1$ ($v \to lc$)
	        *   $v$ 的右子树是 $T_2$ ($v \to rc$)
	        *   $g$ 的右子树是 $T_3$ ($g \to rc$)
	    *   *对照表格 #2 行，完全一致。*

	*   **情况 #3: Zag-Zig (p是右，v是左)**
	    *   结构：$g$ 在顶，$p$ 是 $g$ 的右孩子，$v$ 是 $p$ 的左孩子。
	    *   大小关系：$g < v < p$。
	    *   **映射**：$a=g, b=v, c=p$。
	    *   **子树**：
	        *   $g$ 的左子树是 $T_0$ ($g \to lc$)
	        *   $v$ 的左子树是 $T_1$ ($p \to lc$ 这里原图可能是笔误或者是特定代码实现的指代，逻辑上应为 $v \to lc$ 是 $T_1$, $v \to rc$ 是 $T_2$，但在 Zag-Zig 中，$T_1$ 来自 $v$ 左，$T_2$ 来自 $v$ 右。看代码截图最后一行：参数依次为 $g, v, p, g \to lc, v \to lc, v \to rc, p \to rc$。对照表格，$T_1$ 对应 $p \to lc$ 这一项在表格里似乎写错了，或者是有特定的语境。**根据标准逻辑：** $T_1$ 应来源于 $v$ 的左子树。但在 Zag-Zig 中，中序遍历是 $g, T_0, g, T_1, v, T_2, p, T_3$。不，正确的中序是 $T_0, g, T_1, v, T_2, p, T_3$。
	        *   让我们看代码截图最下面的 `else` (zag-zig) 块：`return connect34(g, v, p, g->lc, v->lc, v->rc, p->rc)`。
	        *   这意味着 $a=g, b=v, c=p$。$T_0=g \to lc, T_1=v \to lc, T_2=v \to rc, T_3=p \to rc$。
	        *   **表格 #3**：$a=g, b=p, c=v$。**注意！** 表格第三行写的是 `g, p, v`，这对应的是 Zag-Zag 情况（$p$ 是 $g$ 右，$v$ 是 $p$ 右，即 $g < p < v$）。
	        *   **修正对照**：表格 #3 对应代码中的 Zag-Zag (对应代码第 3 个块 `zag * / if (IsRChild(*v))` )。
	            *   代码：`connect34(g, p, v, g->lc, p->lc, v->lc, v->rc)`。
	            *   表格 #3: $a=g, b=p, c=v, T_0=g \to lc, T_1=p \to lc, T_2=v \to lc, T_3=v \to rc$。完全匹配。

	*   **情况 #4: Zag-Zag 还是 Zag-Zig?**
	    *   表格 #4：$a=g, b=v, c=p$。这对应 **Zag-Zig**（$g < v < p$）。
	    *   对应代码最后一个 `else` 块。
	    *   参数：$T_0=g \to lc, T_1=v \to lc, T_2=v \to rc, T_3=p \to rc$。
	    *   表格 #4: $T_0=g \to lc, T_1=v \to lc, T_2=v \to rc, T_3=p \to rc$。完全匹配。

**总结**：表格就是把四种几何形状下的 $g, p, v$ 重新分配给 $a, b, c$（小、中、大），并按中序遍历顺序摘下四棵子树挂上去。

- 衍生 
	- 插入与删除的对比  
		- **插入**：一旦发生失衡，调整后整棵树即恢复平衡。时间复杂度 $O(\log n)$ 查找 + $O(1)$ 旋转。
	    *   **删除**：调整一个局部失衡后，可能导致上层失衡，即**失衡可能会向上传播**。最坏情况下需要 $O(\log n)$ 次旋转。
	* 最小节点数与高度的关系
		*  问：高度为 $h$ 的 AVL 树，最少包含多少个节点？
	    *   公式：$N(h) = N(h-1) + N(h-2) + 1$。
	    *   这类似于斐波那契数列。$N(0)=1, N(1)=2, N(2)=4...$ (定义不同初始值可能不同，通常 $N(h) \approx \phi^h$)。
	- #旋转类型的判断   
		- 给定一个具体的失衡局部图，要求判断是 LL, RR, LR, 还是 RL 型旋转。
	    *   **技巧**：看 $g, p, v$ 的路径形状。
	        *   “撇” ($/$) 或 “捺” ($\backslash$) 直线型 $\to$ 单旋 (LL/RR)。
	        *   “小于号” ($<$) 或 “大于号” ($>$) 折线型 $\to$ 双旋 (LR/RL)。




![[Pasted image 20251214221300.png]]
[[Pasted image 20251119110604.png]]
[[Pasted image 20251119110609.png]]
- **核心结论：** AVL树在删除节点后，经过调整（旋转重平衡），该子树的高度**往往会降低**，从而导致其父节点的高度也发生变化，这种高度变化可能会一直向上传播到根节点。
	1.  **高度依赖性：** 树中任意节点$g$的高度取决于其左右子树的高度：$height(g)=\max(height(g.left),height(g.right))+1$。
	2.  **删除的影响：** 当删除一个节点$x$后，其所在子树的高度可能会减小$1$。
	3.  **失衡与调整：** 如果删除导致节点$g$失衡（即$|height(g.left)-height(g.right)|>1$），我们需要进行旋转操作（单旋或双旋）来恢复平衡。
	4.  **调整后的高度变化（关键点）：**
	    *   **与插入操作对比：** 在AVL树**插入**时，如果发生失衡并进行了旋转，旋转后的子树高度通常会恢复到插入前的高度，因此**不需要**继续向上传播调整（只需$O(1)$次旋转）。
	    *   **在删除操作中：** 旋转操作虽然恢复了$g$的平衡，但旋转后的新子树根节点的高度，很可能比删除操作发生之前的原$g$的高度要**小**。
	5.  **代码佐证：** 请看代码截图中的第4行 `for ( ... ; g; g = g->parent )` 和第7行 `updateHeight(g)`。代码显示删除操作需要**从下往上遍历所有祖先**。这是因为子树高度降低后，可能会导致上层祖先失衡，或者虽然上层未失衡但高度需要更新。第8行的注释明确写道：“**无论是否做过调整，全树高度均可能降低**”。

- 因此，题目陈述“经过调整，其高度可能不能保持原高度”是正确的。事实上，它通常会降低  

- 衍生  
	- 插入与删除的区别  
		- **考题：** “AVL树插入和删除后的调整过程有何不同？”
		*   **答案：** 插入操作引发的失衡是局部的，一次调整即可解决，不会传播；而删除操作引发的高度降低可能会向上传播至根节点，导致多层祖先失衡。  
	* 最小/最大节点数与高度的关系  
		* **考点：** 给定高度$h$，AVL树最少包含多少个节点？（斐波那契数列联系）
		*   **公式：** 设$N(h)$为高度为$h$的AVL树的最少节点数。
			    $N(h)=N(h-1)+N(h-2)+1$
		    其中$N(0)=0,N(1)=1$（或者是$N(0)=1,N(1)=2$，取决于高度定义是从0还是1开始）。
    *   这通常用于考察AVL树的高度依然保持在$O(\log n)$级别。




![[Pasted image 20251214221308.png]]
[[Pasted image 20251119110616.png]]

- 题目考察的是 **AVL树（平衡二叉搜索树）** 在**插入操作**导致失衡时，通过**单旋转**  恢复平衡的条件  
1. 答案推导：为什么 $p$ 的[[平衡因子]] 不可能是 0？  
	2. 当插入一个新节点后，我们向上回溯找到第一个失衡的祖先节点 $g$（即 $|BF(g)|=2$）。此时，$p$ 是 $g$ 的孩子，$v$ 是 $p$ 的孩子（也是新插入节点所在的子树根）。
	3. **只需要做一次旋转（单旋）** 就能恢复平衡，仅存在以下两种“直线型”情况：  
		1.  **LL型（左左）**：$p$ 是 $g$ 的左孩子，插入发生在 $p$ 的左子树。
		    *   此时 $g$ 极其左重，$BF(g)=2$。
		    *   为了让 $g$ 失衡，插入必须导致 $p$ 的高度增加。
		    *   因此，$p$ 也必须倾向于左边（因为插入在左边），即 $BF(p)=1$。
		    *   **操作**：对 $g$ 进行一次右旋（Right Rotation）。
		
		2.  **RR型（右右）**：$p$ 是 $g$ 的右孩子，插入发生在 $p$ 的右子树（即题目图片中的情况）。
		    *   此时 $g$ 极其右重，$BF(g)=-2$。
		    *   同理，$p$ 也必须倾向于右边，即 $BF(p)=-1$。
		    *   **操作**：对 $g$ 进行一次左旋（Left Rotation）。
	4. **结论**：
		在插入导致的单旋情况中，$g$ 和 $p$ 的平衡因子**符号必须相同**。
		*   若 $BF(g)=2$，则 $BF(p)=1$。
		*   若 $BF(g)=-2$，则 $BF(p)=-1$。
1. 如果 $BF(p)=0$，说明 $p$ 的左右子树高度相等。这意味着新节点的插入只是填补了 $p$ 较矮的那一侧，**并没有增加 $p$ 的总高度**。如果 $p$ 的高度没有增加，它就不会导致其父节点 $g$ 的平衡因子发生改变，也就不会引发失衡。 
2. 因此，**在旋转之前，节点 $p$ 的平衡因子一定不可能是零（必然是 $1$ 或 $-1$）。**

- 衍生 
	- 删除节点导致的失衡  
		- 如果在 **AVL树中删除一个节点** 导致 $g$ 失衡，且只需要做一次旋转，那么 $p$ 的平衡因子可以是0 
			- **场景**：$g$ 原本平衡，删除导致一边变矮，$g$ 变得不平衡（比如 $BF(g)$ 变成了 $-2$）。
			*   **分析**：此时查看较高那边的孩子 $p$。
			    *   如果 $BF(p)=-1$（同号），做单旋。
			    *   如果 $BF(p)=1$（异号），做双旋。
			    *   **特殊情况**：如果 $BF(p)=0$（即 $p$ 的左右子树一样高），此时只需要做一次**单旋**就可以恢复平衡（虽然旋转后的树高度不会降低，可能不需要继续向上回溯）。
			*   **结论**：插入时单旋 $p$ 必不为 0；**删除时单旋 $p$ 可以为 0**。


![[Pasted image 20251214221318.png]]
[[Pasted image 20251119110623.png]]
- 核心在于理解 **AVL树（平衡二叉搜索树）** 在删除节点后的平衡调整机制
1. 在 AVL 树中，保持平衡的规则是任意节点的左右子树高度差（平衡因子）绝对值不超过$1$。  
	1. **插入操作（对比）：** 当插入一个新节点导致不平衡时，我们只需要进行一次或两次旋转（单旋或双旋）就可以恢复整棵树的平衡。恢复后，子树的高度通常与插入前保持一致或不再引起上层不平衡，因此插入操作的旋转次数是常数级$O(1)$。  
2.  **删除操作（本题重点）：** 删除操作比较复杂。
    1.  当我们删除一个节点后，可能会导致其所在的子树高度减小。
    2.  如果该子树的高度减小导致其父节点失衡，我们需要进行旋转来恢复平衡。
    3.  **关键点：** 旋转操作虽然恢复了当前节点的平衡，但可能会导致**当前子树的整体高度进一步减小**。
    4.  这种“高度减小”可能会向上传播，导致父节点的父节点（祖父节点）也失去平衡。
    5.  在最坏的情况下（例如删除总是发生在某一条特定路径上），这种失衡可能一直传播到根节点。
    6.  由于 AVL 树的高度$h$与节点数$n$的关系为$h=O(\log n)$，因此在最坏情况下，我们需要沿着路径从删除点一直调整到根节点，每一层都可能需要旋转。

	**结论：** 既然树的高度是$\log n$量级，那么最坏情况下需要的旋转次数也是与高度成正比的，即$\Omega(\log n)$次。
[[AVL树的删除操作]] 
#AVL树的删除操作 


![[Pasted image 20251214221324.png]]
[[Pasted image 20251119110631.png]]

关于AVL树特例的经典题目。这道题考察的是**节点最少（最稀疏）的AVL树**，通常被称为 #斐波那契树 
1. 题目条件分析
	*   **8个叶节点**：树中有8个度为0的节点。
	*   **内部节点平衡因子都是+1**：这意味着对于树中的每一个非叶子节点，其左子树的高度都比右子树的高度大1。即$height(L) - height(R) = 1$。
2. 这种结构严格定义了一棵**斐波那契树**。我们可以通过递推的方式找出叶子节点数量与总节点数量的关系。  
3. 设$h$为树的高度，$N_h$为高度为$h$的树的总节点数，$L_h$为高度为$h$的树的叶子节点数。
根据平衡因子为+1的规则，高度为$h$的树由高度为$h-1$的左子树和高度为$h-2$的右子树组成。
#二叉搜索树BST  
**递推公式：**
*   **叶子节点数**：$L_h = L_{h-1} + L_{h-2}$ （符合斐波那契数列规律）
*   **总节点数**：$N_h = N_{h-1} + N_{h-2} + 1$ （根节点+左子树节点+右子树节点） 
	**列表推演：**
	*   **$h=0$** (仅1个根节点，它是叶子):
	    *   $L_0 = 1$
	    *   $N_0 = 1$
	*   **$h=1$** (根节点 + 左子树$T_0$ + 右子树空):
	    *   $L_1 = 1$ (即左子树的那个叶子)
	    *   $N_1 = 2$
	*   **$h=2$** (左$T_1$，右$T_0$):
	    *   $L_2 = L_1 + L_0 = 1 + 1 = 2$
	    *   $N_2 = N_1 + N_0 + 1 = 2 + 1 + 1 = 4$
	*   **$h=3$** (左$T_2$，右$T_1$):
	    *   $L_3 = L_2 + L_1 = 2 + 1 = 3$
	    *   $N_3 = N_2 + N_1 + 1 = 4 + 2 + 1 = 7$
	*   **$h=4$** (左$T_3$，右$T_2$):
	    *   $L_4 = L_3 + L_2 = 3 + 2 = 5$
	    *   $N_4 = N_3 + N_2 + 1 = 7 + 4 + 1 = 12$
	*   **$h=5$** (左$T_4$，右$T_3$):
	    *   $L_5 = L_4 + L_3 = 5 + 3 = 8$  **<-- 题目给出的条件：8个叶节点**
	    *   $N_5 = N_4 + N_3 + 1 = 12 + 7 + 1 = 20$ **<-- 对应的总节点数**
**结论：**
当叶子节点数为8时，对应的总节点数为**20**。

- 衍生 
	- 给定高度求最少节点数  
		- 题目可能会直接问：“高度为5的AVL树，最少包含多少个节点？”
		*   **解法**：使用递推公式$N_h = N_{h-1} + N_{h-2} + 1$。
		    *   $N_0=1, N_1=2, N_2=4, N_3=7, N_4=12, N_5=20$。
		    *   或者记忆公式：$N_h \approx \frac{\phi^{h+3}}{\sqrt{5}} - 1$，其中$\phi \approx 1.618$。
	- 给定节点数求最大高度 
		这是考点一的逆运算。题目问：“一棵有20个节点的AVL树，其最大高度是多少？”
		*   **解法**：反查上述序列。节点数$n$满足 $N_h \le n < N_{h+1}$。
		    *   因为$N_5=20$，刚好满足，所以最大高度是5。
		    *   如果节点数是15，介于$N_4(12)$和$N_5(20)$之间，最大高度只能是4。
		*   **公式**：$h_{max} \approx 1.44\log_2(n+1)$。
	* 叶子节点与非叶子节点的关系  
		* 在**任意二叉树**中，度为0的节点数$n_0$与度为2的节点数$n_2$的关系是：
				$n_0 = n_2 + 1$
		*   **注意**：这个公式在AVL树题目中通常**不能直接用来求总节点数**，因为AVL树中可能存在大量度为1的节点。例如本题中$N=20$，叶子$n_0=8$，则非叶子节点有12个。由于$n_0 = 8$，若假设没有度为1的节点，则$n_2=7$，总数应为15，但这与20不符，说明这棵树中有$20 - 8 - 7 = 5$个度为1的节点。
	- 平衡因子的分布
		- 题目可能会问：“在上述最少节点的AVL树中，有多少个节点的平衡因子为0？”
		*   **分析**：在严格定义的斐波那契树（所有内部节点平衡因子均为+1或-1）中，只有叶子节点的平衡因子在插入后可能为0（视定义而定，通常叶子BF=0）。但在构造过程中，如果严格按照$N_h$的最少节点构造，除了叶子节点外，没有节点的BF是0。


![[Pasted image 20251119110639.png]]
![[Pasted image 20251119110645.png]]