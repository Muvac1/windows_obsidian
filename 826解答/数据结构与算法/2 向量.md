![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=5&rect=23,717,574,807|826历年真题解析-数据结构篇（包括算法题）-12.15, p.5]]
#有序向量查找  #有序向量  
1. 核心逻辑：比较操作的成本不对称性
	1. “常系数”指的是算法时间复杂度$T(n)=c\cdot\log n$中的常数项$c$  
		1. 虽然Fibonacci查找和二分查找的渐进时间复杂度都是$\Theta(\log n)$，但在具体的常数因子上，不同的分割点选择会有差异。
	2. 分割点的选择 
		1. 区间$[0, 1]$中，黄金分割点有两个：左侧的$0.382$（即$1-\phi$）和右侧的$0.618$（即$\phi$）  
			1.   **方案A（主流做法）**：取$0.618$处为轴点（$mid$）。此时左子区间长度为$0.618$，右子区间长度为$0.382$
			2.  **方案B**：取$0.382$处为轴点。此时左子区间长度为$0.382$，右子区间长度为$0.618$
	3. 比较次数的差异  
		1. 典型的比较逻辑中，我们通常先判断“是否小于”，再判断“是否大于”（或者进入右侧分支）  
		2.  若`target < A[mid]`：进行**1次**比较，转向左侧区间。
		    *   若`target > A[mid]`：进行**2次**比较（先判断不小于，再判断大于），转向右侧区间。
	4. 期望成本分析  
		1. 为了优化平均查找长度（ASL），应该让比较次数少（成本低）的分支对应更大概率（长度更长）的区间
			-   **左侧分支**成本低（1次比较），应该对应**长区间**（$0.618$）。
		    *   **右侧分支**成本高（2次比较），应该对应**短区间**（$0.382$）。
2. 结论  
	1. 如果采用方案A（轴点在$0.618$），常系数较小，效率较高。
		如果采用方案B（轴点在$0.382$），由于长区间落在了高成本的右侧分支，导致平均比较次数增加，即
		**常系数变大**。
3. 因此，以前后黄金分割点作为轴点的常系数**不相同**，题目说法错误。
  
[[斐波那契数列]]    [[斐波那契查找（Fibonacci查找）]] 

- 衍生  
	1. 二分查找 vs Fibonacci查找 vs 插值查找  
		1. 二分查找
			*   分割点：$0.5$。
		    *   复杂度：$\Theta(\log n)$。
		    *   适用性：通用，最常用。
		2.   **Fibonacci查找**：
		    *   分割点：$0.618$。
		    *   复杂度：$\Theta(\log n)$。
		    *   考点：如本题所述，针对左右分支比较成本不同时的优化（左长右短）。
		 3.  插值查找：
		    *   分割点：自适应，公式为$mid=low+\frac{key-A[low]}{A[high]-A[low]}(high-low)$。
		    *   复杂度：数据均匀分布时为$\Theta(\log\log n)$，最坏情况（如指数分布）退化为$\Theta(n)$。
		    *   考点：适用于表长较大且关键字分布比较均匀的情况。
	2. 平均查找长度 (ASL) 的计算  
		1. 给出一个具体的长度$n$（例如$n=10$或$n=12$），要求画出Fibonacci查找的判定树，并计算查找成功或失败时的平均查找长度。
			*   公式：$ASL_{success}=\frac{1}{n}\sum_{i=1}^{n}C_i$，其中$C_i$是第$i$个元素被找到时的比较次数（即判定树的层数）
	3. #数组长度的补齐        [[数组补齐（斐波那契查找）]] 
		1. Fibonacci查找要求数组长度$n$满足$F[k]-1$。如果实际长度不满足，需要将数组扩展到$F[k]-1$，通常将扩展出的位置填充为原数组的最后一个元素值。
			*   **考点**：如果$n=10$，应该选哪个Fibonacci数？
			    序列：$1, 1, 2, 3, 5, 8, 13, \dots$
			    因为$8-1 < 10 < 13-1$，所以应选$F[k]=13$，数组需补齐到$12$。
	4. 判定树的高度  
		1.  二分查找判定树的高度为$\lfloor\log_2n\rfloor+1$。
		*   Fibonacci查找判定树的高度与Fibonacci数的索引$k$相关，约为$1.44\log_2n$（因为黄金比例的底数不同）。虽然都是$\log$级别，但Fibonacci树通常比二分查找树略深（常系数差异）



![[Pasted image 20251125140534.png]][[Pasted image 20251119065844.png]]

- 衍生 
	-  #折半查找判定树    
		-  **考点**：折半查找判定树是一棵**平衡二叉树 (AVL)**（或接近平衡）。
		*   **最大比较次数**：对于长度为$n$的顺序表，折半查找在查找不成功或查找最坏情况下，关键字的比较次数不超过$\lfloor\log_2n\rfloor+1$。  
	* #平均查找长度ASL  计算  
		* 考试常考计算具体的ASL值。
		*   **公式**：$ASL = \sum P_i \times C_i$（$P_i$是查找第$i$个元素的概率，$C_i$是找到第$i$个元素需要的比较次数）。
		*   **折半查找 ASL**：需要画出判定树，统计每一层有多少个节点。
				*   $ASL_{成功} = \frac{1}{n} \sum_{j=1}^{h} j \times N_j$（$h$是树高，$N_j$是第$j$层的节点数）。
	 - 存储结构的限制  
		 - **判断题**：“折半查找可以在 #有序链表 上进行吗？”
	    *   **答案**：不可以（或者说效率极低）。因为链表不支持随机访问，定位中间元素需要从头遍历，这会使得时间复杂度退化为$O(n)$，失去了折半查找的意义。
	* #分块查找 (索引顺序查找)   
		*  这是介于顺序查找和折半查找之间的一种方法。
		*   **特点**：块内无序，块间有序。
		*   **考法**：通常结合 #索引表 进行考察，索引表采用折半查找，块内采用顺序查找。
		

![[Pasted image 20251123112305.png]][[Pasted image 20251119065852.png]]
这道题是典型的**数据结构**中关于特殊矩阵（对称矩阵） #压缩存储 的考点。 [[压缩存储]] 
1. 计算元素在压缩数组中的相对位置（索引 $k$）   #矩阵压缩  
	1. 起始地址（基地址）：$Loc(a[0][0]) = 1000$
		*   目标元素地址：$Loc(a[i][j]) = 2000$
		*   每个数据占用单元大小：$L = 2$
	 2.  #一维数组的地址计算公式 ：
		$Loc(a[i][j]) = Loc(a[0][0]) + k \times L$  
	3. 代入数值：
		$2000 = 1000 + k \times 2$
		$1000 = 2k$
		$k = 500$
	4. 意味着，$a[i][j]$ 是压缩后的一维数组中的第$500$个元素（下标从$0$开始，即$a'[500]$）  
2. 建立二维坐标 $(i, j)$ 与一维索引 $k$ 的关系  
	1. 题目中提到是**对称矩阵**且存储**下三角**（$i \ge j$），采用**行优先**（Row-major）存储
		*   **第 $0$ 行**：有 $1$ 个元素 $(0,0)$
		*   **第 $1$ 行**：有 $2$ 个元素 $(1,0), (1,1)$
		*   **第 $2$ 行**：有 $3$ 个元素 $(2,0), (2,1), (2,2)$
		*   ...
		*   **第 $i-1$ 行**：有 $i$ 个元素
	2. 到达第$i$行之前，前$i$行（从第$0$行到第$i-1$行）的总元素个数是一个等差数列求和：
		$Sum = 1 + 2 + 3 + \dots + i = \frac{i(i+1)}{2}$ 
		1. 第$i$行内部，由于是下三角，$a[i][j]$ 前面还有 $j$ 个元素（即列下标 $0$ 到 $j-1$）
			1. 因此，映射公式为：
				$k = \frac{i(i+1)}{2} + j$
3. 求解 $i$ 和 $j$   
	1. 找到满足上述公式的$i$和$j$，已知 $k=500$。
		$500 = \frac{i(i+1)}{2} + j$  
	2. 这里有一个约束条件：$0 \le j \le i$（因为是下三角）。这意味着 $\frac{i(i+1)}{2}$ 必须是小于等于$500$的最接近的数   
		1. 可以通过估算或解方程来找$i$：
			$\frac{i^2}{2} \approx 500 \Rightarrow i^2 \approx 1000 \Rightarrow i \approx 31.6$  
	3. 验证一下 $i=31$：
		$\text{前31行的总数} = \frac{31 \times (31+1)}{2} = \frac{31 \times 32}{2} = 496$  
	4. 因为 $496 \le 500$，说明目标元素确实在第$31$行。
		接下来求 $j$：
		$j = k - \text{前i行的总数} = 500 - 496 = 4$
4. 所以，答案是：
	$i = 31, j = 4$    

- 图片中直接给出了求解$i$的公式：
	$i = \lfloor \frac{\sqrt{8k+1}-1}{2} \rfloor$
	 [[Pasted image 20251119065852.png]]
	这个公式是由 $k \approx \frac{i(i+1)}{2}$ 推导出来的逆运算：
	1.  近似认为 $k = \frac{i^2+i}{2}$
	2.  整理得一元二次方程：$i^2 + i - 2k = 0$
	3.  利用求根公式 $i = \frac{-b + \sqrt{b^2 - 4ac}}{2a}$，其中 $a=1, b=1, c=-2k$
	4.  $i = \frac{-1 + \sqrt{1 - 4(1)(-2k)}}{2} = \frac{\sqrt{8k+1}-1}{2}$ （取正根）
	5.  由于$j$的存在，$k$通常比刚好填满$i$行要大一点，所以计算结果向下取整即可得到正确的行号$i$。
	代入 $k=500$：
	$i = \lfloor \frac{\sqrt{4001}-1}{2} \rfloor \approx \lfloor \frac{63.25-1}{2} \rfloor = \lfloor 31.125 \rfloor = 31$

- 衍生  
	-  #存储上三角矩阵    
		-  **场景**：存储 $i \le j$ 的部分  
		- 推导  
			- 第$0$行有$n$个元素，第$1$行有$n-1$个元素...
		    *   映射公式会变为：$k = \frac{i(2n - i + 1)}{2} + (j - i)$ （假设行优先）。
		    *   **注意**：上三角的公式推导比下三角复杂，建议考试时现场画图推导前几行规律，不要死记硬背。
	* 列优先存储   
		*  **场景**：题目改为“列优先”存储下三角矩阵  
	- 数组下标从1开始  
		-  **场景**：题目说矩阵是 $A[1..n][1..n]$，且 $a[1][1]$ 是第一个元素  
		- 推导  
			- 第$1$行有$1$个元素，第$2$行有$2$个... 第$i$行有$i$个。
		    *   在第$i$行之前（$1$到$i-1$行）共有 $\frac{(i-1)i}{2}$ 个元素。
		    *   第$i$行内，$a[i][j]$ 前面有 $j-1$ 个元素。
		    *   公式变为：$k = \frac{i(i-1)}{2} + (j-1)$ （如果$k$也是从0开始编号）
	* #三对角矩阵  
		* **场景**：非零元素只分布在主对角线及上下两条对角线上（$|i-j| \le 1$）。
		*   **公式**：通常公式为 $k = 2i + j$ （当下标从0开始时）。
		*   **推导**：第$0$行$2$个元素，第$1$到$n-2$行每行$3$个元素...
### 总结

解决此类问题的核心步骤：
1.  **算偏移量**：根据地址算出是一维数组的第几个元素（$k$）。
2.  **找规律**：根据行优先/列优先、上三角/下三角，写出前几行的元素个数。
3.  **列公式**：利用等差数列求和公式建立 $k$ 与 $i, j$ 的方程。
4.  **求解**：估算求解 $i$，再反推 $j$。


![[Pasted image 20251123112251.png]]
[[Pasted image 20251119065900.png]]
- 这道题目的核心在于考察**动态数组（Vector）的空间管理策略**以及分摊复杂度分析
1. [[动态数组的扩容与缩容]]  
	1. 题目中的策略是：“满（100%）则倍增，少于一半（50%）则减半”。这个策略看似合理，实际上会导致一种被称为 #复杂度震荡 的最坏情况    
2. 假设当前向量的容量（Capacity）为$N$，且当前元素数量（Size）也为$N$  
	1. 插入操作（push_back）
		1.  因为已满，需要扩容。容量变为$2N$。
		    *   需要将原来的$N$个元素复制到新空间。
		    *   **时间消耗：**$O(N)$。
		    *   此时：Size =$N+1$，Capacity =$2N$，装填因子 $\approx 50\%$
	2. 删除操作（pop_back）  
		1. 删除刚才插入的元素。Size 变回$N$。
		    *   此时装填因子为$N/2N=50\%$。
		    *   **根据题目策略**（不足50%或等于50%触发），触发缩容。容量减半回$N$。
		    *   需要将$N$个元素复制回新空间。
		    *   **时间消耗：**$O(N)$
	3. 重复上述过程  
		1. 用户反复执行“插入-删除-插入-删除”的操作，每一次操作都会触发$O(N)$级别的内存申请和数据搬运  
		2. 原本期望的$O(1)$分摊复杂度，在这种边界情况下退化成了$O(N)$  
3. **结论：**
	为了避免这种震荡，缩容的阈值必须**远小于**扩容后达到的[[装填因子]] 。通常的做法是： #装填因子 为100%时扩容（加倍），但装填因子下降到25%时才缩容（减半）。
- 衍生 
	- #扩容倍数 为什么通常是2？可以是其他数吗？   #扩容倍数对复杂度的影响  
		-  **问题：** 扩容倍数$k$（Growth Factor）对复杂度有何影响？  
		-   **解析：**
		    *   如果每次扩容增加固定大小（如增加10个位置），分摊复杂度是$O(N)$。
		    *   如果按比例扩容（如$k=1.5$或$k=2$），分摊复杂度是$O(1)$。
		    *   **$k=2$ vs $k=1.5$：**
		        *   $k=2$：实现简单（ #位运算 ），但可能导致 #内存碎片 ，因为新申请的空间总是大于之前所有旧空间之和，无法重用旧空间。
		        *   $k=1.5$（或黄金分割比）：在多次扩容后，新申请的空间可能小于之前释放的空间总和，理论上可以重用之前的内存块（缓存友好）。Java的`ArrayList`通常取1.5，C++ STL的`vector`通常取2（取决于具体实现）。
	- #势能分析法计算复杂度     
		-   **问题：** 如何用数学证明扩容策略的分摊复杂度是$O(1)$？
		*   **解析：** 定义势能函数$\Phi$。
		    *   当操作廉价时（不扩容），积累势能；
		    *   当操作昂贵时（扩容），消耗势能支付代价。
		    *   公式：$\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1})$。
		    *   只要证明对于任意序列，总分摊成本 $\sum \hat{c}_i$ 是 $O(N)$（即单次$O(1)$），即可证明策略有效
	- #缩容的正确策略（滞后性）  
		- **问题：** 如果扩容倍数是$k$， #缩容阈值 应该是多少才能保证$O(1)$？
		*   **解析：** 必须利用**滞后性（Hysteresis）**。
		    *   如果扩容后装填因子变为$1/k$（例如倍增后变为$0.5$）。
		    *   缩容阈值必须严格小于$1/k$。
		    *   例如：扩容倍数$k=2$，扩容后$\lambda=0.5$。缩容阈值设为$0.25$是安全的。如果设为$0.5$，就会震荡。
	* 时间与空间的权衡
		* **问题：** 为什么不让装填因子始终保持在90%以上？
		*   **解析：**
		    *   **高装填因子：** 节省空间，但导致频繁扩容，增加时间开销。
		    *   **低装填因子：** 浪费空间，但减少扩容次数，提高速度。
		    *   Vector的设计本质上是**以空间换时间**。
![[Pasted image 20251126010925.png]]
[[Pasted image 20251126010915.png]]    [[向量数据结构vector]] 
- 题目中提到的数据结构是“向量”（Vector），在计算机科学中，通常指的是**顺序存储结构**（如数组），其特点是内存地址连续   
1.  **操作过程：** 当我们在长度为$n$的向量中删除第$r$个元素（索引为$r$）时，为了保持内存的连续性，该元素之后的所有元素（即索引从$r+1$到$n-1$的元素）都需要向前移动一位，填补被删除元素留下的空缺。  
	1.  **计算移动次数：** 需要移动的元素个数是$n-1-r$（或者近似看作$n-r$）  
	2. **时间复杂度：** 算法的耗时主要取决于元素的移动次数。因此，删除操作的时间复杂度与$(n-r)$成正比，即$O(n-r)$。  
2. 题目声称时间复杂度是$O(1+r)$（即$O(r)$），这意味着$r$越大（越靠近末尾），耗时越长。这与事实恰恰相反：在向量中，**$r$越大，后面需要移动的元素越少，耗时越短**。
	*   如果$r=n-1$（删除最后一个元素），移动0个元素，时间复杂度为$O(1)$。
	*   如果$r=0$（删除第一个元素），移动$n-1$个元素，时间复杂度为$O(n)$
因此，题目说法错误，正确的时间复杂度应为$O(n-r)$




![[Pasted image 20251119065914.png]]![[Pasted image 20251119065923.png]]