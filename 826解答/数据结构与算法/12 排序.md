[[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=47&rect=20,713,581,808|826历年真题解析-数据结构篇（包括算法题）-12.15, p.47]]
![[Pasted image 20251216060011.png]] 
- 核心逻辑在于混淆了**比较次数**的时间复杂度与**移动元素**的时间复杂度  
1. 为什么是 $O(n^2)$ 而不是 $O(n\log n)$？  
	1. #排序算法的时间复杂度 通常由两个主要操作决定：比较 和 移动 
		1. #折半插入排序 是对 #直接插入排序 的优化，优化的仅仅是“寻找插入位置”这一步。
			*   **寻找插入位置（比较操作）：**
			    使用 #二分查找 代替 #顺序查找 。对于第$i$个元素，查找位置的时间复杂度从$O(i)$降低到了$O(\log i)$。整个排序过程中，总的比较次数大约为$\sum_{i=1}^{n} \log i$，即$O(n\log n)$。
			    *这看起来很好，符合题目中的前半句描述。*
			*   **插入元素（移动操作）：**
			    这是关键瓶颈所在。在数组（顺序表/向量）中，一旦找到了插入位置，为了把新元素放进去，你必须把该位置之后的所有元素向后移动一位。
			    对于第$i$个元素，平均需要移动$\frac{i}{2}$个元素，即移动操作的时间复杂度是$O(i)$。
			    整个排序过程中，总的移动次数大约为$\sum_{i=1}^{n} \frac{i}{2}$，这是一个 #等差数列求和公式  ，结果为$O(n^2)$。[[数列求和公式]]
**结论：**
	虽然比较次数减少到了$O(n\log n)$，但是移动次数依然保持在$O(n^2)$。在计算总时间复杂度时，取最高阶项：
	$TotalTime = O(n\log n) + O(n^2) = O(n^2)$
	所以，题干说时间复杂度是$O(n\log n)$是错误的。 
2. “向量”和“列表”的区别，这是为了封死另一种可能性的辩解：  
	1.  **情况一：使用向量（Vector/顺序表/数组）**
	    *   **查找：** 支持随机访问，可以使用二分查找，耗时$O(\log n)$。
	    *   **移动：** 插入元素需要移动数组中大量数据，耗时$O(n)$。
	    *   **总计：** $O(n^2)$。
	*   **情况二：使用列表（List/链表）**
	    *   **查找：** 链表不支持随机访问（不能直接跳到中间节点），无法进行真正意义上的二分查找。要在链表中找到第$k$个位置，必须从头遍历，耗时$O(n)$。
	    *   **移动：** 只需要修改指针，耗时$O(1)$。
	    *   **总计：** 查找的$O(n)$乘以$n$个元素，依然导致总时间为$O(n^2)$。
* **简单总结：** 无论是用数组还是链表，都无法同时解决“快速查找”和“快速移动”这两个问题，因此折半插入排序无法突破的界限。 

- 衍生 
	- #插入排序的稳定性
		- **问题：** 折半插入排序是稳定的吗？
		*   **答案：** 是稳定的。虽然查找位置用了二分法，但只要在二分查找时，当遇到相等元素，将插入位置定在相等元素的**后面**，就能保证稳定性。 
	* 与其他 $O(n^2)$ 排序的对比 
		*  **直接插入排序 vs 折半插入排序：**
		    *   时间复杂度都是$O(n^2)$。
		    *   **区别：** 折半插入排序的**比较次数**显著少于直接插入排序（$O(n\log n)$ vs $O(n^2)$）。如果题目问“哪种排序比较次数最少”，折半插入优于直接插入；但如果问“移动次数”，两者相当。
	- 真正 $O(n\log n)$ 的排序算法  
		- 既然折半插入排序达不到$O(n\log n)$，那么谁能达到？
			*   **快速排序 (Quick Sort)**、**归并排序 (Merge Sort)**、**堆排序 (Heap Sort)**。
			*   **考点逻辑：** 为什么堆排序可以达到$O(n\log n)$？因为它使用堆结构（类似完全二叉树）优化了选择最大/最小值的过程，且不需要像数组插入那样线性移动数据（它主要靠交换）。
	- #数据结构的选择对复杂度的影响 
		*   **公式化记忆：**
		    *   二分查找的前提是：**顺序存储**（数组）且**有序**。
		    *   链表上进行二分查找是不切实际的，时间复杂度会退化为$O(n)$。这一点常用于判断题陷阱。
 总结公式
	$T_{BinaryInsertion} \approx \underbrace{O(n\log n)}_{Comparison} + \underbrace{O(n^2)}_{Movement} = O(n^2)$
![[Pasted image 20251216060019.png]]
[[Pasted image 20251119211354.png]]
#起泡排序  #气泡排序 
- 虽然起泡排序的大趋势是将大元素往后移（假设升序），将小元素往前移，但在具体的交换过程中，**某些元素可能会被迫向反方向移动**
- **设定场景：**
	假设我们要对一个包含$n$个元素的序列进行升序排列。
	序列初始状态为：$\{n,n-1,1,2,\dots,n-2\}$。

	**分析特定元素$n-1$的移动轨迹：**
	1.  **目标位置：** 在排好序的最终序列中，$n-1$是第二大的数，它的最终位置应该在序列的**倒数第二个**位置（索引为$n-2$）。
	2.  **初始位置：** 在当前序列中，它位于**第二个**位置（索引为$1$）。
	3.  **第一轮排序过程：**
	    *   算法首先比较第1个元素$n$和第2个元素$n-1$。
	    *   因为$n>n-1$，两者发生交换。
	    *   此时序列变为：$\{n-1,n,1,2,\dots\}$。
	4.  **结论：**
	    *   在这次交换中，元素$n-1$从索引$1$移动到了索引$0$。
	    *   它的**最终位置**是在右侧的$n-2$处。
	    *   也就是它原本就在左边，结果因为被更大的数$n$“挤”了一下，反而往**更左边**（远离最终位置的方向）移动了一步。


	- [[起泡排序（气泡排序）]] 
		*   **基本思想：** 从前往后（或从后往前）两两比较相邻元素的值，若为逆序（即$A[i]>A[i+1]$），则交换它们，直到序列比较完。这一过程称为“一趟”起泡。
		*   **过程特征：** 每一趟起泡都会将当前待排序序列中的最大关键字交换到最后的位置（像气泡一样浮上来）。
		*   **时间复杂度：**
		    *   最好情况（已有序）：$O(n)$
		    *   最坏情况（逆序）：$O(n^2)$
		    *   平均时间复杂度：$O(n^2)$
		*   **空间复杂度：** $O(1)$（仅需常数个辅助单元）。
		*   **稳定性：** **稳定**。因为$A[i]=A[i+1]$时不交换，相同元素的相对位置不会改变。
- 衍生 
	- #交换次数与逆序对的关系（起泡排序）   
		- 这是起泡排序最核心的数学考点。
			*   **原理：** 起泡排序中的每一次交换操作，本质上都是消除了一个**逆序对**。
			*   **公式：** 序列的交换次数$K$严格等于该序列初始状态下的逆序对总数$I$。
			*   **考题形式：** 给定一个序列，问需要进行多少次交换才能完成排序？
			    *   **解法：** 计算该序列的逆序对数量即可。
			    *   例如序列$3,1,4,2$，逆序对为$(3,1),(3,2),(4,2)$，共3个，故需交换3次。
	- 排序趟数与标志位优化 
		- **普通考点：** $n$个元素的起泡排序，最多需要进行$n-1$趟排序。
		*   **优化考点：**如果在某一趟排序中，**没有发生任何一次交换**，说明序列已经有序，算法可以提前终止。
	    *   代码中常设置一个`flag`变量来记录本趟是否有交换。
	- 元素移动速度的差异（“乌龟”与“兔子”）  
		-  **现象：**
		    *   **兔子（大数）：** 在升序排序中，大的元素（如$n$）可以通过一趟排序从最左边一直移到最右边，移动速度很快。
		    *   **乌龟（小数）：** 小的元素（如$1$）如果位于序列的最末端，在每一趟排序中只能向左移动一步（因为它只能被交换一次）。
		*   **考题形式：** 哪种输入数据会导致起泡排序最慢？
		    *   **答案：** 最小的元素位于序列的最后面（如$2,3,4,5,1$），这会导致需要$n-1$趟才能将其移到最前面。
	- 比较次数的计算  
		-  **最坏情况：** 也就是初始为逆序，需要的比较次数为$C_{max}=\frac{n(n-1)}{2}$。
		*   **最好情况：** 初始已有序，只需比较第一趟，次数为$C_{min}=n-1$。  
	* #局部有序性的利用   
		* 题目可能会给出一个局部有序的序列，问 #起泡排序的效率 。例如：已知序列$A[1\dots n]$中，前$k$个元素已经有序且均小于后$n-k$个元素，分析此时的复杂度。  



![[Pasted image 20251216060024.png]]
[[Pasted image 20251119211404.png]]
- 直接插入排序 在**最坏情况**下的比较次数推导出来的
- 待排序序列为$(64,63,\dots,2,1)$。
	这是一个完全**逆序**（从大到小）的序列，而通常排序的目标是**升序**（从小到大）。对于直接插入排序来说，逆序是**最坏情况  
1. **具体步骤：**
	假设序列长度为$n$，在此题中，$n=64$（从1到64共有64个数）。
	直接插入排序的逻辑是将第$i$个元素插入到前面已经排好序的$i-1$个元素中。
	*   **第1趟：** 插入$63$。前面只有$[64]$。$63$需要和$64$比较1次，然后插入到最前面。
	    *   比较次数：$1$
	*   **第2趟：** 插入$62$。前面是$[63,64]$。$62$需要依次和$64,63$比较，共比较2次，才能找到位置（最前面）。
	    *   比较次数：$2$
	*   **第3趟：** 插入$61$。前面是$[62,63,64]$。$61$需要比较3次。
	    *   比较次数：$3$
	*   ...
	*   **第$i$趟：** 插入第$i+1$个元素。前面有$i$个有序元素。在最坏情况下，新元素比前面所有元素都小，需要一直比较到第一个元素之前。
	    *   比较次数：$i$
	*   **最后一般（第$n-1$趟）：** 插入$1$。前面有$n-1$个有序元素（即$63$个）。$1$比它们都小，需要比较$n-1$次。
	    *   比较次数：$n-1$
	**总比较次数计算：**
	将每一趟的比较次数相加，构成一个等差数列求和：
	$Sum=\sum_{i=1}^{n-1}i=1+2+3+\dots+(n-1)$
	将$n=64$代入公式：
	$Sum=1+2+3+\dots+63$
	利用等差数列求和公式$\frac{k(first+last)}{2}$：
	$Sum=\frac{63(1+63)}{2}=\frac{63\times64}{2}=63\times32=2016$
**结论：**
	计算结果为2016。在给出的选项中：
	(A) 2800
	(B) 2600
	(C) 2400
	(D) 2200
	(E) 2000
	2016最接近2000，因此选择(E)。

- 衍生 
	- #折半插入排序 
		- **考点：** 在查找插入位置时，使用 #二分查找 代替顺序查找。
		*   **区别：** 比较次数减少到了$O(n\log n)$级别，但是**移动元素的次数**并没有改变，依然是$O(n^{2})$。因此总的时间复杂度仍然是$O(n^{2})$。
		*   **公式：** 比较次数与初始序列的顺序无关（因为总是要二分查到底）
	* #希尔排序  
		* **考点：** 希尔排序是基于插入排序的改进（又称缩小增量排序）。
		*   **关联：** 它利用了插入排序在“基本有序”或“n较小”时效率很高的特点。
		*   **不稳定性：** 希尔排序是**不稳定**的，这是它与直接插入排序的一个重要区别。
	- 排序算法的比较与移动次数  
		- **选择排序（Selection Sort）：** 无论数据是否有序，比较次数永远是$\frac{n(n-1)}{2}$，即$O(n^{2})$。如果题目问“哪种排序的比较次数与初始状态无关”，答案通常是选择排序。
		*   **冒泡排序（Bubble Sort）：** 最坏情况（逆序）下的比较次数与直接插入排序相同，也是$\frac{n(n-1)}{2}$。
	* #链表上的插入排序  
		*  **考点：** 如果数据存储在链表中，直接插入排序只需要修改指针，不需要移动数据（移动次数为0），但比较次数依然是$O(n^{2})$。注意：链表上无法使用折半插入排序。  
* 总结公式备忘：
	*   直接插入排序最坏比较次数：$\frac{n(n-1)}{2}$
	*   直接插入排序最好比较次数：$n-1$
	*   选择排序总是比较：$\frac{n(n-1)}{2}$



![[Pasted image 20251216060030.png]]
[[Pasted image 20251119211413.png]]

这道题考察的是对 #基于比较的排序算法CBA 的 #时间复杂度下界理论 的理解，以及对具体排序算法在不同情况（最好、最坏）下表现的区别
1.   **题干含义**：题目声称“对于**所有**大小为$n$的数组，基于 CBA 的排序算法的时间复杂度都是$\Omega(n\lg n)$”。  
2. 这是一个**特称命题**与**全称命题**的逻辑陷阱 
	1. 理论下界  
		1. 确实存在一个定理，指出“任何基于比较的排序算法在**最坏情况**下的时间复杂度下界是$\Omega(n\lg n)$”。这意味着，不存在任何一种比较排序算法能在最坏情况下比$n\lg n$更快  
3. #反例  
	1. 虽然最坏情况是$\Omega(n\lg n)$，但题目说的是“对**所有**数组”。这包含了 最好情况  
	2. 结合图片解析
		1. 图片中的解析提到了“插入和起泡最好情况都是$O(n)$”。
		    *   如果输入数组已经是很多序的（例如 `[1, 2, 3, 4, 5]`），插入排序和改进后的冒泡排序只需要进行$n-1$次比较，不需要移动或交换元素。
		    *   此时，它们的时间复杂度是$O(n)$。 
	3. **结论**：因为$O(n)$远小于$\Omega(n\lg n)$，所以并非“所有”情况都至少需要$n\lg n$的时间。只要存在一种情况（最好情况）使得时间少于$n\lg n$，原命题即为**假（False，×）**。
 [[决策树模型与下界定理]] 
- 衍生 
	- 如何突破 $\Omega(n\lg n)$ 的限制  
		- **考点**：题目可能会问“是否存在时间复杂度为$O(n)$的排序算法？”
		*   **答案**：存在，但**不是基于比较的**。
		*   **例子**：**计数排序 (Counting Sort)**、**基数排序 (Radix Sort)**、**桶排序 (Bucket Sort)**。
		*   **原理**：利用元素的值与其位置的映射关系，而非两两比较。这些算法可以在$O(n)$或$O(n+k)$的时间内完成排序。
	* 关于“平均情况”的下界  
		*  **考点**：如果题目改成“基于比较的排序算法的**平均**时间复杂度下界是$\Omega(n\lg n)$”，这句话是对的还是错的？
		*   **答案**：这是**对**的（True）。虽然最好情况可以是$O(n)$，但从数学期望来看，对于随机输入的数组，基于比较的排序平均至少需要$\Omega(n\lg n)$次比较。
	- 特定算法的特性    
		- **考点**：哪些基于比较的排序算法在最好情况下能达到$O(n)$？
		*   **答案**：**插入排序**和**冒泡排序**（带标志位优化）。像堆排序和归并排序，即使数组已经有序，它们通常还是要跑完完整的流程，时间依然是$O(n\lg n)$。  
	* $\Theta, O, \Omega$ 的严格定义 
		* 辨析符号含义。
		    *   $O(f(n))$：上界（不超过...）
		    *   $\Omega(f(n))$：下界（至少...）
		    *   $\Theta(f(n))$：紧确界（既是上界又是下界）
		*   题目中用$\Omega(n\lg n)$描述最好情况是错误的，因为$n$的增长率低于$n\lg n$，即$n \in o(n\lg n)$。


![[Pasted image 20251216060036.png]]
[[Pasted image 20251119211418.png]]

核心知识点是 序列中的逆序对性质 以及 元素交换对逆序对数量的影响 

1. **核心结论：**
	如果我们交换序列中任意一对**逆序元素**（即前大后小的一对数），整个序列的逆序对总数**必然减少**。  
2. 推导逻辑
	1. 假设原序列为$A$，我们在位置$i$和$j$（其中$i<j$）找到了两个元素$A_i$和$A_j$，并且满足$A_i>A_j$（这是一对逆序元素）。现在我们将它们交换。
	2. 将逆序对的变化分为三部分来考虑：
		1.  **交换的这一对元素$(A_i,A_j)$本身：**
		    *   交换前：$A_i$在$A_j$前面且$A_i>A_j$，这贡献了**1**个逆序对。
		    *   交换后：$A_j$变到了$A_i$的前面，因为$A_j<A_i$，变成了顺序，这不再是逆序对。
		    *   **变化：** 逆序对数量**减少1**。
		2.  **序列中在$i$之前和$j$之后的其他元素：**
		    *   这些元素与$A_i$、$A_j$的相对位置没有改变，因此它们与$A_i$、$A_j$构成的逆序对数量**不变**。
		3.  **序列中在$i$和$j$中间的元素（设为$A_k$，其中$i<k<j$）：**
		    *   设交换前的值为$X=A_i$，$Y=A_j$，已知$X>Y$。
		    *   对于中间的任意元素$A_k$：
		        *   如果$A_k<Y$：交换前后$A_k$都小于这两个数，相对逆序关系不变（例如：$X, A_k$是逆序，交换后$A_k, X$仍是逆序；$A_k, Y$非逆序，交换后$Y, A_k$仍非逆序）。贡献变化为**0**。
		        *   如果$A_k>X$：交换前后$A_k$都大于这两个数，相对逆序关系不变。贡献变化为**0**。
		        *   如果$Y<A_k<X$（即$A_k$的值介于两者之间）：
		            *   **交换前**：$X\dots A_k \dots Y$。$(X,A_k)$是逆序（因为$X>A_k$），$(A_k,Y)$是逆序（因为$A_k>Y$）。贡献为**2**。
		            *   **交换后**：$Y\dots A_k \dots X$。$(Y,A_k)$是顺序（因为$Y<A_k$），$(A_k,X)$是顺序（因为$A_k<X$）。贡献为**0**。
		            *   **变化**：这种情况会导致逆序对数量**减少2**。
		**综合结论：**
		总的[[逆序对]] 变化数量 = (这对元素本身的减少量) + (中间介值元素的减少量) 
		$\Delta = -1 - 2 \times (\text{中间满足}A_j < A_k < A_i\text{的元素个数})$
		
		因为中间满足条件的元素个数非负（$\ge 0$），所以**总变化量必然是一个负奇数**（至少减少1）。因此，逆序对数**必然减少**。

- 衍生 
	- #冒泡排序的交换次数  #交换次数与逆序对的关系（起泡排序） 
	    *   冒泡排序中，只有当相邻两个元素是逆序对时才交换。
	    *   **考点：** 冒泡排序中交换操作执行的总次数 **等于** 原序列的初始逆序对总数。
	    *   **推论：** 交换任意相邻逆序对，逆序数严格减少$1$。
	- #任意交换对奇偶性的影响  
		- **考点：** 只要交换序列中的**任意**两个元素（不管它们是不是逆序对，也不管是否相邻），序列逆序数的**奇偶性（Parity）一定会发生改变**。
	    *   解释：如上文推导，逆序数的变化量是$-1-2k$或者$+1+2k$（如果是顺序对交换），这永远是一个奇数。奇数+奇数=偶数，偶数+奇数=奇数，所以奇偶性必变。
	    *   这在线性代数中行列式的定义（$(-1)^{\tau(\sigma)}$）中非常重要。
	* #逆序对的计算算法  
		* **考点：** 给定一个乱序数组，如何快速求出逆序对的总数？
	    *   暴力法是$O(n^2)$。
	    *   **高效算法：** 利用**归并排序（Merge Sort）**的过程来统计，时间复杂度为$O(n \log n)$。
	- 最小交换次数  
		-  **考点：** 将一个数组变成有序数组（升序），最少需要交换多少次？
	    *   注意：如果允许交换任意两个元素，最少交换次数 $\ne$ 逆序对数。
	    *   公式：最少交换次数 = $n - (\text{置换环的个数})$。
	* #全排列的生成  
		*  **考点：** 邻位对换法生成全排列。通过不断交换相邻元素生成下一个排列，这就利用了 逆序数奇偶性交替变化 的特性


![[Pasted image 20251216060045.png]]
[[Pasted image 20251119211429.png]]
#选择排序vs插入排序 
1. 时间复杂度  （特别是最好情况）
	*   **选择排序**：它的逻辑是“盲目”的。无论数组是否已经有序，它每一轮都要遍历剩下的所有元素去寻找最小值。
	    *   **推导**：即使输入数组是`[1, 2, 3, 4, 5]`，选择排序依然会比较第1个和后面4个，第2个和后面3个……以此类推。
	    *   **公式**：比较次数固定为$\frac{n(n-1)}{2}$。因此，最好、最坏、平均时间复杂度均为$O(n^2)$。
	*   **插入排序**：它的逻辑是“聪明”的。它将当前元素与已排序序列从后向前比较，一旦发现前一个元素比当前元素小（或相等），就停止比较，因为它知道前面的序列已经有序了。
	    *   **推导**：如果输入数组是`[1, 2, 3, 4, 5]`（最好情况），每次内层循环只需要比较1次即可退出。
	    *   **公式**：此时只需要遍历$n$次，时间复杂度降为$O(n)$。
	*   **结论**：**最好情况的复杂度低，为$O(n)$**是插入排序的一大优势。
2. 稳定性
	*   **定义**：如果待排序的序列中存在两个或两个以上具有相同关键字的记录，排序后这些记录的相对次序保持不变，则称该排序算法是稳定的。
	*   **选择排序**：是不稳定的。
	    *   **推导**：选择排序在交换位置时，可能会把前面的元素交换到后面去，从而打乱顺序。
	    *   **例子**：序列`[5, 8, 5, 2, 9]`。第一轮会将最小元素`2`与第一个`5`交换，序列变为`[2, 8, 5, 5, 9]`。原本在前面的`5`跑到了第二个`5`的后面，相对顺序改变。
	*   **插入排序**：是稳定的。
	    *   **推导**：插入排序在向前寻找插入位置时，只有当“前一个元素大于当前元素”时才移动。如果遇到相等的元素，它会插在这个元素后面，不会跨越它，因此保持了相对顺序。
	*   **结论**：**插入排序是稳定的**。
3. #在线排序 
	*   **定义**：算法可以处理不断到来的数据流，即每接收到一个新数据，就能立即将其放入已排序序列的正确位置，而不需要等待所有数据都到齐。
	*   **选择排序**：不支持在线排序。它必须知道整个数组的全貌才能确定谁是当前的“最小值”。
	*   **插入排序**：支持在线排序。它维护一个已排序的子序列，新来一个数据，只需扫描这个子序列并插入即可。
	*   **结论**：**插入排序可以在线排序**。

- 衍生 
	- #插入排序基本有序时的效率   
		- 这是插入排序最核心的考点之一。
			*   **考点**：如果一个数组已经**基本有序**（Almost Sorted），或者数组元素个数很少，应该选择哪种排序算法？
			*   **答案**：**插入排序**。
			*   **原因**：在这种情况下，插入排序的效率极高，接近$O(n)$，甚至优于快速排序（快速排序在小数组或特定有序情况下可能退化）。实际上，许多高级排序库（如C++ STL的std::sort或Java的TimSort）在递归到底层小数组时，都会切换为插入排序。
	-  移动次数与交换次数的对比（选择排序的唯一微弱优势）   
		- 虽然插入排序总体更优，但选择排序并非一无是处。
		*   **考点**：哪种算法的**数据交换（写入）次数**最少？
		*   **解析**：
		    *   **插入排序**：在最坏情况下（逆序），每次插入都需要大量移动元素，平均赋值移动次数是$O(n^2)$级别的。
		    *   **选择排序**：无论什么情况，它每一轮只进行一次交换。总共的交换次数最多是$n-1$次，即$O(n)$。
		*   **结论**：如果 #写操作的代价非常昂贵 （例如在Flash存储器上），选择排序可能比插入排序略有优势。
	- 两者都是原地排序（In-place sort），空间复杂度均为$O(1)$。  

| 特性 | 选择排序 (Selection Sort) | 插入排序 (Insertion Sort) |
| :--- | :--- | :--- |
| **平均复杂度** | $O(n^2)$ | $O(n^2)$ |
| **最好复杂度** | $O(n^2)$ | $O(n)$ |
| **最坏复杂度** | $O(n^2)$ | $O(n^2)$ |
| **稳定性** | 不稳定 | 稳定 |
| **适用场景** | 几乎不推荐（除非写操作极其昂贵） | 数据量小或基本有序 |



![[Pasted image 20251216060051.png]]
[[Pasted image 20251119211436.png]]


题目的核心在于理解 排列， #置换环 以及 排序操作如何影响环的数量   [[置换与置换环]]  
1. **初始状态：**
	待排序数组为$A=\{6,5,4,3,2,1\}$，目标有序数组为$S=\{1,2,3,4,5,6\}$。
	我们需要找出当前数组下标$k$与其元素在有序数组中应在的位置$r(k)$之间的映射关系$k \to r(k)$，从而确定“循环环节”（置换环）  [[插入排序的本质]] 
2. 分析初始环
    *   $A[0]=6$，6在$S$中位于下标5，故$0 \to 5$。$A[5]=1$，1在$S$中位于下标0，故$5 \to 0$。形成环：$(0 \to 5 \to 0)$。
    *   $A[1]=5$，5在$S$中位于下标4，故$1 \to 4$。$A[4]=2$，2在$S$中位于下标1，故$4 \to 1$。形成环：$(1 \to 4 \to 1)$。
    *   $A[2]=4$，4在$S$中位于下标3，故$2 \to 3$。$A[3]=3$，3在$S$中位于下标2，故$3 \to 2$。形成环：$(2 \to 3 \to 2)$。
    *   **初始环的总数：3个。**
3. 插入排序的一趟操作后
	插入排序的第一步是将$A[1]$（即5）插入到有序前缀$A[0]$（即6）之前。实质上是交换了6和5的位置。
	此时数组变为$A'=\{5,6,4,3,2,1\}$。
	
	*   **分析新状态下的环：**
	    *   $A'[0]=5$，应在下标4，故$0 \to 4$。
	    *   $A'[4]=2$，应在下标1，故$4 \to 1$。
	    *   $A'[1]=6$，应在下标5，故$1 \to 5$。
	    *   $A'[5]=1$，应在下标0，故$5 \to 0$。
	    *   形成了一个大环：$(0 \to 4 \to 1 \to 5 \to 0)$。
	    *   剩下的$A'[2]$和$A'[3]$没有变动，仍构成环：$(2 \to 3 \to 2)$。
	    *   **现在的环的总数：2个。**
	
	**结论：**
	环的数量从3个变成了2个，**数量减少了**。因此，题目中“亦不致减少”的说法是错误的。

- 衍生 
	- 最少交换次数
	- **问题：** 给定一个乱序数组，每次只能交换任意两个元素，最少需要多少次交换才能使其有序？
		*   **公式：** 最少交换次数$S = n - k$。
		    *   其中$n$是数组长度，$k$是数组中**置换环（Cycle）的个数**。
		*   **原理：** 排序的最终目标是有$n$个自环（即$k=n$）。每次交换如果发生在同一个环内，环数$+1$。为了最快达到$n$个环，我们需要每次交换都让环数$+1$。因此需要的步数是$n-k$。
	- 逆序对与 冒泡/插入排序  
		- **区别：** 题目中的“循环环节”与“逆序对”是两个不同的概念。
		*   **考点：** 插入排序的时间复杂度直接取决于数组中**逆序对**的数量。
		    *   每次交换相邻元素，逆序对数量严格减1。
		    *   但“循环环节”的数量不一定单调变化。
	- 选择排序与环的关系  
		- **问题：** 选择排序（Selection Sort）的最少交换次数是多少？
		*   **分析：** 选择排序每轮固定一个元素到位。如果运气好，涉及的交换正好切分了环。但在最坏情况下，选择排序的交换策略并不一定遵循“每次都在环内交换以增加环数”的最优策略，但在统计上，它最多进行$n-1$次交换。 
	* #期望环数  
		* **问题：** 一个随机排列的长度为$n$的数组，其包含的置换环个数的期望是多少？
		*   **公式：** 期望值为[[调和级数（发散）]] $H_n = \sum_{i=1}^{n} \frac{1}{i} \approx \ln n$。
		*   这在分析某些算法（如快速排序的某些变种或寻找极值的算法）的平均复杂度时会用到。



![[Pasted image 20251216060057.png]]
[[Pasted image 20251119212435.png]]

1. #快速排序的核心思想 是 #分治法     [[快速排序]] 
	1. 其性能取决于 基准值 的选择以及划分是否平衡
2.  **最好情况（Best Case）：**
    每次选取的基准值都能将数组**均匀地**划分成两个长度相等的子数组（即每次都五五开）。
    *   此时递归树的深度为$\log_2n$。
    *   每一层处理所有元素的时间是$O(n)$。
    *   所以总时间复杂度为$O(n)\times\log_2n$，即$O(n\log n)$。
    *   **结论：题目中说的“最好时间复杂度是$O(n\lg n)$”是正确的。
3. 平均情况
	1. 在随机输入数组的情况下，基准值的选择虽然不能保证每次都完美平分，但在统计学上，划分出来的子数组长度通常是成比例的（例如1:9或1:3）。
	    *   数学证明表明，即使是不平衡的划分，递归树的平均深度仍然保持在$O(\log n)$级别。
	    *   因此，平均时间复杂度依然是$O(n\log n)$。
	    *   **结论：题目中说的“平均时间复杂度为$O(n\lg n)$”是正确的。
4. 综上所述，题目表述完全正确，因此选$\sqrt{}$  
- 衍生考点（必看） 
	- 最坏时间复杂度（高频考点）  
		-   **问题：** 快速排序最坏情况是什么？复杂度是多少？
			*   **场景：** 当数组已经是**有序**（正序或逆序）状态，且每次总是选择第一个或最后一个元素作为基准值时。
			*   **分析：** 此时划分极其不平衡（1个元素 vs $n-1$个元素），递归树退化成链表，深度变为$n$。
			*   **公式：** $T(n)=T(n-1)+T(0)+O(n)$，这是一个等差数列求和。
			*   **结果：** 最坏时间复杂度为$O(n^2)$。
			*   **考点提示：** 如果题目问“快速排序在任何情况下都优于冒泡排序吗？”，答案是否定的，因为最坏情况下快排也是$O(n^2)$
	- 空间复杂度  
		- 快速排序虽然是原地排序（In-place），但需要使用递归栈空间。
			*   **最好/平均情况：** 递归树深度为$\log n$，空间复杂度为$O(\log n)$。
			*   **最坏情况：** 递归树退化，深度为$n$，空间复杂度为$O(n)$。
	- 稳定性
		- **结论：** 快速排序是**不稳定**的排序算法。
		*   **原因：** 在交换元素的过程中，可能会改变相同元素的相对位置。例如序列`5, 3, 5, 1`，以第一个`5`为基准，可能导致两个`5`的顺序交换。
	- 优化方法（进阶考点）  [[快速排序的优化]]
		- 为了避免最坏情况$O(n^2)$的发生，通常会考察如何优化基准值的选择：
			*   **三数取中法（Median-of-Three）：** 取头、尾、中三个数的中位数作为基准。
			*   **随机选取法：** 随机选择一个元素作为基准。

| 维度          | 说明           | 复杂度表示              |
| :---------- | :----------- | :----------------- |
| **平均时间复杂度** | 绝大多数情况       | $O(n\log n)$       |
| **最好时间复杂度** | 每次划分都很均匀     | $O(n\log n)$       |
| **最坏时间复杂度** | 数组已有序，基准选偏   | $O(n^2)$           |
| **空间复杂度**   | 主要是递归栈的开销    | $O(\log n)$~$O(n)$ |
| **稳定性**     | 相同元素相对位置可能改变 | **不稳定**            |




![[Pasted image 20251216060111.png]]
[[Pasted image 20251119212608.png]]

- 找出一组数据中的前$10\%$并不需要对所有数据进行完全排序
	- 完全排序的时间复杂度下界是$O(n\log n)$，但如果只是为了找到特定的元素或者划分数据，时间复杂度可以优化到线性时间$O(n)$  
1. 第一步：找到第$k$大的元素   
	- 假设数据量为$n$，前$10\%$意味着我们需要找到第$k$大的元素，其中$k=0.1n$。  [[快速选择算法]] 
		我们不需要对数组排序，而是使用 #快速选择算法   或  #BFPRT算法   [[BFPRT 算法 (中位数的中位数算法)]] 
	- 通过Partition，我们可以确定一个基准值在数组中的最终位置。如果这个位置正好是$k$，我们就找到了；如果不是，我们只需要在基准值的一侧继续查找。 
	- 这一步的平均时间复杂度是$O(n)$  
2. 第二步：根据该元素划分数据  
	1. 一旦我们找到了第$k$大的这个“分界线”元素，我们只需要再遍历一次数组，将所有比它大的元素选出来即可。
	*   遍历数组的时间复杂度是$O(n)$。
		**总时间复杂度：**
		$T(n) = O(n) + O(n) = O(n)$
		所以，可以在线性时间内确定无序数据中的前$10\%$
- 衍生 
	- 不同算法解决 Top-K 的复杂度对比  
		- 题目可能会换不同的条件，让你选择最优算法：
			1.  **全排序法**：先排序再取前$k$个。
			    *   时间复杂度：$O(n\log n)$。
			    *   适用场景：需要输出有序的前$k$个数据时。
			2.  **堆排序法 (Heap)**：维护一个大小为$k$的小顶堆。
			    *   时间复杂度：$O(n\log k)$。
			    *   适用场景：$n$非常大（海量数据），内存无法一次装下所有数据，或者$k$远小于$n$时。
			3.  **快速选择法**：本题的方法。
			    *   时间复杂度：$O(n)$。
			    *   适用场景：内存足够，且不需要前$k$个数据内部有序，只需要找出它们。
	- 基于比较的排序 #算法下界  
		- **考点**：只要是基于“比较”的**完全排序**，其时间复杂度不可能优于$O(n\log n)$。
		*   **陷阱**：本题之所以能做到$O(n)$，是因为它**不是排序**，而是**查找/选择**。如果题目改为“在$O(n)$内对无序数据的前$10\%$进行**排序**”，那么答案就是错误的（除非数据满足基数排序等非比较排序的条件）。 
	* 空间复杂度
		*   快速选择算法通常需要递归实现，空间复杂度为$O(\log n)$（栈空间）。
		*   如果题目问及“空间复杂度为$O(1)$”，则需要使用非递归（迭代）的方式实现Partition。
-  总结
	这道题的关键在于区分“**排序整个数组**”和“**找出部分数据**”。
	*   排序整个数组：$O(n\log n)$
	*   找出第$k$大元素：$O(n)$
	*   找出前$k$大元素（不要求内部有序）：$O(n)$
	

![[Pasted image 20251216060118.png]]
[[Pasted image 20251119212613.png]]
- 理解为什么最后一步插入排序的时间是$O(nm)$，我们需要分析 QuickSort 递归停止后的数组状态，它是工业界标准库（如 C++ STL 的 `std::sort`）实现中的一个核心优化思路
1. 考察的是 #高级排序算法的优化策略 以及**时间复杂度分析**   
2. 第一步：理解 QuickSort 停止后的状态    #快速排序 
	1. QuickSort 的核心逻辑是 Partition（划分）。每次划分选定一个 pivot（枢轴），将小于 pivot 的放左边，大于 pivot 的放右边
		1. 题目中说：“子序列规模缩减至$m$以下之后，不再继续递归”。
			这意味着：
			1.  **宏观有序（段间有序）：** 整个大数组被划分成了若干个小的“块”或“段”。由于 QuickSort 的性质，左边“块”里的所有元素一定小于等于右边“块”里的所有元素。
			2.  **微观无序（段内无序）：** 每个“块”内部的大小不超过$m$，且内部是未排序的（因为递归在变得有序之前就停止了）。
3. 第二步：计算[[插入排序的性质]] 的代价  
	1. 对整个数组运行 Insertion Sort。由于“段间有序”的特性，插入排序在处理某一个元素时，绝不会跨越它所属的“块”去寻找插入位置（因为它所属块左边的所有元素都比它小，它已经是“大于左边所有内容”的状态了）  
	2. 因此，对整个长为$n$的数组做插入排序，实际上等价于分别对每一个长度为$m$的小块做插入排序 
		*   **块的数量：** 总长度是$n$，每个块大小约是$m$，所以大约有$n/m$个块。
		*   **单块排序时间：** 对一个长度为$m$的数组进行插入排序，最坏时间复杂度是$O(m^2)$。
		*   **总时间复杂度：**
			$总时间 = 块的数量 \times 单块最坏时间$
		    $TotalTime = \frac{n}{m} \times O(m^2) = O(nm)$
4. 所以，Insertion Sort 需要花费的时间是$O(nm)$  
5. #混合算法 [[混合算法]] 


- 衍生 
	- 为什么要这么做？（优化的意义）  
		- **问题**：既然快速排序平均是$O(n \log n)$，为什么还要在最后用$O(n^2)$的插入排序？
		*   **解答**：虽然渐进复杂度上$O(nm)$看似比$O(n \log n)$（当$m$较大时）差，但实际上$m$通常取一个很小的常数（如 5~20）。此时$O(nm)$退化为$O(n)$。
		    *   对于小数组，快速排序的递归调用（压栈、出栈）开销占比很大。
		    *   插入排序指令少，局部性好（Cache友好）。
		    *   这种策略消除了递归树底层的巨大开销，因为递归树的底层节点数占总节点数的一半以上。
	- $m$ 的取值对复杂度的影响  
		- **问题**：如果$m$取值很大，比如$m = n/2$，复杂度是多少？
		*   **解答**：代入公式$O(nm)$。如果$m=n$，就是直接对原数组做插入排序，复杂度为$O(n^2)$。如果$m=1$，就是标准的快速排序（最后一步插入排序代价为$O(n)$），总复杂度仍由快排主导为$O(n \log n)$。这个优化主要利用了$m$为常数时的优势。  
	* 从“[[逆序对]]”角度分析   
		* **问题**：如何用逆序对（Inversion）的概念解释这个复杂度？
		*   **解答**：插入排序的时间复杂度与数组中的**逆序对数量**成正比。
		    *   在一个大小为$m$的块中，最多有$m(m-1)/2$个逆序对，即$O(m^2)$个。
		    *   全数组有$n/m$个这样的块。
		    *   因为块与块之间是有序的，所以块之间不存在逆序对。
		    *   总逆序对数量最大为$\frac{n}{m} \times \frac{m^2}{2} = O(nm)$。
		    *   因此运行时间为$O(nm)$。
	- 其他混合排序算法  
		- **关联**：C++ STL 的 `std::sort` 不仅用了上述优化，还防止了快速排序退化为$O(n^2)$。
		*   **机制**：它使用 **IntroSort**（内省排序）。开始用 QuickSort，如果递归深度超过$2 \log n$（说明快排选轴很烂，可能退化），则转而使用 **HeapSort (堆排序)**，保证最坏情况也是$O(n \log n)$。最后再结合本题提到的插入排序处理小区间。 

![[Pasted image 20251216060129.png]]
[[Pasted image 20251119212618.png]]
[[希尔排序]] 

- 根据计算机科学经典结论，该特定序列突破了希尔原始序列$O(n^2)$的限制，达到了$O(n^{3/2})$。  

- 衍生 
	- 希尔原始增量序列
		- **序列形式**：每次将步长折半，即$h_k=\lfloor n/2^k \rfloor$（例如：$n/2, n/4, \dots, 1$）。
		*   **缺陷**：奇数位置的元素和偶数位置的元素直到最后一步$h=1$时才会有机会进行比较。
		*   **复杂度**：最坏情况时间复杂度为$O(n^2)$。
		    *   *考点预警*：如果题目换成“采用序列$n/2, n/4...$”，那么$O(n^{3/2})$的说法就是错误的
	- 算法的稳定性  
		- **结论**：希尔排序是**不稳定**的排序算法。
		*   **原因**：相同的元素可能会因为被分在不同的“增量组”中进行排序，导致相对位置发生改变。
		    *   *例子*：序列$\{3, 2, 2\}$，如果第一轮步长导致第一个$2$移动到了第二个$2$的后面，稳定性就被破坏了。
	* 空间复杂度
		* 希尔排序是原地排序算法（In-place sorting）。
		*   **结论**：空间复杂度为$O(1)$。  
	* 其他著名增量序列（高阶考点）
		* 除了Hibbard序列，可能会考到Sedgewick序列：
			*   **形式**：$\{1, 5, 19, 41, 109, \dots\}$（基于$9\cdot4^k - 9\cdot2^k + 1$等公式）。
			*   **复杂度**：最坏时间复杂度可以优化到$O(n^{4/3})$。
	- 最后一趟排序的特性  
		- 无论选择什么增量序列，希尔排序的最后一趟增量必须是$1$。
		*   此时的希尔排序等同于**直接插入排序**，但由于数据已经基本有序，效率会非常高。

![[Pasted image 20251216060136.png]]
[[Pasted image 20251119212625.png]]

-    #插入排序  的工作原理类似于我们打扑克牌时整理手牌。我们一张张抓牌，将新抓到的牌插入到左手已经排好序的牌堆中的正确位置。
    在计算机算法中，它只需要**一个**额外的临时变量（通常用来存储当前待插入的元素，记为 key 或 temp）来进行比较和移位操作。

**结论：**
由于插入排序在排序过程中，无论数据量$n$有多大，它始终只需要占用**固定大小**的额外空间（几个变量），其辅助空间复杂度为$O(1)$。符合“ #就地算法 ”的定义，因此题目表述正确。  

- 衍生 
	- 排序算法的“稳定性”与“就地性”归类
		这通常是选择题的高频考点。你需要记住常见排序算法的属性：
		*   **就地排序 ($O(1)$空间)：** 插入排序、选择排序、冒泡排序、希尔排序、堆排序。
		*   **非就地排序 ($O(n)$或$O(\log n)$空间)：** 归并排序（需要$O(n)$辅助数组）、快速排序（递归栈需要$O(\log n)$到$O(n)$空间）。
	* 插入排序的“最好情况”  
		* **问：** 在什么情况下，插入排序的效率最高？
		- **答：** 当数据**基本有序**（Nearly Sorted）或者数据量**较小**时。
			此时插入排序的效率远高于冒泡排序和选择排序，甚至在数据极少时优于快速排序。这也是为什么高级排序算法（如 std::sort 或 Arrays.sort）在递归到底层数据量很小时，会切换为插入排序的原因。
	- 比较次数与移动次数   
		- **问：** 插入排序在最好情况下的比较次数是多少？
		    **答：** $n-1$次（每个元素只和前一个比一次，发现比它大就不动了）。
		*   **问：** 简单选择排序 (Selection Sort) 和插入排序的区别？
		    **答：** 简单选择排序无论数据是否有序，比较次数恒定为$O(n^2)$；而插入排序对有序数据敏感，效率可提升至$O(n)$。但选择排序的移动次数很少（最多$n-1$次交换），而插入排序在最坏情况下移动次数是$O(n^2)$。
	- 希尔排序的关联
		**问：** 希尔排序与插入排序的关系？
		**答：** 希尔排序是插入排序的优化版本（也叫缩小增量排序）。它通过将数组分组进行插入排序，利用了插入排序在“基本有序”时效率极高的特点，突破了$O(n^2)$的时间复杂度限制。


![[Pasted image 20251216060142.png]] 
[[Pasted image 20251119212630.png]]
#稳定排序算法 
- 在计算机科学中，**排序算法的稳定性**（Stability）的定义正是：如果待排序的序列中存在两个或两个以上具有相同关键字的记录$R_i$和$R_j$，且在排序前$R_i$在$R_j$的前面（即$i<j$），如果在排序后$R_i$依然在$R_j$的前面，则称这种排序算法是稳定的。


- **记忆口诀提示**：
	*   不稳定的算法通常涉及“跳跃式”的交换（如快速排序、堆排序）或长距离的移动（如希尔排序、选择排序）。
	*   稳定的算法通常是相邻交换或有序合并

- 衍生 
	- 时空复杂度与稳定性的综合考察
		题目可能会问：“在$O(n\log n)$时间复杂度下，且是稳定的排序算法是什么？”
		*   答案通常是：**归并排序**（Merge Sort）。
		*   注意：虽然堆排序和快速排序也是$O(n\log n)$，但它们通常是不稳定的。



![[Pasted image 20251216060152.png]]
[[Pasted image 20251119212636.png]]
- **起泡排序的空间需求：**
	起泡排序在对向量（或数组）进行排序时，主要的操作是比较相邻元素并进行交换。
	*   比较操作不需要额外空间。
	*   交换操作通常只需要一个临时的变量（例如 `temp`）来暂存数据，即 `temp = a[i]; a[i] = a[j]; a[j] = temp;`。
	*   无论待排序的向量长度$n$是多少，所需的辅助空间始终是固定的几个变量（循环变量$i,j$和交换变量$temp$），与$n$的大小无关。
* 向量（Vector）在数据结构中通常指**顺序存储结构**（如数组）。起泡排序非常适合这种支持随机访问的结构。 

#向量起泡排序 
	 **结论：**
        因为起泡排序的辅助空间复杂度为$O(1)$，符合就地算法的定义。因此，“不是就地算法”这个表述是**错误**的。

- 衍生  
	- 向量（顺序表）与链表的区别 
		- **考点**：如果是链表进行起泡排序，还是就地算法吗？
			*   **解析**：**是**。链表进行起泡排序可以通过交换节点的值或者调整指针来实现，辅助空间依然是常数级$O(1)$，所以依然是就地算法。但链表不支持随机访问，通常不推荐用起泡排序（尽管可行）。




![[Pasted image 20251216060200.png]]
[[Pasted image 20251119212643.png]]

*   **什么是逐个给出？**
    这意味着我们不是一开始就拥有一个完整的、静态的数组，而是一个接一个地接收数据流。每接收到一个新数据，我们都需要将其加入到当前的集合中，并保持集合有序。这种场景在算法领域被称为**在线算法（Online Algorithm）**。

*   **插入排序（Insertion Sort）的机制：**       #在线排序  
    插入排序的基本思想正是：维护一个**已排序的序列**，对于未排序数据（或者新来的数据），在已排序序列中从后向前扫描，找到相应位置并插入。
    *   当数据逐个到达时，插入排序正好对应其逻辑：当前手里有$k$个已排好序的数，第$k+1$个数来了，直接把它插到正确位置，变成$k+1$个有序的数。这一过程不需要等待所有数据到齐，因此它非常适合“在线”场景。

*   **为什么不选其他选项？**
    *   **(B) 选择排序（Selection Sort）：** 需要遍历**整个**剩余的未排序部分，找出最小值放到已排序部分的末尾。如果数据是逐个来的，你无法预知后面是否还有比当前更小的值，因此无法确定谁是真正的最小值，必须等所有数据到齐（离线）才能开始排序。
    *   **(C) 归并排序（Merge Sort）：** 典型的分治算法，通常需要知道数组的整体边界以便进行二分切割（Divide），然后再合并（Conquer）。虽然可以修改为流式处理，但标准实现是离线的。
    *   **(D) 快速排序（Quick Sort）：** 也是分治算法，核心是选取基准值（Pivot）并将数组分为两部分。如果不知道数据的整体情况，很难选取合适的基准值进行有效划分，通常需要全量数据。

- **结论：** 只有插入排序天然符合“来一个，排一个”的在线处理逻辑。
 
- 衍生 
	- #插入vs选择排序  
		- **区别：** 选择排序无论数据是否有序，时间复杂度永远是$O(n^2)$，因为它必须扫描完剩余部分。而插入排序在数据有序时可以提前结束内层循环。
		*   **比较次数与移动次数：** 选择排序的**移动次数**最少（最多$n-1$次交换），但比较次数固定为$n(n-1)/2$。插入排序的移动次数取决于数据的有序程度。 
	- 稳定性判断
	*   题目可能会给出一组数据，问哪种排序是稳定的？
		*   #记忆口诀 ： “心情不稳定，快（快速）些（希尔）选（选择）一堆（堆排序）朋友”。即：快速排序、希尔排序、选择排序、堆排序是**不稳定**的。而插入排序、冒泡排序、归并排序是**稳定**的。
	- #链表排序 
		*   **问题：** 如果数据存储在链表中，哪种排序比较自然？
		*   **答案：** 插入排序非常适合链表，因为链表插入操作不需要像数组那样移动后续元素，只需要改变指针指向，避免了大量数据移动的开销（虽然查找插入位置的时间复杂度仍是$O(n^2)$）。



![[Pasted image 20251216060208.png]]
[[Pasted image 20251119212649.png]]

这道题的核心在于考查 希尔排序中不同 增量序列对算法性能及执行过程的影响。 #希尔排序增量序列的选择 
- 题目问的是哪种增量序列需要做 $\Omega(\log^2 n)$ 趟排序。这里的“一趟排序”指的是针对增量序列中的某一个特定增量 $h$ 进行一次分组插入排序。因此，需要的排序趟数等于增量序列中不大于 $n$ 的元素的个数
1. **(A) $\{2^p | p \in N\}$**：这是最原始的 #希尔增量序列 （或类似的，$n/2, n/4, \dots$）。
    *   满足 $2^p \le n$ 的 $p$ 的个数约为 $\log_2 n$。
    *   趟数为 $O(\log n)$。
    *   *注：此序列最坏时间复杂度为 $O(n^2)$，因为奇偶位置元素直到最后一步才交互。
2. **(B) $\{2^{p+1} - 1 | p \in N\}$**：这是 #Hibbard增量序列  ($1, 3, 7, 15, \dots$)。
    *   满足 $2^{p+1}-1 \le n$ 的 $p$ 的个数约为 $\log_2 n$。
    *   趟数为 $O(\log n)$。
    *   *注：此序列最坏时间复杂度为 $O(n^{3/2})$。*
3. **(C) $\{2^p \cdot 3^q | p, q \in N\}$**：这是 #Pratt增量序列  ($1, 2, 3, 4, 6, 8, 9, 12, \dots$)。
    *   我们需要计算满足 $2^p \cdot 3^q \le n$ 的非负整数对 $(p, q)$ 的数量。
    *   对不等式两边取对数：$p \ln 2 + q \ln 3 \le \ln n$。
    *   在二维坐标系 $(p, q)$ 中，这是一个由坐标轴和直线围成的三角形区域。
    *   该区域内的整数点数量近似于其面积，即 $\frac{1}{2} \cdot \frac{\ln n}{\ln 2} \cdot \frac{\ln n}{\ln 3} \approx \frac{1}{2 \ln 2 \ln 3} (\ln n)^2$。
    *   因此，序列长度（即排序趟数）的数量级为 $\Theta(\log^2 n)$。符合题目中的 $\Omega(\log^2 n)$。
    *   *注：使用此序列的希尔排序最坏时间复杂度为 $O(n \log^2 n)$，是目前已知渐进时间复杂度最好的希尔排序，但由于趟数太多，在 $n$ 较小时实际运行速度可能不如 Hibbard 或 Sedgewick 序列。
4.  (D) #Sedgewick序列  （由两个交错的表达式组成）。
    *   这些表达式本质上也是指数增长的（约为 $4^p$ 级别）。
    *   满足条件的元素个数同样约为 $\log n$ 级别。
    *   趟数为 $O(\log n)$。
    *   *注：最坏时间复杂度为 $O(n^{4/3})$。

- **结论：** 只有选项 (C) 的 Pratt 序列，其增量个数（即排序趟数）达到了 $\log^2 n$ 的级别。  

- 衍生 
	-  **原地排序**：
	    *   希尔排序的空间复杂度是 $O(1)$，属于原地排序。


![[Pasted image 20251216060215.png]]
[[Pasted image 20251119212657.png]]

#基数排序 #LSD最低位优先 基数排序的正确性严格依赖于底层排序算法的稳定性  
1. 什么是基数排序的逻辑？     [[基数排序]]
	1. 基数排序通常是从低位到高位进行多轮排序。
		假设我们要排序 $23$ 和 $21$：
		1.  **第一轮（按个位排序）：** 比较 $3$ 和 $1$。排序后，$21$ 在 $23$ 前面。
		    *   此时序列状态：$21, 23$。（也就是利用个位的大小，确定了暂时的顺序）。
		2.  **第二轮（按十位排序）：** 比较 $2$ 和 $2$。
		    *   此时十位数字相同。**关键点来了**：既然十位相同，谁排在前面应该由谁决定？应该由**低位（个位）**决定。
		    *   我们在第一轮已经根据个位把 $21$ 排在 $23$ 前面了。在第二轮中，面对相等的十位数字，排序算法必须**保持**第一轮排好的相对位置不变。
		    *   这就是**稳定性**的定义：如果两个元素键值相同，它们在排序后的相对位置应与排序前保持一致。
	* **总结推导：** 只有当每一步排序都是稳定的，才能保证“高位数字相同时，低位数字小的排在前面”，从而保证最终结果有序。  

- 衍生  
	- 基数排序的时间复杂度是 $O(d(n+r))$。
		*   **陷阱：** 如果 $d$（位数）很大，或者 $r$（基数）很大，基数排序的效率可能不如 $O(n\log n)$ 的比较排序（如快速排序）。  
	* 为什么LSD比MSD更常用？
		*  LSD 不需要递归，实现简单，且由于从低位到高位处理，容易利用计算机的缓存特性。MSD 需要递归地对子桶进行排序，管理开销较大。
	* 如果题目让你分析性能，你可能需要写出如下形式：
		若对 $N$ 个整数进行排序，范围在 $0$ 到 $R^d-1$ 之间（即 $d$ 位 $R$ 进制数），则：
		*   时间复杂度：$T(n)=O(d \cdot (n+R))$
		*   空间复杂度：$S(n)=O(n+R)$
		

![[Pasted image 20251216060223.png]]
[[Pasted image 20251119212704.png]]

#基数排序 是指 #LSD ，即从低位到高位进行排序

1.  **基本流程**：基数排序将整数按位数切割成不同的数字，然后按每个位数分别比较。通常是从最低位（个位）开始，一直排到最高位。
2.  **依赖关系**：当我们进行第$i$位的排序时，实际上是在“合并”第$i-1$位的排序结果。
3.  **关键点**：如果在比较第$i$位时，两个数字的第$i$位数值 **相同**，那么这两个数字谁排在前面，**必须取决于它们在第$i-1$位排序时的相对顺序**。
4.  **不稳定的后果**：如果底层算法是“不稳定”的，那么当第$i$位数值相同时，它可能会打乱原本由第$i-1$位确定的顺序。这就意味着之前几轮排序所做的工作全部白费了，导致最终结果错误。
**举例说明：**
假设我们要对数组 $A=[15, 25, 12]$ 进行排序。

*   **第一步：按个位排序（个位分别是 5, 5, 2）**
    *   $12$ (个位2) 排第一。
    *   $15$ 和 $25$ 个位都是5。
    *   **如果稳定**：保持原序，$15$ 在 $25$ 前。序列变为：$[12, 15, 25]$。
*   **第二步：按十位排序（十位分别是 1, 1, 2）**
    *   现在的输入是 $[12, 15, 25]$。
    *   $12$ (十位1) 和 $15$ (十位1) 的十位数字相同。
    *   **这里是关键**：因为个位排序时，$12$ 已经在 $15$ 前面（或者在实际数值逻辑中12小于15），我们需要保持这个相对位置。
    *   **如果底层算法不稳定**：虽然 $12$ 和 $15$ 的十位都是1，算法可能会随意交换它们的位置，变成 $[15, 12, \dots]$。
    *   最终结果如果是 $[15, 12, 25]$，显然排序是错误的。

**结论**：为了保证低位的排序成果在高位排序中不丢失，底层排序算法必须是 **稳定** 的。

- 衍生 
	- 应用场景
		*   基数排序适合用于：
		    1.  数据量$n$很大，但位数$d$较小的情况。
		    2.  固定长度的字符串排序。
		    3.  IP地址排序。
	- 底层算法的选择
		题目可能会问：“以下哪种算法**不适合**作为基数排序的底层算法？”
		*   **适合**：计数排序（稳定）、冒泡排序（稳定）、插入排序（稳定）。
		*   **不适合**：快速排序（不稳定）、堆排序（不稳定）、希尔排序（不稳定）。如果强行使用这些算法，基数排序的逻辑就会失效


![[Pasted image 20251216060230.png]]
[[Pasted image 20251119212710.png]]



[[排序可能会考但没考的考点]] 



![[Pasted image 20251119212716.png]]



![[Pasted image 20251119212722.png]]



![[Pasted image 20251119212730.png]]![[Pasted image 20251119212742.png]]