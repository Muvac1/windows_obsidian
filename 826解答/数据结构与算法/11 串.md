[[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=43&rect=26,356,575,803|826历年真题解析-数据结构篇（包括算法题）-12.15, p.43]]
![[Pasted image 20251216022741.png]]
- 这道题目的核心在于比较 #KMP算法 与 #朴素模式匹配算法（BF算法/蛮力算法） 在特定条件下的 平均时间复杂度   
1. 结论基于概率论的分析。虽然BF算法的最坏时间复杂度是$O(n\times m)$，但在“字符集各字符出现概率相同”这一前提下，其**平均时间复杂度**会退化为线性，即$O(n+m)$，从而与[[KMP算法]]相当   
	1. **假设前提**：
	    设字符集规模为$s$（例如字母表有26个字母，则$s=26$）。假设文本串$T$和模式串$P$中的字符都是随机均匀出现的。
	2.  **单次比较的概率**：
	    *   任意两个字符相等的概率为$1/s$（成功）。
	    *   任意两个字符不相等的概率为$1-1/s=(s-1)/s$（失败）。
	3.  特定位置的比较次数分析
		当[[BF算法]] 在文本串的某一个位置开始匹配时，需要进行多少次字符比较才能确定是否匹配？这是一个几何分布问题。
		*   **比较1次就发现不匹配（第1次失败）**：概率为$(s-1)/s$。
		*   **比较2次才发现不匹配（第1次成功，第2次失败）**：概率为$(1/s)\cdot(s-1)/s$。
		*   **比较k次才发现不匹配（前k-1次成功，第k次失败）**：概率为$(1/s)^{k-1}\cdot(s-1)/s$。
	4. 期望比较次数计算
		1. 我们在文本串的每一个位置，期望进行的比较次数$E$是所有可能比较次数的加权平均：
			1. $E=\sum_{k=1}^{m}k\cdot P(X=k)=\sum_{k=1}^{m}k\cdot(s-1)/s^k$
		2. 利用无穷级数求和公式，上式可以放缩并计算为：
		    $E<(s-1)\cdot\sum_{k=1}^{\infty}\frac{k}{s^k}=\frac{s}{s-1}$ 
		3. 由于$s\ge2$（字符集至少有2个字符），所以$E\le2$。
		    这意味着：在平均情况下，BF算法在文本串的每一个位置，平均只需要比较不到2次就能确定是否匹配（通常是第1个字符就不匹配了）
	5. 结论  
		1. 文本串长度为$n$，每个位置平均比较次数是常数$O(1)$，所以BF算法的总平均时间复杂度为$O(n)$。这与KMP算法的$O(n)$（或准确说是$O(n+m)$）属于同一个数量级。因此，题目说两者“渐进时间复杂度接近”是正确的  
2. #字符集规模对算法的影响（KMP-BF）     
	1. 当字符集规模$s$较大时，单次比较成功的概率$1/s$很低，失配的概率很高。BF算法往往比一下就发现不匹配了，因此在字符集很大时（如ASCII码），BF算法实际运行速度往往比KMP还快（因为KMP有预处理开销）
- 衍生 
	- KMP `next` 数组的计算  
		-  题目会给出一个具体的模式串（例如 "abaabcac"），让你手算其`next`数组或`nextval`数组的值。
	    *   **考点**：理解最长相等前后缀的长度计算。 
	- #KMPvsBF的场景判断   
		-   **问**：什么时候BF比KMP差得最多？
		    *   **答**：当字符集很小（如二进制串$01$串）且模式串和主串有大量重复子结构时。
		    *   **问**：什么时候选择BM（Boyer-Moore）算法？ #BM算法  
		    *   **答**：当字符集较大且模式串较长时，BM算法利用“坏字符”和“好后缀”规则可以实现大幅度跳跃，$O(n/m)$的效率比KMP更高（如图中绿色曲线所示）。
	- 时间复杂度的具体数学表达
		- 可能会考察BF算法在最好情况、最坏情况和平均情况下的复杂度分别是多少。
		    *   **最好**：$O(n)$（每次都在第一个字符失配，或者直接匹配成功）。
		    *   **最坏**：$O(n\times m)$。
	- 代码填空  
		- 给出 #KMP算法的核心代码 （`i`不回退，`j`回退到`next[j]`），让你填补缺失的逻辑判断，例如`if (j == -1 || T[i] == P[j])`。
- 这道题实际上是在纠正一个刻板印象：认为“BF一定慢，KMP一定快”。实际上在随机文本（平均情况）下，两者效率是同一个量级的。理解这一点需要掌握**期望**和**概率**的基本计算。



![[Pasted image 20251216022805.png]]
[[Pasted image 20251119210916.png]]


- 一个非常经典的《数据结构》考研题目。这道判断题的核心在于考察你对 #KMP算法时间复杂度 本质的理解，以及**优化（nextval）与未优化（next）的区别**  
1. 这道题的答案之所以是“正确”的，是因为 #改进next数组 （即求nextval数组）只是减少了匹配失败后的比较次数（优化了常数项），并没有改变算法算法的时间复杂度量级。
2. 具体推导逻辑如下： [[KMP算法改进nextval数组]]
	*   **主串指针不回溯：** KMP算法的核心优势在于，在匹配过程中，主串（Text）的指针$i$是永远不回溯的，它只是一直向前移动，直到扫描完主串。这部分的时间复杂度是$O(n)$，其中$n$是主串长度。
	*   **模式串指针的回跳次数受限：** 当发生失配时，模式串（Pattern）的指针$j$会根据`next`数组向回跳。虽然$j$会回跳，但每一次匹配成功，$j$和$i$都会同时加1。因为$i$最多增加$n$次，所以$j$增加的次数也不超过$n$次。既然$j$增加的次数有上限，那么它减小（回跳）的总次数也是有上限的（不可能回跳到负无穷）。通过摊还分析可知，匹配过程的总比较次数是线性的。
	*   **预处理的时间：** 计算未改进的`next`数组，其本身其实就是模式串自己对自己进行一次KMP匹配，时间复杂度是$O(m)$，其中$m$是模式串长度。
	*   **结论：** 总时间复杂度 = 预处理时间 + 匹配时间 = $O(m)+O(n)=O(n+m)$。无论是否使用改进版的`next`数组，这个渐进时间复杂度的上限是不变的。
3.  [[KMP算法]] 是一种改进的字符串匹配算法，主要用于在一个文本串$S$中查找模式串$P$的位置。  
- 衍生  
	- 手算 Next 数组与 Nextval 数组（高频）  
		- 这是最常见的题型。题目会给出一个具体的字符串（例如："ababaa"），让你写出它的`next`值或`nextval`值。
			*   **注意下标：** 题目中数组是从$0$开始还是从$1$开始？这直接影响答案。
			    *   若从$1$开始，通常`next[1]=0`。
			    *   若从$0$开始，通常`next[0]=-1`
	- #朴素模式匹配vsKMP  
		- **朴素算法（Brute Force）：** 主串指针需要回溯。最坏时间复杂度为$O(n\times m)$。
		*   **KMP算法：** 主串指针不回溯。最坏时间复杂度为$O(n+m)$。
		*   **题目：** 可能会问“在最坏情况下，KMP比朴素算法快多少？”或者判断“KMP总是优于朴素算法”（不一定，对于短串或字符集很大的随机串，朴素算法可能更快，但渐进复杂度KMP更优）。
	- 空间复杂度  
		- KMP算法需要一个辅助数组来存储`next`值，因此其空间复杂度为$O(m)$。
	- Next 数组的定义理解  
		- 题目可能给出一段描述，问你`next[j]`的含义。答案通常涉及“子串$P[0...j-1]$的最长相等前后缀长度”  
	- 代码填空
		- 考察 #KMP算法代码中的关键逻辑 ，例如求`next`数组时的回溯逻辑：`j = next[j]`
- 改进的 next 数组（nextval）是为了解决特殊情况下的重复比较问题，提升执行效率，但并没有突破$O(n+m)$这个量级限制  


![[Pasted image 20251216022812.png]]
[[Pasted image 20251119210952.png]]

- 推导过程
	KMP算法的核心优势在于利用模式串本身的结构信息（即最长相等前后缀），在匹配失败时，主串指针$i$不需要回溯，只需移动模式串指针$j$。
	无论使用的是**未改进的**$next$数组还是**改进后的**$nextval$数组，KMP算法的时间复杂度分析如下：
	1.  **求$next$数组**：对长度为$m$的模式串进行预处理，时间复杂度为$O(m)$。
	2.  **匹配过程**：主串指针$i$扫描整个长度为$n$的主串，不回溯；模式串指针$j$虽然会根据$next$数组回退，但在整个匹配过程中，其前移和回退的总次数与$n$成线性关系，时间复杂度为$O(n)$。
	
	因此，未改进$next$表的KMP算法总时间复杂度依然是$O(n+m)$，属于线性时间复杂度。改进后的$nextval$数组只是优化了某些特定情况下的比较次数（减少了常数项的开销），并没有改变算法渐进时间复杂度的量级。
- 衍生  
	- $next$数组的手工计算（高频）  
		- 题目会给出一个具体的模式串，要求写出其对应的$next$数组。
			*   **方法**：寻找子串的最长相等前后缀长度。
			*   **注意**：需确认题目要求的数组下标是从0开始还是从1开始，通常$next[1]=0$或$next[0]=-1$。
	- $nextval$数组的计算（改进的KMP）  
		- 题目要求计算改进后的$next$数组，通常称为$nextval$数组。
			*   **原理**：如果模式串中$j$处的字符与$next[j]$处的字符相同（即$P_{j} = P_{next[j]}$），则在$j$处匹配失败时，跳到$next[j]$处肯定也匹配失败。因此可以直接跳到$next[next[j]]$。
			*   **公式逻辑**：
			    若$P_{j} \neq P_{next[j]}$，则$nextval[j] = next[j]$。
			    若$P_{j} = P_{next[j]}$，则$nextval[j] = nextval[next[j]]$。




![[Pasted image 20251216022818.png]]
[[Pasted image 20251119210959.png]]

- KMP算法相对于朴素的蛮力算法在什么情况下具有压倒性的性能优势 
1. 蛮力算法（BF）的软肋  [[BF算法]]
	1. #蛮力算法的逻辑 是：当模式串（Pattern）和主串（Text）在某一位发生不匹配时，主串的指针$i$回溯，模式串的指针$j$重置为$0$，然后主串向后移动一位，重新开始逐个比较
		*   **最好情况：** 每次比较第一个字符就不匹配。此时时间复杂度为$O(n)$。
		*   **最坏情况：** 每次都比较到了模式串的最后一个字符才发现不匹配（例如主串是`AAAA...B`，模式串是`AAAAB`）。此时指针不断回溯，时间复杂度退化为$O(n \times m)$。
		1. **推导过程：**
			*   **字符集越小 $\rightarrow$ 单次匹配概率越大：** 比如只有0和1两个字符，随便拿两个字符比较，相等的概率很高。
			*   **单次匹配概率越大 $\rightarrow$ 部分匹配越长：** 如果两个字符很容易相等，那么BF算法在比较时，就会经常出现“前几个都对，后面突然不对”的情况。
			*   **部分匹配越多 $\rightarrow$ BF回溯越频繁：** 一旦出现部分匹配后失败，BF就需要回溯。匹配成功的概率越高，BF算法越接近其**最坏时间复杂度**$O(n \times m)$。
2.  KMP算法的优势  
	1. KMP算法利用`next`数组（前缀表），当发生不匹配时，主串指针$i$**不回溯**，模式串指针$j$利用`next`值跳转到合适的位置。
		*   无论字符集大小、无论单次匹配概率多高，KMP的主串指针永远只进不退。
		*   因此，KMP的时间复杂度稳定在$O(n+m)$。
3. 为什么字符集倾斜（概率大）时，匹配概率极高：
	假设只有0和1，且出现不均匀：
	*   $P(0) = 0.9$
	*   $P(1) = 0.1$
	那么，随机取两个位置字符相等的概率（即匹配成功的概率）是“两个都是0”或“两个都是1”的概率之和：
	$P_{match} = P(0) \times P(0) + P(1) \times P(1) = 0.9 \times 0.9 + 0.1 \times 0.1 = 0.81 + 0.01 = 0.82$
	高达$0.82$的匹配率意味着BF算法会进行大量的无效回溯比较，性能急剧下降，而KMP保持不变，因此KMP优势“足够明显”。
- 衍生
	- 手算Next数组 (高频)  
		- 题目会给出一个具体的模式串，例如`ababaa`，要求写出其对应的`next`数组值。
		*   **考点：** 理解前缀、后缀、最长公共前后缀长度的概念。
			*   **注意：** 不同的教材对`next`数组的定义下标可能不同（有的从-1开始，有的从0开始），考试时需注意题目约定。
	* 字符集对算法选择的影响
		* **问：** 如果是在 #DNA序列 （只有A, G, C, T四个字符）中查找，相比于在常规英文文章中查找，哪种算法的性能提升更关键？ 
		*   **答：** 在DNA序列中更关键。因为字符集小（4个），随机匹配概率大（$0.25$），BF算法极易退化，KMP或Boyer-Moore算法的稳定性优势更明显。
	* 字符串的前缀与后缀概念  
		- **考点：** 比如字符串`abcab`。
		    *   真前缀：`a`, `ab`, `abc`, `abca`
		    *   真后缀：`b`, `ab`, `cab`, `bcab`
		    *   最长相等前后缀是`ab`，长度为2。这是计算`next`值的基础。


![[Pasted image 20251216022829.png]]
![[Pasted image 20251216022835.png]]
[[Pasted image 20251119211035.png]]

- #KMP算法vsBF算法  。假设文本串长度为$n$，模式串长度为$m$，且字符集大小为$s$（题中$s=26$）  
1.  第一空：最好情况下的时间复杂度  
	1. **BF 算法：**
	    最好情况发生在**模式串的第一个字符就不匹配**。
	    例如：文本串$T=$`AAAA...`，模式串$P=$`B...`。
	    在文本串的每一个位置，BF 算法只需要比较 1 次发现不匹配，然后向后移动一位。总共比较$n$次。
	    时间复杂度为$O(n)$。
	2. **KMP 算法：**
	    KMP 算法在最好情况下（无回溯，一路匹配或立即失配）也是扫描一遍文本串。
	    时间复杂度为$O(n)$（忽略预处理$O(m)$，通常讨论匹配过程）。
	3. **结论：** 两者在最好情况下都是$O(n)$。
	    **所以第一空填：等于。**  
2. 第二空：平均情况下的时间复杂度  
	1. #BF算法平均情况下的时间复杂度  
		在随机字符串中，字符集大小$s=26$。
	    在文本串的某一个对齐位置，比较第 1 个字符匹配的概率是$1/s$，不匹配的概率是$(s-1)/s$。
	    如果第 1 个不匹配，比较次数为 1。
	    如果第 1 个匹配但第 2 个不匹配，比较次数为 2。
	    以此类推。
		1. 根据概率论，在每一个位置需要进行的**期望比较次数**$E$是一个几何级数，其公式为：
		    $E=1+\frac{1}{s}+\frac{1}{s^2}+\dots\approx\frac{1}{1-1/s}=\frac{s}{s-1}$
		    题目中$s=26$，代入公式：
		    $E=\frac{26}{26-1}=\frac{26}{25}=1.04$
		    这意味着，在平均情况下，BF 算法在文本串的每一个位置平均只需要比较 **1.04 次** 就会发现不匹配并移位。
		    总的平均比较次数约为$1.04n$，从时间复杂度的量级（Big O）来看，这就是$O(n)$。
	2. KMP算法
		1. KMP 算法无论在什么情况下，其主逻辑的时间复杂度都是$O(n)$。
		*   **结论：** 在字符集较大（如 26 个字母）的随机数据下，BF 算法的效率极高，接近$O(n)$，与 KMP 算法处于**同一个数量级**。
		    **所以第二空填：等于。**

- 衍生 
	- 最坏情况的对比  
		-  **问题：** 在最坏情况下，BF 和 KMP 的复杂度对比？
		*   **场景：** 主串为`AAAA...AB`，模式串为`AAAA...B`。
		*   **答案：** BF 会退化为$O(n\times m)$，而 KMP 依然保持$O(n+m)$。这时候 KMP 的优势才体现出来（**大于**）。
	- Next 数组与 Nextval 数组的计算  
		- **考法：** 给你一个模式串，例如`ababaa`，让你手动计算其`next`数组或优化后的`nextval`数组的值。
		*   **公式：**
		    *   $next[j]$：表示当第$j$个字符失配时，模式串应跳到的位置（最长相等前后缀长度 + 1 或类似定义，取决于教材下标从 0 还是 1 开始）。
		    *   $nextval[j]$：在`next`基础上的优化，如果$P[j]==P[next[j]]$，则继续递归寻找。
	- #字符集大小对BF的影响      
		-   **考点：** 如果字符集$s$很小（例如只有 0 和 1 组成的二进制串），BF 的平均效率会怎样？
		*   **分析：** 代入公式$E=\frac{s}{s-1}$。如果$s=2$，则$E=2$。这意味着平均比较次数翻倍，虽然量级还是$O(n)$，但常数项变大，冲突概率变高，BF 效率会相对下降。
-  总结
	这道题考察的是对算法**平均情况概率分析**的理解。
	*   **最好/平均情况：** BF $\approx$ KMP （都是$O(n)$）
	*   **最坏情况：** BF $\ll$ KMP （$O(nm)$ vs $O(n)$）
	
	由于题目问的是“最好”和“平均”，且特意强调了 26 个字母（暗示冲突概率低），所以选 **(D)**。



![[Pasted image 20251216022843.png]]
[[Pasted image 20251119211024.png]]

- 考察的是 **KMP算法** 中核心的 **next数组** 以及 **改进后的next数组（通常称为nextval数组）** 的求解方法  
1. 题目中的字符串索引是从$0$开始的（即$P[0]$是第一个字符）
	符号定义
	*   $P$：模式串，本题中为 "HHFBHHFHHFBSHF"。
	*   $j$：当前字符的下标。
	*   $next[j]$：当模式串第$j$个字符匹配失败时，下一次跳转的位置。
	*   $nextval[j]$（即题中的“改next”）：在$next$基础上进行了优化。
2. 推导步骤 1：求解 next[1] 和 nextval[1]
	1. **求 $next[1]$**：
	    *   根据定义，通常规定$next[0]=-1$，$next[1]=0$（因为$P[0]$之前没有子串，长度为0）。
	    *   或者看前缀后缀：在下标$1$之前的子串是 "H"（对应下标$0$），最长相等前后缀长度为$0$。
	    *   所以，$next[1]=0$。
	2.  **求 $nextval[1]$**：
	    *   **公式**：如果$P[j]==P[next[j]]$，则$nextval[j]=nextval[next[j]]$；否则$nextval[j]=next[j]$。
	    *   当前$j=1$，字符为$P[1]=\text{'H'}$。
	    *   $next[1]$指向的位置是$0$，对应字符$P[0]=\text{'H'}$。
	    *   比较：$P[1]$与$P[0]$。因为$\text{'H'}==\text{'H'}$，字符相等。
	    *   **结论**：我们需要递归使用$nextval$值。
	    *   $nextval[1]=nextval[0]$。已知$nextval[0]$通常固定为$-1$。
	    *   所以，**$nextval[1]=-1$**。
3. 推导步骤 2：求解 next[13] 和 nextval[13] 
	1.  **求 $next[13]$**：
	    *   我们需要看下标$0$到$12$组成的子串：$\text{"HHFBHHFHHFBSH"}$。
	    *   寻找该子串的**最长相等前后缀**。
	    *   前缀集合：H, HH, HHF...
	    *   后缀集合：H, SH, BSH...
	    *   观察发现，只有首尾的 "H" 是匹配的。
	        *   前缀 "H" (下标0)
	        *   后缀 "H" (下标12)
	    *   长度为$1$。
	    *   所以，**$next[13]=1$**。
	2.  **求 $nextval[13]$**：
	    *   当前$j=13$，字符为$P[13]=\text{'F'}$。
	    *   $next[13]$指向的位置是$1$，对应字符$P[1]=\text{'H'}$。
	    *   比较：$P[13]$与$P[1]$。即$\text{'F'}$与$\text{'H'}$。
	    *   它们**不相等**（$\text{'F'}\neq\text{'H'}$）。
	    *   **结论**：不需要优化，直接沿用$next$值。
	    *   $nextval[13]=next[13]$。
	    *   所以，**$nextval[13]=1$**。
	综上所述：$nextval[13]=1$，$nextval[1]=-1$。对应选项 **(A)**。

- 衍生 
	-  (1) 下标从1开始的情况  
		- 部分教材或题目中，字符串下标从$1$开始。
		*   **变化**：所有的$next$和$nextval$值通常会**加1**。
		    *   $next[1]=0$，$next[2]=1$。
		    *   在本题中，如果是1-based indexing，答案会变成$nextval[14]=2$，$nextval[2]=0$。
		*   **应对**：考试时一定要先看清楚题目给出的表格第一列是从$0$开始还是$1$开始，或者通过$next[1]$的值来判断（若$next[1]=0$通常是1-based；若$next[0]=-1$通常是0-based）。
	- (2) 手动计算完整 next 数组
		题目可能不给表格，要求你写出完整的序列。
		*   **技巧**：不要死记算法代码，使用**“观察法”**。
		    *   计算$next[j]$时，遮住第$j$位及以后的字符，只看前面的子串。
		    *   找这一段子串“头”和“尾”最大的重合部分长度。
	-  (3) #KMP的时间复杂度 
		- **考点**：构造$next$数组的时间复杂度是$O(m)$（$m$为模式串长度），匹配过程的时间复杂度是$O(n)$（$n$为主串长度）。
		*   总时间复杂度为$O(n+m)$。

![[Pasted image 20251216022853.png]]
![[Pasted image 20251119211101.png]]

#KMP算法
模式串 $P$：`R V M M O R E O T R V M P`

1.  **$j=0$**: 规定 $next[0]=-1$。
2.  **$j=1$**: 子串 "R"，无真前后缀，长度为0。$next[1]=0$。
3.  **$j=2$**: 子串 "RV"，前缀 "R"，后缀 "V"，不相等。$next[2]=0$。
4.  **$j=3, 4, 5$**: 子串 "RVM"、"RVMM"、"RVMMO"，均没有相同的前后缀。所以 $next[3]=0$, $next[4]=0$, $next[5]=0$。
5.  **$j=6$**: 子串 "RVMMOR"。前缀 "R"，后缀 "R"。长度为1。$next[6]=1$。
6.  **$j=7, 8, 9$**: 子串 "RVMMORE" 等，找不到匹配的前后缀。$next[7]=0$, $next[8]=0$, $next[9]=0$。
7.  **$j=10$**: 子串 "RVMMOREOTR"。前缀 "R"，后缀 "R"。长度为1。$next[10]=1$。
8.  **$j=11$**: 子串 "RVMMOREOTRV"。前缀 "RV"，后缀 "RV"。长度为2。$next[11]=2$。
9.  **$j=12$**: 子串 "RVMMOREOTRVM"。前缀 "RVM"，后缀 "RVM"。长度为3。$next[12]=3$。

**结果**：`-1 0 0 0 0 0 1 0 0 0 1 2 3`，与图中答案一致。
2. 改进 $next[j]$ (nextval) 的推导   #改进next数组   
**计算公式（设改进后的数组为 $val$）：**
*   如果 $P[j] \neq P[next[j]]$，则 $val[j]=next[j]$。
*   如果 $P[j] = P[next[j]]$，则 $val[j]=val[next[j]]$（即递归回溯）。

**推导过程解析：**

1.  **$j=0$**: $next[0]=-1$。无比较对象，保持 $-1$。
    *   **改进 $next[0]=-1$**
2.  **$j=1$**: $next[1]=0$。比较 $P[1]$ ('V') 和 $P[0]$ ('R')。不等。
    *   **改进 $next[1]=0$**
3.  **$j=2, 3, 4$**: 同理，字符与 $P[0]$ 均不相等。
    *   **改进 $next[2,3,4]=0$**
4.  **$j=5$**: $next[5]=0$。比较 $P[5]$ ('R') 和 $P[0]$ ('R')。**相等！**
    *   因为相等，所以不能停在0，要取 $next[0]$ 的改进值。
    *   **改进 $next[5] = 改进 next[0] = -1$**
5.  **$j=6$**: $next[6]=1$。比较 $P[6]$ ('E') 和 $P[1]$ ('V')。不等。
    *   **改进 $next[6]=1$**
6.  **$j=7, 8$**: $next$ 值为0，且字符与 $P[0]$ 不等。
    *   **改进 $next[7,8]=0$**
7.  **$j=9$**: $next[9]=0$。比较 $P[9]$ ('R') 和 $P[0]$ ('R')。**相等！**
    *   **改进 $next[9] = 改进 next[0] = -1$**
8.  **$j=10$**: $next[10]=1$。比较 $P[10]$ ('V') 和 $P[1]$ ('V')。**相等！**
    *   **改进 $next[10] = 改进 next[1] = 0$**
9.  **$j=11$**: $next[11]=2$。比较 $P[11]$ ('M') 和 $P[2]$ ('M')。**相等！**
    *   **改进 $next[11] = 改进 next[2] = 0$**
10. **$j=12$**: $next[12]=3$。比较 $P[12]$ ('P') 和 $P[3]$ ('M')。不等。
    *   **改进 $next[12]=3$**

**结果**：`-1 0 0 0 0 -1 1 0 0 -1 0 0 3`，与图中答案一致。

- 衍生 
	- 数组下标的起始位置（易错点）   
		- 本题是**0-based**（从0开始），$next[0]=-1$。
	    *   很多考研题目或教材 采用**1-based**（从1开始）。
	    *   如果是1-based，所有 $next$ 值通常都要 $+1$。例如本题如果 $j$ 从1开始，则 $next$ 序列会变成 `0 1 1 1 1 1 2...`。**做题时务必先看 $j$ 是从0还是1开始
	- 手工计算技巧
		- 考试中不建议死记算法代码，建议用“画线法”或“观察法”。
	    *   对于 $next[j]$：遮住第 $j$ 位及以后的字符，看前面子串的“头”和“尾”最长能重合几个字。
	    *   对于 $nextval[j]$：先算出 $next[j]$，然后看 $P[j]$ 是否等于 $P[next[j]]$。如果不等，照抄；如果相等，这就叫“追尾”，需要去引用那个位置的 $nextval$ 值。
	- 公式化表示  
		- 设 $P$ 为模式串，
		    $next[j] = \begin{cases} -1 & j=0 \\ \max \{k \mid 0 < k < j \text{ 且 } P[0 \dots k-1] = P[j-k \dots j-1]\} & \text{集合非空} \\ 0 & \text{其他情况} \end{cases}$
	    （注：这是0-based且 $next[0]=-1$ 的定义）


![[Pasted image 20251216022900.png]]
[[Pasted image 20251119211107.png]] 

计算 #改进next数组中最大项与最小项的差  
1.  **找出最大值**：
    浏览表格最后一行，可以看到在 $j=13$ 时，数值为 **6**。这是整行中的最大值。
    *   推导验证：$j=13$ 时，模式串 $P[13]$='A'。此时标准 $next[13]=6$。我们需要比较 $P[13]$ 和 $P[next[13]]$ 即 $P[6]$。
    *   $P[6]$='B'。
    *   因为 $P[13]\neq P[6]$ ('A' $\neq$ 'B')，所以不需要回溯优化，改进后的值保持不变，即 $nextval[13]=next[13]=6$。

2.  **找出最小值**：
    浏览表格最后一行，可以看到出现了多次 **-1**（例如在 $j=0, 2, 4, 9, 11, 14$）。这是整行中的最小值。
    *   推导验证：$nextval[0]$ 固定为 -1。

3. $\text{差值} = \max(\text{nextval}) - \min(\text{nextval}) = 6 - (-1) = 7$  

**本题案例演示**：
*   **$j=2$ 时**：
    *   $P[2]$='B'，标准 $next[2]=0$。
    *   检查：$P[2]$ 与 $P[next[2]]$ 即 $P[0]$ 相比。
    *   $P[0]$='B'。因为 $P[2]=P[0]$，触发优化。
    *   $nextval[2]=nextval[0]=-1$。
*   **$j=5$ 时**：
    *   $P[5]$='B'，标准 $next[5]=3$。
    *   检查：$P[5]$ 与 $P[next[5]]$ 即 $P[3]$ 相比。
    *   $P[3]$='A'。因为 $P[5]\neq P[3]$，不触发优化。
    *   $nextval[5]=next[5]=3$。

- 衍生 
	- 手算 `next` 数组
		- **考点**：给出一个陌生的模式串，要求在 1-2 分钟内快速写出完整的 `next` 数组。
		*   **技巧**：
		    1.  写出字符串。
		    2.  前两位固定（如 -1, 0）。
		    3.  从第 3 位开始，看前一位字符 $P[j-1]$ 和前一位的 $next$ 值指向的字符是否相等。若相等则 $+1$，若不等则 #回溯 
	1. #最短循环节与字符串周期 
		*   **考点**：利用 `next` 数组求字符串的最小循环周期。
		*   **公式**：如果 $Len \% (Len - next[Len]) == 0$，则字符串具有周期性。
		    *   最小循环节长度 $L = Len - next[Len]$。
		    *   这是 KMP 的一个重要应用，常出现在算法填空题中。
	2. 模式串匹配次数分析
		1. **考点**：给定主串和模式串，问在匹配过程中字符比较了多少次？
			*   **应对**：需要模拟 KMP 的指针移动过程，注意利用 `next` 数组进行跳转，而不是简单地像朴素算法那样每次后移一位。

![[Pasted image 20251216022909.png]]
[[Pasted image 20251119211118.png]]

- 题目问的是：在一个长度为 $m$ 的随机 0,1 串中，好后缀数组 $gs[0]==1$ 的概率是多少？
	1.  **理解 $gs[0]$ 的含义**：
	    在 BM 算法中，通常 $gs[j]$ 表示当模式串（Pattern）的第 $j$ 位发生“失配”（Mismatch），而 $j+1$ 到 $m-1$ 位的后缀已经匹配成功时，模式串应该向后移动的位数。
	    *   $gs[0]$ 对应的情况是：模式串的第 $0$ 位（第一个字符）失配，而后面的 $m-1$ 个字符（即 $P[1 \dots m-1]$）都与主串匹配成功。
	2.  **理解 $gs[0]==1$ 的条件**：
	    根据 #好后缀规则 ，为了让位移量仅为 1（这是最小的移动步长），意味着在这个长达 $m-1$ 的后缀内部，必须存在某种“自相似性”，使得模式串向右滑动 1 位后，重叠部分依然能对齐。
	    具体来说，如果我们将模式串 $P$ 向右滑动 1 位，新的重叠部分 $P[0 \dots m-2]$ 必须与之前的后缀 $P[1 \dots m-1]$ 完全相同。
	    即满足方程：
	    $P[0 \dots m-2] = P[1 \dots m-1]$
	    这就要求：
	    $P[0] = P[1]$
	    $P[1] = P[2]$
	    $...$
	    $P[m-2] = P[m-1]$
	    **结论**：只有当模式串 $P$ 的**所有字符都相同**时，上述条件才成立。
	3. **概率计算**：
	    *   由于是 0,1 串，字符集大小为 2。
	    *   所有可能的长度为 $m$ 的 0,1 串总数为 $2^m$。
	    *   满足“所有字符相同”的串只有两种情况：
	        1.  全为 0：`00...0`
	        2.  全为 1：`11...1`
	    *   因此，满足条件的概率 $P$ 为：
	        $P = \frac{\text{满足条件的串数}}{\text{总串数}} = \frac{2}{2^m} = \frac{1}{2^{m-1}}$
	- 这与图片中的解析逻辑一致（图片中是通过独立事件概率相加推导的：$P(\text{全0}) + P(\text{全1}) = (\frac{1}{2})^m + (\frac{1}{2})^m = \frac{1}{2^{m-1}}$）。
		[[Boyer-Moore（BM）算法]] 
- 衍生  
	- #gs数组的具体计算  
		- 给定一个具体的模式串，例如 $P = \text{"ANPANMAN"}$，让你计算其坏字符表或好后缀数组。
		*   **考点**：考察对定义的精确理解。例如，好后缀不仅看完全匹配，还要看“后缀的后缀”是否匹配“前缀”（当完全匹配不存在时）。
	- #BM算法的时间复杂度  
	    *   最坏情况：$O(n \cdot m)$（但在实际应用中极少遇到，需特定构造）。
	    *   最好情况：$O(n/m)$（这是 BM 的优势，比如在 `AAAA...A` 中查找 `B`）。
	    *   平均情况：通常被认为是亚线性的，比 KMP 快
	- #BMvsKMP算法  
		-  **考点**：
		    *   KMP 是**从左向右**比较，利用 `next` 数组（最长相等前后缀）避免回溯。
		    *   BM 是**从右向左**比较，利用跳跃规则实现快速移动。
		    *   KMP 适合字符集小的情况，BM 适合字符集大的情况。
	- 简单的组合数学概率
		- **考点**：给定特定条件（如无重复字符、回文串等），计算在随机生成字符串中出现的概率。
	    *   *例题*：长度为 $m$ 的随机字符串中，坏字符规则总是能移动 $m$ 位的概率是多少？（答案：意味着坏字符从未在模式串中出现过）。
	- 变形公式   
		- 如果是 $k$ 进制的字符串（字符集大小为 $k$），本题的答案会变成什么？
			*   满足条件的串有 $k$ 个（全为字符1，全为字符2...），总数为 $k^m$。
			*   概率为：$\frac{k}{k^m} = \frac{1}{k^{m-1}}$。

![[Pasted image 20251216022916.png]]
[[Pasted image 20251119211128.png]]
- 仅使用好后缀 (gs) 策略，是否能在最好情况下达到 $O(n/m)$ 的时间复杂度？ #gs好后缀策略 
1.  **最好情况的定义：**
    BM 算法的最好情况通常出现在模式串 $P$ 与文本串 $T$ 进行匹配时，每次都在模式串的**最后一个字符**（从右向左比较的第一个字符）发生不匹配。如果算法能指示模式串向右移动 $m$ 个位置（即跳过整个模式串长度），那么总的比较次数约为 $n/m$，时间复杂度即为 $O(n/m)$。
2.   **好后缀 (gs) 规则的机制：**    [[Boyer-Moore（BM）算法]] 
	    通常认为 #bc坏字符策略 更容易产生较大的跳跃（特别是当字符未出现在模式串中时）。但是，“好后缀 (gs)”规则在特定情况下也能产生最大位移 $m$。
    *   `gs` 表格存储的是：当模式串的后缀 $suffix$ 匹配成功，但前一个字符不匹配时，模式串应该向右移动的距离。
    *   如果在**第一个字符就发生不匹配**（即好后缀长度为 0），`gs` 规则会查看整个模式串是否在其他地方作为子串出现。如果没有，且没有前缀匹配后缀的情况，位移量通常被设定为 $m$。
		- **特例分析：** 假设模式串 $P$ 全是相同的字符（如 `aaaaaa`）。
	        *   在构建 `gs` 表时，代码中的循环（第 21-26 行）会更新 `gs[0]` 到 `gs[m-2]` 的值。
	        *   但是，对于 **`gs[m-1]`**（对应于在模式串最右端、即第一个比较字符就发生不匹配的情况），循环逻辑并不会更新它。
	        *   因此，`gs[m-1]` 保持初始值 $m$。
	    *   **匹配过程：**
	        *   如果文本串 $T$ 是 `bbbbbb...` 而模式串 $P$ 是 `aaaaaa`。
	        *   第一次比较 $P[m-1]$ 与 $T[m-1]$，字符不同，发生不匹配。
	        *   此时好后缀长度为 0，查询 `gs[m-1]`。
	        *   由于 `gs[m-1] = m`，模式串向右移动 $m$ 位。
	        *   这种情况下，每次比较 1 次，移动 $m$ 位，总时间复杂度为 $O(n/m)$。
- **结论：** 既然存在一种情况（最好情况），使得仅用 `gs` 策略也能达到 $O(n/m)$，那么题目中说“不能保证”就是错误的。
- 衍生  
	- #BMvsKMP算法   
		- **方向：** KMP 是从左向右比较，BM 是从右向左比较。
	    *   **数组：** KMP 计算 `next` 数组（最长相等前后缀），BM 计算 `bc` 和 `gs` 数组。
	    *   **效率：** 对于大字符集或长模式串，BM 通常比 KMP 快，因为 KMP 只能移动 $1$ 到 $m$ 之间的距离，且跳跃通常较小；BM 可以一次跳跃 $m$ 长度。
	- 手动计算 next 数组或 gs 数组  
		- 题目可能会给出一个具体的模式串（如 $P = ababa$），让你手动推导 KMP 的 `next` 数组值，或者 BM 算法中 `gs` 数组的特定值。  
	- #BM最坏情况分析   
		- 这就涉及到为什么标准 BM 算法最坏是 $O(nm)$。考题可能会让你举例什么情况下 BM 会退化。
	    *   *例子：* $T = \dots 00000$, $P = 10000$。每次都在最后一个字符比较失败，且只能移动 1 位。
	- 好后缀规则的细节逻辑（三种情况） 
		- **Case 1:** 模式串中有子串匹配好后缀 $\rightarrow$ 对齐子串。
	    *   **Case 2:** 模式串中无子串匹配好后缀，但有好后缀的后缀匹配模式串的前缀 $\rightarrow$ 对齐前缀。
	    *   **Case 3:** 上述都不满足 $\rightarrow$ 移动 $m$ 位。
	    *   *考点：* 给定模式串，判断特定不匹配位置属于哪种 Case。
	- 时间复杂度填空：  
		-  #BM算法的预处理时间复杂度 是 $O(m+|\Sigma|)$。
	    *   包含 `gs` 和 `bc` 策略的完整 BM 算法在实际应用中通常表现为 #亚线性时间复杂度 




[[Pasted image 20251216022925.png]]
![[Pasted image 20251119211214.png]]

[[KR算法]] 
**推导过程：**
题目考查的是 KR 算法在移动窗口时计算新哈希值（指纹）的时间复杂度。

*   **朴素做法：** 如果我们每移动一位，都重新计算长度为$m$的子串的哈希值，那么计算一次需要遍历整个子串，时间复杂度是$O(m)$。
*   KR 算法的做法（滚动哈希）： 图片中的解析部分展示了核心思路。为了计算下一个窗口的哈希值，我们不需要重新计算。
    *   图片中的红色块 `- suffix(T_{i-1})` 表示**移除**上一个窗口最高位的字符值。
    *   图片中的绿色块 `+ prefix(T_j)` 表示**加入**新窗口最低位的字符值。
    *   利用数学上的 #进制转换性质 ，我们可以利用上一个哈希值，通过简单的数学运算（减法、乘法、加法）直接推导出下一个哈希值。
    *   因为这些运算的次数是固定的，与子串长度无关，所以时间复杂度是$O(1)$**。 

**结论：** 题目说“无法在 O(1) 内找到”，这与 KR 算法的核心优势（利用滚动哈希在$O(1)$时间内更新指纹）相悖，因此该说法是错误的。


- 衍生 
	- #哈希冲突  
		- **考点：** 如果两个子串的哈希值相等（$H_i = H_{target}$），这两个子串一定相同吗？
		*   **答案：** 不一定。这叫做哈希冲突（伪命中）。
		*   **应对：** KR 算法在哈希值匹配成功后，必须逐个字符比对原字符串以确保正确性。
		*   **复杂度影响：** 在最坏情况下（所有子串哈希值都冲突），KR 算法的时间复杂度会退化为$O(nm)$，其中$n$是文本长度，$m$是模式串长度。但在一般情况下，其平均复杂度为$O(n+m)$。
	-  #模运算的必要性   
		- **考点：** 为什么要进行$\pmod p$运算？
		*   **解释：** 字符串对应的整数值通常非常大，直接存储会溢出标准整数类型（如 64 位整数）。取模是为了将指纹限制在可存储的范围内。 
	* #KRvsKMP算法  
		* **KMP：** 利用前缀函数（Next 数组）跳过不必要的比较，最坏时间复杂度严格为$O(n+m)$，不需要进行哈希运算，无冲突风险。
		*   **KR：** 实现简单，扩展性强（例如可以扩展到二维矩阵匹配），但最坏情况较差。
	* #二维模式匹配   
		* **考点：** 如何在一个大矩阵中查找一个小矩阵？
		*   **思路：** KR 算法的思想很容易推广到二维。可以先对每一列进行滚动哈希，将其压缩成一维数组，然后再在行方向进行滚动哈希。
- **总结公式：**
	KR 算法之所以快，是因为它满足：
	$Hash(Next) = f(Hash(Current), \text{RemovedChar}, \text{AddedChar})$
	且函数$f$的计算复杂度为$O(1)$。


![[Pasted image 20251216022931.png]]
[[Pasted image 20251119211220.png]]

#BM算法 的一个显著特点是**从右向左**比较字符（即从模式串的末尾开始比对）
1. **最好情况（Best Case）的设定：**
	1.  我们将模式串$P$与文本串$T$的开头对齐。
	2.  算法首先比较模式串的最后一个字符$P[m-1]$与对应的文本串字符$T[m-1]$。
	3.  **最好情况**发生当：文本串中的这个字符$T[m-1]$是一个**坏字符**（Bad Character），且该字符**根本不出现**在模式串$P$中。
	4.  根据坏字符规则，既然这个字符不在模式串中，那么模式串中任何字符都不可能与它匹配。因此，我们可以直接将模式串向右滑动**整个模式串的长度**$m$。
	5.  滑动后，我们再次比较当前窗口末尾的字符，情况同上，再次发生完全不匹配并全速滑动。
2. **计算过程：**
	*   文本串长度$n=2023$
	*   模式串长度$m=17$
	*   每次比较只需**1次**（比对模式串末尾字符，发现不匹配）。
	*   每次移动距离为**17**（因为坏字符不在模式串中，跳过整个区域）。
	*   由于$2023$是$17$的倍数（$2023 \div 17 = 119$），这意味着我们可以完美地进行$119$次跳跃，覆盖整个文本串。
	因此，总的比对次数为：
	$Comparisons=\frac{n}{m}=\frac{2023}{17}=119$
	
	所以，答案是$119$次。
 - 衍生 
	 - #坏字符规则的位移计算   
		 -  **问题：** 给定模式串 $P=$`EXAMPLE`，当前坏字符是 $X$（假设文本中对应位置是 $X$），问模式串向右移动几位？
		*   **解析：** 需要判断 $X$ 是否在 `EXAMPLE` 中出现。如果出现，移动距离 $= \text{当前下标} - \text{模式串中最右该字符下标}$；如果不出现，移动距离 $= \text{当前下标} - (-1)$。
	- 最坏情况下的比较次数  
		- **问题：** 若 $T=$`0000...0`（共$n$个），$P=$`10000`（共$m$个），利用 BM 算法的最坏比较次数是多少？
		*   **解析：** 每次从右向左比对，前面的 $m-1$ 个 `0` 都匹配，直到第一个字符 `1` 不匹配。每次移动 $1$ 位。
		*   **公式：** 比较次数约为$n \times m$（更精确可能是$(n-m+1) \times m$）
	- #BMvsKMP算法   
		- **问题：** 何时使用 BM，何时使用 KMP？
		*   **解析：**
		    *   **KMP：** 适合字符集小、模式串短或需要实时处理流数据的场景。时间复杂度稳定在$O(n+m)$。
		    *   **BM：** 适合字符集大、模式串长的情况（如文本编辑器中的查找）。因为$m$越大，BM 在最好情况下跳跃的步长越大，速度越快。
	- #好后缀规则的应用  
		- **问题：** 给出一个匹配失败的具体场景，要求根据**好后缀规则**计算移动位数。
		*   **解析：** 这需要考生能够预处理出 `gs` 表（或手动模拟），寻找模式串中是否存在与已匹配后缀相同的子串。 
	- #字符串匹配顺序     
		- **问题：** 以下哪个算法在匹配过程中通常是从右向左比较字符的？
		*   **选项：** A. BF 算法  B. KMP 算法  C. Boyer-Moore 算法
			*   **答案：** C。这是一个非常基础但高频的概念题。

![[Pasted image 20251216022941.png]]
[[Pasted image 20251119211223.png]]


1. 核心逻辑： #坏字符表的索引 是字符本身，而不是 #模式串 的下标   
	*   #坏字符表的作用 
	    当模式串（Pattern）与主串（Text）匹配过程中发生不匹配（Mismatch）时，我们需要根据主串中那个导致不匹配的字符（即“坏字符”），快速查找该字符在模式串中上一次出现的位置，从而决定模式串向右移动多少位。
	*   **数据结构实现**：
	    为了实现$O(1)$的快速查找，通常使用一个 **数组** 来存储这张表。
	    *   **数组的下标（Index）**：对应字符集中的每一个字符的编码（例如 ASCII 码）。
	    *   **数组的值（Value）**：该字符在模式串中最右边出现的位置下标。
	*   **推导结论**：
	    假设字符集为$\Sigma$，字符集的大小为$|\Sigma|$（例如 ASCII 码表通常为 256）。
	    那么，坏字符数组的大小（长度）必须能够容纳字符集中所有的字符，即数组长度固定为$|\Sigma|$（例如定义 `int bc[256]`）。
	    无论你的模式串长度$m$是 3 还是 10000，只要字符集是 ASCII，坏字符表的长度始终是 256。
	
	因此， #坏字符表的长度 由 #字符集大小 决定 ，与模式串长度无关。题目的判断是正确的（$\sqrt{}$）。
[[构建坏字符表的伪代码]]  
- 衍生 
	1. 坏字符规则的计算与移动  
		1. 题目可能会给出一个具体的主串和模式串，问你发生第一次不匹配时，根据坏字符规则需要移动多少位。
			*   **公式**：移动位数$=si-xi$
			    *   $si$：不匹配字符在模式串中的下标（当前位置）。
			    *   $xi$：坏字符在模式串中**最右出现**的下标（查表得到，若不存在则为$-1$）。
			*   **注意**：如果计算结果是负数（因为坏字符在模式串当前位置的右侧也有出现），则坏字符规则不起作用（即移动 0 位或 1 位），需要依赖好后缀规则。
	2. #BM算法的时间复杂度  
		1. **最好情况**：$O(n/m)$。这是 BM 算法最强的地方。当主串中的字符在模式串中都不存在时，每次可以跳跃$m$个字符。
			*   **最坏情况**：$O(n\times m)$（标准实现如果不加优化）。这通常发生在模式串和主串包含大量重复字符时（例如主串 "AAAAA..." 找模式串 "BAA"）。
			*   注：$n$为主串长度，$m$为模式串长度。
	3. #BMvsKMP算法  
		1. **KMP**：利用 `next` 数组（或 `prefix` 表）。`next` 数组的长度**等于**模式串长度$m$。
		*   **BM**：坏字符表长度等于**字符集大小**$|\Sigma|$。
		*   **比较方向**：BM 适合大字符集、长模式串的场景（如文本编辑器搜索），一般情况下比 KMP 快；KMP 适合小字符集或特定重复模式。

[[串可能考但没考的内容]] 



![[Pasted image 20251119211232.png]]