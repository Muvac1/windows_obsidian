![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=1&rect=17,398,583,693|826历年真题解析-数据结构篇（包括算法题）-12.15, p.1]]
1.  #指针运算的本质 ： 在C/C++等语言中，对于指针$p$，执行$p++$操作实际上是将指针指向的内存地址增加该指针类型的大小。公式为：$NewAddress=OldAddress+\text{sizeof}(Type)$。这仅仅是内存地址的线性偏移。  
2.   #数据结构的存储方式  
	1.  **顺序存储（如数组）：** 逻辑上相邻的元素，在物理内存上也是相邻的。此时，$p++$确实指向下一个逻辑元素。
    *   **链式存储（如链表）：** 逻辑上相邻的元素（节点），在物理内存中通常是**分散**的。节点之间通过“指针域”（next pointer）连接。
3.   **结论：** 如果$p$指向链表中的一个节点，执行$p++$只会让指针移动到该节点内存块紧挨着的下一个位置（可能是垃圾数据，也可能是其他无关变量），而不是链表逻辑上的“下一个节点”。链表的下一个节点地址存储在$p\to next$中。因为题目表述具有普适性（暗示所有情况），而链表是反例，所以该命题为假
知识点 
-   指针算术运算    [[指针算数运算]]   
- [[存储结构]] 
- #静态链表  图片右侧展示的`rank`, `link[]`, `elem[]`图示即为**静态链表**。
	*   它利用**数组**来模拟链表。
	*   **数据域：** `elem[]` 存放数据。
	*   **指针域：** `link[]` 存放下一个元素在数组中的**下标**（游标），而不是内存地址。
	*   在这种结构中，物理上相邻的`elem[0]`和`elem[1]`在逻辑上可能并不相连。
- 衍生 
	1. 指针运算的具体计算
	2. #顺序表与链表的优缺点对比 
		1.  在频繁进行插入和删除操作的场景下，应选择哪种存储结构？
			**解析：** 应选择**链式存储**。
			*   **顺序表：** 插入/删除需要移动大量元素，时间复杂度为$O(n)$。
			*   **链表：** 插入/删除只需修改指针指向，时间复杂度为$O(1)$（前提是已知位置）。
	3. #静态链表的特性    
		1. **题目示例：** 静态链表中指针的作用是什么？
			**解析：** 静态链表中的“指针”实际上是**数组下标**（游标）。它不需要像动态链表那样频繁地进行`malloc`/`new`内存分配，适合不支持指针的语言（如早期的BASIC、Fortran）或需要固定内存池的场景。
	4. #C➕➕迭代器Iterator 的理解    
		1. **题目示例：** 在C++ STL中，`vector<int>::iterator`和`list<int>::iterator`执行`it++`的区别。
			**解析：**
			*   对于`vector`（数组实现），`it++`通常被编译为指针的算术运算（物理地址$+4$）。
			*   对于`list`（链表实现），`it++`是操作符重载（Operator Overloading），其内部实现逻辑类似于$p=p\to next$，即跳转到非连续的内存地址。这正是题目中容易混淆的高级形式。


![[Pasted image 20251118183040.png]]

- 这道题目的核心在于考察 #大O符号的定义 以及 #函数增长率 的比较，特别是针对增长极快的函数（如$n^n$或$n!$）时的特殊性质。   
-    #大O表示法     [[大O符号的定义]]    [[函数增长率排序]]   
- $O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$ 
解析中给出的反例是$f(n)=n^n$且$g(n)=n^n$   #举反例 
1. 显然$f(n)=n^n$且$g(n)=n^n$，根据大O定义，$n^n \le 1 \cdot n^n$，所以$f(n)=O(g(n))$成立  
2. 验证结论是否失效  
	1. 需要判断$n^n$是否是$O((n-1)^{n-1})$  
	2. 通过计算极限$\lim_{n \to \infty}\frac{f(n)}{g(n-1)}$来判断。如果极限是常数，则成立；如果是无穷大，则不成立。

    $$ \begin{aligned} \lim_{n \to \infty} \frac{n^n}{(n-1)^{n-1}} &= \lim_{n \to \infty} \frac{n \cdot n^{n-1}}{(n-1)^{n-1}} \\ &= \lim_{n \to \infty} n \cdot \left( \frac{n}{n-1} \right)^{n-1} \\ &= \lim_{n \to \infty} n \cdot \left( 1 + \frac{1}{n-1} \right)^{n-1} \end{aligned} $$

    3. 根据重要极限公式$\lim_{x \to \infty}(1+\frac{1}{x})^x=e$，当$n \to \infty$时，$(1 + \frac{1}{n-1})^{n-1}$趋近于常数$e$。[[基本极限公式(求积分）]] 
	    所以整个式子趋近于：
	    $\lim_{n \to \infty} (n \cdot e) = +\infty$ 
    4. 因为比值的极限是无穷大，说明$f(n)$的增长速度远快于$g(n-1)$，因此无法找到常数$C$使得$f(n) \le C \cdot g(n-1)$。
	    即$f(n) \neq O(g(n-1))$。
3. **结论：**
	虽然$f(n)=O(g(n))$，但在该反例下推导不出$f(n)=O(g(n-1))$。因此题目中的判断“不一定有”是正确的。  

- 衍生 
	- #阶乘函数的反例  
		- 除了$n^n$，另一个经典的考点是阶乘$n!$。
			*   设$f(n)=n!$，$g(n)=n!$。
			*   前提：$f(n)=O(g(n))$成立。
			*   结论：考察$g(n-1)=(n-1)!$。
			    $\frac{f(n)}{g(n-1)} = \frac{n!}{(n-1)!} = n \to \infty$
			    因此，$n! \neq O((n-1)!)$。
			    **结论：** 对于阶乘函数，题目中的命题同样成立。
	- #指数函数的特例    
		- 题目换成指数函数，结论可能不同。
			*   设$f(n)=2^n$，$g(n)=2^n$。
			*   考察$g(n-1)=2^{n-1}$。
			    $$ 2^n = 2 \cdot 2^{n-1} = 2 \cdot g(n-1) $$
			    根据大O定义，取$C=2$，则$2^n = O(2^{n-1})$**成立**。
			    **注意：** 对于底数为常数的指数函数（如$2^n, 3^n$），$f(n)=O(g(n-1))$通常是成立的，因为$a^n = a \cdot a^{n-1}$，只差一个常数倍数
	- #多项式函数  
		- 设$f(n)=n^2$，$g(n)=n^2$。
		*   考察$g(n-1)=(n-1)^2 = n^2 - 2n + 1$。
		    显然$n^2$与$(n-1)^2$是同阶的，即$n^2 = O((n-1)^2)$**成立**。
		
		**总结衍生规律：**
		在判断$f(n)=O(g(n)) \implies f(n)=O(g(n-1))$时：
		1.  对于**多项式**（如$n^k$）和**常数底数指数函数**（如$2^n$），该推导通常**成立**。
		2.  对于**超指数函数**（如$n!, n^n$），该推导通常**不成立**。
		
		


![[Pasted image 20251118183048.png]]
- 这道题的答案是基于 #主定理 （Master Theorem）推导出来的。题目考察的是对递归算法时间复杂度的渐进分析，特别是常数项对最终复杂度阶数的影响   [[分治法与主定理]]  
1. 题目给出的递推公式为$T(n)=T(n/2)+O(1)$，且基础情况$T(1)=a$（$a$为常数）  
	1. 将该公式对应到主定理的标准形式$T(n)=A\cdot T(n/B)+f(n)$中  
2. 第一步：计算 #临界指数 
	1.   我们需要计算$n^{\log_B A}$的值：
		$n^{\log_B A}=n^{\log_2 1}=n^0=1$  
3. 第二步：比较$f(n)$与$n^{\log_B A}$  
	*   题目中$f(n)=O(1)$，即常数。
	*   计算出的$n^{\log_B A}=1$，也是常数。
	*   两者属于同阶，即$f(n)=\Theta(n^{\log_B A})$。
4. 第三步：套用主定理情形  
	1. 主定理的**第二种情况**（Case 2）：
		若$f(n)=\Theta(n^{\log_B A})$，则$T(n)=\Theta(n^{\log_B A}\cdot\log n)$
	2. 代入数值：
		$T(n)=\Theta(1\cdot\log n)=\Theta(\log n)$  
		- 题目中的陷阱“无论常数$a$多大”
		1. 在渐进时间复杂度分析（Big O notation）中，我们关注的是随着$n$趋向于无穷大时函数的增长率。基础情况$T(1)=a$只是一个常数项。在数学上，最终的时间消耗可以近似表示为$C\cdot\log n+a$。当$n$足够大时，$\log n$项起主导作用，常数项$a$（无论是一万还是一亿）相对于$\log n$都可以忽略不计。因此，答案确实总是$O(\log n)$  
- 衍生  
	- 二分查找的变种  
		-  公式：$T(n)=T(n/2)+O(1)$
		*   结果：$O(\log n)$
		*   应用：二分查找
	* 二叉树遍历 / 归并排序  
		*    公式：$T(n)=2T(n/2)+O(1)$（树遍历）或$T(n)=2T(n/2)+O(n)$（归并排序）。
		*   分析（树遍历）：$a=2, b=2 \Rightarrow n^{\log_2 2}=n^1$。$f(n)=1$。叶子重。结果$O(n)$ 
		*   分析（归并排序）：$a=2, b=2 \Rightarrow n^{\log_2 2}=n$。$f(n)=n$。均衡。结果$O(n\log n)$
	* 只有分支没有合并代价 
		* 公式：$T(n)=2T(n/2)$
		*   分析：这等同于$f(n)=0$的情况，完全由叶子节点决定。
		*   结果：$O(n)$。
	* #主定理的失效情况 
		*  如果$f(n)$和$n^{\log_b a}$之间不是多项式级的差距（例如相差一个$\log n$因子），则不能直接套用最简形式，需要用到扩展的主定理（如图片中提到的$f(n)=\Theta(n^{\log_b a}\cdot\log^k n)$的情况）。
		*   例如：$T(n)=2T(n/2)+n\log n$。此时$n^{\log_2 2}=n$，而$f(n)=n\log n$。两者相除是$\log n$，符合扩展情况$k=1$，结果为$O(n\log^2 n)$ 
![[Pasted image 20251118183058.png]]
#就地算法 
- 衍生 
	- [[就地算法的排序]]   
	- #非数值计算终端就地操作   
		- 除了排序，还可能考察：
			*   **矩阵操作**：如“矩阵的原地转置”，要求空间复杂度为$O(1)$。
			*   **字符串操作**：如“原地反转字符串”，使用双指针交换首尾字符，空间复杂度为$O(1)$。

![[Pasted image 20251118183108.png]]
[[Pasted image 20251118183116.png]]
- 这道题的核心思路是通过**代数变形**和**换元法**，将复杂的函数比较转化为我们熟悉的函数比较  

1. 第一步：左边式子（LHS）的变形  
	1. 对数恒等式$a = e^{\ln a}$或$x^y = e^{y \ln x}$，我们可以将底数$n$变形。
		根据图片中的推导：  
		 $n^{\log\log\log n} = e^{\log n \cdot \log\log\log n}$   
	2. 利用乘法交换律和指数性质$e^{a \cdot b} = (e^b)^a$：
		$e^{\log\log\log n \cdot \log n} = (e^{\log(\log\log n)})^{\log n}$
		因为$e^{\log x} = x$，所以括号内变为$\log\log n$。于是左边变为：
			$(\log\log n)^{\log n}$
	3. 因为$e^{\log x} = x$，所以括号内变为$\log\log n$。于是左边变为：
		$(\log\log n)^{\log n}$  
2. 第二步：换元法  
	1. 简化比较，令$M = \log n$。
		*   左边式子变为：$(\log M)^M$
		*   右边式子（RHS）变为：$M!$（即$[\log n]!$）
3. 第三步：比较增长率  
	1. 问题转化为比较$(\log M)^M$与$M!$的大小关系  
		1.   通过取对数或者利用 #斯特林公式 （Stirling's approximation）来辅助判断。    [[斯特林公式]]
		2.  **左边取对数**：$\ln((\log M)^M) = M \cdot \ln(\log M)$
			*   **右边取对数**：根据斯特林公式，$M! \approx \sqrt{2\pi M}(\frac{M}{e})^M$，取对数后约为$\ln(M!) \approx M \ln M - M$
	2. 比较指数部分  
		1. 需要比较$M \ln(\log M)$与$M \ln M - M$  
		2. $M$趋于无穷大时，$\ln(\log M)$远小于$\ln M$  
		3. $M \ln(\log M) \ll M \ln M$  
	3. 意味着$(\log M)^M$的增长速度远小于$M!$的增长速度。
		所以，$(\log M)^M = O(M!)$成立。
		代回$n$，即原命题$n^{\log\log\log n} = O([\log n]!)$成立。  #增长上界   [[大O符号的定义]] 
- 衍生 
	- [[函数增长率排序]]  
		- 比较$n!$与$n^n$，$2^n$与$n!$，$n^{\log n}$与$2^{(\log n)^2}$的大小。
		*   例如：$n^{\log n} = (e^{\ln n})^{\ln n} = e^{(\ln n)^2}$，这比多项式$n^k$大，但比指数$2^n$小。  
	* 斯特林公式的直接应用  
		* 可能会要求计算包含阶乘的极限。
			**衍生题**：求$\lim_{n \to \infty} \frac{\sqrt[n]{n!}}{n}$。
			*   利用斯特林公式可得结果为$\frac{1}{e}$。
	- 积分判别法与级数估算  
		- 图片底部提到了$\sum \frac{1}{k} \approx \ln n$和$\sum \ln k \approx n \ln n$。这通常与积分近似有关。
			**衍生题**：估算$\sum_{k=1}^n k \log k$的复杂度。
			*   可以通过积分$\int_1^n x \ln x \, dx$来估算，结果为$\Theta(n^2 \log n)$。
	- 复杂的对数变换  
		- 类似于本题，给出一个看起来很吓人的指数对数混合式，要求化简。
			**衍生题**：判断$2^{\sqrt{2 \log n}}$与$n$的关系。
			*   取对数比较：$\ln(2^{\sqrt{2 \log n}}) = \sqrt{2 \log n} \cdot \ln 2$ vs $\ln n$。显然$\sqrt{\log n} \ll \log n$，所以前者是$o(n)$

![[Pasted image 20251122140515.png]]
[[Pasted image 20251118183121.png]]
- 这道题目的核心在于**比较两个函数的渐进增长率**。图片中的解析通过取对数（或者说将其转换为以$2$为底的指数形式）来简化比较过程。以下是详细的推导、知识点介绍及衍生考点  
	- 解析使用了 #统一底数法 ，即将等式两边的函数都转换为$2$的幂次方形式进行比较 
1.   第一步：分析左边  
	1. 左边的函数是$\lg^n n$，这里的记号通常表示$(\lg n)^n$。  
	2. 对数恒等式$x=2^{\lg x}$，我们可以将其重写为：
		$\lg^n n = 2^{\lg(\lg^n n)}$
		根据对数性质$\lg(a^b) = b\lg a$，指数部分可以化简为：
		$\lg(\lg^n n) = n\lg(\lg n)$
		所以，左边$=2^{n\lg\lg n}$
2. 第二步：分析右边 (RHS)   
	1. 右边的函数是$n^{\lg n}$。
		同样利用对数恒等式将其重写为：
		$n^{\lg n} = 2^{\lg(n^{\lg n})}$
		根据对数性质，指数部分可以化简为：
		$\lg(n^{\lg n}) = \lg n \cdot \lg n = \lg^2 n$
		所以，右边$=2^{\lg^2 n}$  
3. 第三步：比较指数的增长率  
	1. 比较左边的指数$E_1 = n\lg\lg n$和右边的指数$E_2 = \lg^2 n$  
		*   $E_1$包含线性项$n$，其增长速度是多项式级别的。
		*   $E_2$是$\lg n$的平方，属于多对数级别（Polylogarithmic），其增长速度远小于线性增长$n$。
		*   当$n$趋于无穷大时，$n\lg\lg n \gg \lg^2 n$。
[[渐进符号]]  
[[对数运算性质ln公式]]   

-  衍生  
	- #利用换元法比较    
		- 比较$n^{\lg n}$与$(\lg n)^n$。
		*   **方法：** 令$k = \lg n$，则$n = 2^k$。
		    *   $n^{\lg n} \Rightarrow (2^k)^k = 2^{k^2}$
		    *   $(\lg n)^n \Rightarrow k^{(2^k)}$
		    *   显然$k^{(2^k)}$（类似于$n^n$级别）远大于$2^{k^2}$（类似于$2^n$级别）。 
	- 阶乘与指数的比较    
		-   **题目：** 比较$n!$与$2^n$或$n^n$。
		*   **结论：** $2^n < n! < n^n$。  
		*   **技巧：** 使用斯特林公式 (Stirling's approximation) $\ln(n!) \approx n\ln n - n$
	- 常数对数次幂的比较  
		- 比较$2^{\sqrt{2\lg n}}$与$n$。
		*   **分析：** 取对数比较。
		    *   $\lg(2^{\sqrt{2\lg n}}) = \sqrt{2\lg n}$
		    *   $\lg(n) = \lg n$
		    *   因为$\lg n$增长快于$\sqrt{\lg n}$，所以$n$增长更快
	- 特殊的对数恒等式应用  
		-   **题目：** 判断$3^{\lg n} = \Theta(n^{\lg 3})$  
		- **分析：** 利用公式$a^{\log_b c} = c^{\log_b a}$。
		    *   $3^{\lg n} = 3^{\log_2 n} = n^{\log_2 3} = n^{\lg 3}$。
		    *   两者完全相等，所以是$\Theta$关系。这是正确的

![[Pasted image 20251122140526.png]]
[[Pasted image 20251118183126.png]]
- 这道题考察的是算法分析中 #渐进复杂度的比较 。简单来说，就是当输入规模$n$趋向于无穷大时，哪一个函数的数值增长得更迅猛   
1. 比较$f(n)=2^{\lg^2 n}$和$g(n)=n^{2020}$的增长速度，最直观的方法是将它们变换成**相同的底数**或者**取对数**来进行比较。题目解析采用的是统一底数的方法  
	1. 第一步：理解符号  
		1. 题目中的$\lg n$通常在计算机科学中默认表示以2为底的对数，即$\log_2 n$。
			$\lg^2 n$表示的是对数的平方，即$(\lg n)^2$，而不是$\lg(\lg n)$   
	2. 第二步：统一底数  
		1. 将$g(n)$也表示成以2为底的指数形式。
			利用 #对数恒等式$n=2^{\lg n}$ $n = 2^{\log_2 n}$，我们可以对$g(n)$进行变形：  
		2. $g(n)=n^{2020}=(2^{\lg n})^{2020}=2^{2020\lg n}$  
	3. 此时，两个函数变成了：
		*   $f(n)=2^{(\lg n)^2}$
		*   $g(n)=2^{2020\lg n}$
	4. 第三步：比较指数  
		1. 底数都是2（且$2>1$），底数相同的指数函数是单调递增的，所以我们只需要比较指数部分的增长速度即可。
			*   $f(n)$的指数是$A(n)=(\lg n)^2$
			*   $g(n)$的指数是$B(n)=2020\lg n$
		2. 可以设$x=\lg n$。当$n\to\infty$时，$x\to\infty$  
			1. 问题转化为比较$x^2$和$2020x$的增长速度。
				显然，二次函数$x^2$的增长速度远快于线性函数$2020x$
	5. 数学证明（求极限）  
		1. $\lim_{n\to\infty}\frac{\text{指数}A}{\text{指数}B}=\lim_{n\to\infty}\frac{(\lg n)^2}{2020\lg n}=\lim_{n\to\infty}\frac{\lg n}{2020}=\infty$  
		2. 极限是无穷大，说明分子（$f(n)$的指数）是分母（$g(n)$的指数）的高阶无穷大   
	6. 结论：  
		1. 指数$(\lg n)^2$增长得比$2020\lg n$快，所以$f(n)$增长更快  
2. #对数与指数的性质  
	*   幂的对数转换：$a^b=c^{b\log_c a}$，特别是$n=2^{\lg n}$。
    *   幂的乘方：$(a^m)^n=a^{mn}$。
    *   对数的记法：$\lg^k n=(\lg n)^k$。
3. #函数的渐进增长率   
	1.  这是算法复杂度分析的核心。我们需要判断当$n$充分大时，哪个函数占主导地位。
    *   **多项式函数 vs 拟多项式函数：**
        *   $g(n)=n^{2020}$是一个**多项式函数**（Polynomial）。
        *   $f(n)=2^{\lg^2 n}=2^{(\lg n)(\lg n)}=(2^{\lg n})^{\lg n}=n^{\lg n}$。这是一个**超多项式函数**（Super-polynomial），它的增长速度快于任何形式的$n^k$（其中$k$是常数），但慢于指数函数$2^n$
    [[函数增长率排序]]
	1. **考点：** 题目可能会把$f(n)=n!$和$g(n)=n^n$放在一起比较（$n^n$更快），或者比较$n!$和$2^n$（$n!$更快）。
- 衍生  
	-  取对数法  
		- 当函数形式是指数塔（如$2^n$）或阶乘时，直接比较困难，可以两边同时取对数。
		*   **例子：** 比较$f(n)=n!$和$g(n)=2^{n^2}$。
		    *   $\lg(n!)\approx n\lg n$（斯特林公式近似）
		    *   $\lg(2^{n^2})=n^2$ 
		    *   显然$n^2$增长快于$n\lg n$，所以$g(n)$更快。
	- [[洛必达法则]]   
		- 比较两个函数$f(n)$和$g(n)$时，如果直接看不出来，可以计算极限$\lim_{n\to\infty}\frac{f(n)}{g(n)}$。
			*   如果极限为$0$，则$f(n)=o(g(n))$（$g$快）。
			*   如果极限为$\infty$，则$f(n)=\omega(g(n))$（$f$快）。
			*   如果极限为常数$c>0$，则$f(n)=\Theta(g(n))$（同阶）。
	- #常数项的迷惑  
		- 题目中的$2020$是一个很大的常数，这是为了迷惑考生。在渐进分析中，**常数项和低阶项是可以忽略的**。
			*   例如：$n^{0.01}$最终一定会超过$\lg^{100}n$。虽然在$n$较小时后者大，但在渐进意义上（$n\to\infty$），幂函数永远快于对数函数。
**总结公式：**
对于本题这类$n^{\lg n}$与$n^k$的比较，可以记住一个结论：
只要指数不仅包含常数，还包含$n$的函数（如$\lg n$），那么$n^{\lg n}$这类函数的增长速度通常会超过任何常数次幂的多项式$n^k$。



![[Pasted image 20251122140534.png]]
[[Pasted image 20251118183158.png]]
- 这道题目考察的是 #递归方程 （Recurrence Relation）的渐进复杂度分析。图片中的解析使用的是 #迭代法（展开法） ，但同时也提到了 #主定理 
1. $f(n)=3f(\frac{n}{9})+O(1)$   把$O(1)$看作一个常数$C$。解析中使用的是**迭代法**，即不断把函数展开，寻找规律。     
	1. 第一步：不断展开递推式  
		1. 第1层：$f(n)=3f(\frac{n}{9})+C$
		*   第2层：将$f(\frac{n}{9})$替换为$3f(\frac{n}{9^2})+C$，代入上式：
		    $f(n)=3[3f(\frac{n}{9^2})+C]+C=3^2f(\frac{n}{9^2})+3C+C$
		*   第3层：同理代入：
		    $f(n)=3^2[3f(\frac{n}{9^3})+C]+3C+C=3^3f(\frac{n}{9^3})+3^2C+3C+C$
	2. 第二步：寻找第$k$层的通项公式  
		1. 展开到第$k$次时：
			$f(n)=3^kf(\frac{n}{9^k})+C(3^{k-1}+3^{k-2}+\dots+3+1)$  
	3.  第三步：确定递归停止条件  
		1. 递归会在$n$被除到只剩常数（如$1$）时停止。设$\frac{n}{9^k}=1$，则有：
			$9^k=n$
			对两边取以9为底的对数：
			$k=\log_9n$
	4. 第四步：计算最终复杂度  
		1. 需要计算$3^k$是多少。利用对数换底公式或指数性质：
			$3^k=3^{\log_9n}$
			因为$9=3^2$，所以$\log_9n=\frac{1}{2}\log_3n=\log_3(\sqrt{n})$。
			或者更直观地看：$3^k=(9^{1/2})^k=(9^k)^{1/2}=n^{1/2}=\sqrt{n}$
	5. 通项公式的两部分分别为：
		1.  **第一项（递归项）：**$3^kf(1)=\sqrt{n}\cdot O(1)=O(\sqrt{n})$
		2.  **第二项（常数项求和）：**这是一个等比数列求和，公比为3。
		    Sum$=C\frac{3^k-1}{3-1}=\frac{C}{2}(3^k-1)\approx O(3^k)=O(\sqrt{n})$
	6. 两项相加，最终复杂度为：
		$f(n)=O(\sqrt{n})$  
- 2. 主定理  
	- 对于形式为$T(n)=aT(\frac{n}{b})+f(n)$的递推式（其中$a\ge1,b>1$），我们将$n^{\log_ba}$与$f(n)$进行比较：

	1.  情况1：如果$f(n)=O(n^{\log_ba-\epsilon})$（即$f(n)$增长得比$n^{\log_ba}$慢），则$T(n)=O(n^{\log_ba})$。
	2.  情况2：如果$f(n)=\Theta(n^{\log_ba})$（即两者增长速度相当），则$T(n)=O(n^{\log_ba}\log n)$。
	3.  情况3：如果$f(n)=\Omega(n^{\log_ba+\epsilon})$（即$f(n)$增长得更快），且满足正则性条件，则$T(n)=O(f(n))$。
	
	**套用本题：**
	*   $a=3$（子问题数量）
	*   $b=9$（子问题规模缩小的比例）
	*   $f(n)=O(1)$（合并子问题的代价是常数）
		计算临界指数：
		$\log_ba=\log_93=\frac{1}{2}$
		所以临界函数是$n^{0.5}$即$\sqrt{n}$。
		
		比较$f(n)$与临界函数：
		$f(n)=1$，而临界函数是$\sqrt{n}$。
		显然$1<\sqrt{n}$，属于**情况1**（递归树叶子节点的代价占主导）。
		
		**结论：**
		$T(n)=O(n^{\log_ba})=O(n^{\log_93})=O(n^{0.5})=O(\sqrt{n})$
- 衍生 
	- 主定理的其他情况
		- 归并排序的复杂度分析。
		    *   公式：$T(n)=2T(\frac{n}{2})+n$
		    *   分析：$a=2,b=2$，$\log_22=1$。此时$f(n)=n$，与$n^{\log_ba}=n^1$相等。
		    *   结果：属于情况2，复杂度为$O(n\log n)$。
		- 考点： 只有分支没有合并代价的情况。
		    *   公式：$T(n)=2T(\frac{n}{2})+1$（二叉树遍历的某种变体）
		    *   分析：$n^{\log_22}=n$，比$1$大，结果为$O(n)$。
	- 典型的算法复杂度对应  
		-  **二分查找 (Binary Search)：**
		    $T(n)=T(\frac{n}{2})+O(1)\Rightarrow O(\log n)$
		    （这里$a=1,b=2,\log_21=0$，即$n^0=1$，与$f(n)$相等，属于情况2）。
		*   **二叉树遍历：**
		    $T(n)=2T(\frac{n}{2})+O(1)\Rightarrow O(n)$
	-  #递归树法   
		- 如果题目给出的式子不能直接套用主定理（例如$T(n)=T(n/3)+T(2n/3)+n$），则需要画出递归树，计算每一层的代价总和，然后累加。这是迭代法的图形化表示。   
	- 简单的数学变换  
		- 题目可能会考察$T(n)=2T(\sqrt{n})+\log n$这类变体。
		*   解法：通过换元，令$n=2^m$，将问题转化为关于$m$的常规递推式。   
* 掌握**主定理**是解决这类选择题或填空题的神器。对于需要写过程的大题，建议先用主定理在草稿纸上算出结果，再用**迭代法**（如图片所示）写出详细步骤，这样既能保证正确率又能拿满步骤分。   

![[Pasted image 20251122140543.png]]
[[Pasted image 20251118183410.png]]
[[Pasted image 20251118183415.png]]

1. 第一步：换元简化  
	1. 令$M = \log n$   
		1. 不等式左边变为：$M!$
		*   不等式右边进行对数恒等变换：
		    利用公式$a^{\log_a b} = b$，或者更通用的$x^{\log y} = y^{\log x}$。
		    $n^{\log \log n} = (e^{\ln n})^{\ln \ln n}$ (若以e为底)
		    更直观的变换是：$n^{\log \log n} = (\log n)^{\log n} = M^M$。
2. 第二步：比较$M!$与$M^M$  
	1. 问题转化为比较$M!$和$M^M$的大小关系。
		*   $M! = 1 \times 2 \times 3 \times \dots \times M$
		*   $M^M = M \times M \times M \times \dots \times M$
		显而易见，对于$M > 1$，有$M! < M^M$。
3. 第三步：严格证明（利用斯特林公式或极限）  
	1. 使用了级数收敛的必要条件来证明极限为0。
		考察级数$\sum_{n=1}^{\infty} \frac{n!}{n^n}$，利用 #比值判别法   [[比值审敛法vs极限审敛法]]
	2. $\lim_{n \to \infty} \frac{a_{n+1}}{a_n} = \lim_{n \to \infty} \frac{(n+1)!}{(n+1)^{n+1}} \cdot \frac{n^n}{n!} = \lim_{n \to \infty} \frac{n+1}{n+1} \cdot (\frac{n}{n+1})^n = \lim_{n \to \infty} \frac{1}{(1+\frac{1}{n})^n} = \frac{1}{e} < 1$   
	3. 因为级数收敛，所以通项趋于0，即$\lim_{M \to \infty} \frac{M!}{M^M} = 0$     
		1. 意味着$M!$是$M^M$的高阶无穷小（$M! = o(M^M)$）
	4. 根据大O记号的定义，若$f(n) = o(g(n))$，则$f(n) = O(g(n))$必然成立   [[斯特林公式]] 
4. 因为$M! = O(M^M)$，代回$M=\log n$，得$[\log n]! = O(n^{\log \log n})$。答案为正确  
-   渐进符号的误区（ #取对数陷阱 ）   
	- 图片重点强调了一个错误推理：**不能简单地通过两边取对数来判断$\Theta$关系**。
    *   错误逻辑：$\ln f(n) = \Theta(\ln g(n)) \implies f(n) = \Theta(g(n))$。
    *   反例：$f(n)=n^2, g(n)=n^3$。
        $\ln(n^2) = 2\ln n = \Theta(\ln n)$
        $\ln(n^3) = 3\ln n = \Theta(\ln n)$
        但是$n^2 \neq \Theta(n^3)$
	1.  **结论**：取对数后同阶，原函数不一定同阶；原函数同阶，取对数后一定同阶（需满足一定条件）。 
- 衍生  
	- 改问 $\Theta$ 关系（图片第二张的内容）
		-  **题目**：$[\log n]! = \Theta(n^{\log \log n})$ 是对还是错？  
		- **分析**：
		    由斯特林公式，$M! \approx \sqrt{2\pi M}(\frac{M}{e})^M$。
		    而$M^M = M^M$。
		    两者相除：$\frac{M!}{M^M} \approx \frac{\sqrt{2\pi M}}{e^M}$。
		    当$M \to \infty$时，该极限趋于0。
		    因此，$M!$的增长速度严格慢于$M^M$，它们不是同阶的。
		*   **答案**：**错误（False）**。
	- 比较 $n!$ 与 $2^n$ 或 $n^n$  
		- 常见排序：$1 < \log n < \sqrt{n} < n < n \log n < n^2 < 2^n < n! < n^n$。
		*   考点：$n! = O(n^n)$ 是成立的，但 $n^n = O(n!)$ 是不成立的。  
	* 函数变换技巧  
		* 题目可能变为比较 $f(n) = n^{\sqrt{n}}$ 和 $g(n) = 2^n$
		* 解法：两边取对数。
		    $\log f(n) = \sqrt{n} \log n$
		    $\log g(n) = n$
		    因为 $\sqrt{n} \log n = o(n)$，所以 $f(n) = o(g(n))$，即 $f(n) = O(g(n))$。
	 (注意：虽然不能由 对数同阶推 原函数 同阶，但如果对数后一个是另一个的 #高阶无穷小 ，则原函数的大小关系是确定的)
	-  级数收敛性与复杂度的关系  
		-  如图片中利用$\sum \frac{n!}{n^n}$收敛来证明$\lim \frac{n!}{n^n} = 0$。这在考研数学或高级算法分析中可能作为证明题出现



![[Pasted image 20251122140553.png]]
[[Pasted image 20251118183421.png]]

- 将给定的递归式$T(n)=128T\left(\frac{n}{2^{2023}}\right)+\sqrt[290]{n}$与 #主定理 的标准形式$T(n)=aT(n/b)+f(n)$进行对应  
1.  确定参数 
    *   $a=128$（子问题的数量）
    *   $b=2^{2023}$（子问题规模缩小的倍数）
    *   $f(n)=\sqrt[290]{n}=n^{\frac{1}{290}}$（合并子问题所需的非递归时间代价）
2. 计算 #临界指数$\log_b a$   
	1. 需要比较$n^{\log_b a}$与$f(n)$的增长速度。首先计算$\log_b a$
$$\log_b a=\log_{2^{2023}}128$$
	利用对数性质，将$128$写成$2^7$：
    $$\log_{2^{2023}}(2^7)=\frac{7}{2023}$$
    对分数进行约分（$2023\div7=289$）：
    $$\frac{7}{2023}=\frac{1}{289}$$
    所以，递归部分的复杂度项为$n^{\log_b a}=n^{\frac{1}{289}}$。

3. 比较$n^{\log_b a}$与$f(n)$  
	1.  递归部分项：$n^{\frac{1}{289}}$
	    *   非递归部分项：$f(n)=n^{\frac{1}{290}}$  
	2. 比较指数大小：因为$289<290$，所以分母越小数值越大，即$\frac{1}{289}>\frac{1}{290}$。
	    这意味着$n^{\log_b a}$的增长速度**多项式级地快于**$f(n)$（即存在$\epsilon>0$，使得$f(n)=O(n^{\log_b a-\epsilon})$  
4. 得出结论  
	1. 根据主定理的第一种情况（Case 1），当递归树叶子节点的开销占主导地位时，总的时间复杂度由$n^{\log_b a}$决定。
        $T(n)=\Theta(n^{\log_b a})=\Theta(n^{\frac{1}{289}})$   


- 衍生 
	- 指数与对数的运算陷阱  
		- 考题常使用$a=8,b=4$或类似本题的$a=2^x,b=2^y$的形式，考察学生是否能熟练化简$\log_{2^y}2^x=\frac{x}{y}$。
	    *   *例*：若$T(n)=8T(n/4)+n$，则$\log_4 8=1.5$，比较$n^{1.5}$与$n^1$，得$T(n)=\Theta(n^{1.5})$。  
	* 情况 2 的扩展（Polylog 情况）  
		* 题目是$T(n)=2T(n/2)+n\log n$。
		    此时$\log_b a=1$，而$f(n)=n\log n$。这不属于情况3（因为$n\log n$并不比$n^1$多项式级地大，只大了一个对数因子）。这属于情况2的扩展形式，此时$k=1$，答案为$T(n)=\Theta(n\log^2 n)$ 
	- 多项式级差距  
		- 主定理要求$f(n)$和$n^{\log_b a}$之间必须有**多项式级**的差距（即差一个$n^\epsilon$）  
		- 考点  
			- 如果$T(n)=2T(n/2)+n/\log n$。此时$n^{\log_b a}=n$，而$f(n)=n/\log n$。虽然$f(n)<n$，但并不是多项式级的小（只差对数因子），此时**不能直接用主定理**，通常需要用递归树法求解  
	- #正则性条件   
		- 情况3中，除了比较大小，还必须验证$af(n/b)\le cf(n)$。虽然在考试中给定的多项式$f(n)$通常都满足该条件，但在严格的数学证明题中，忽略这一步会被扣分 
	- 主定理失效的情况 
		- 如果$f(n)$不是多项式形式（例如$f(n)=2^n$或$f(n)=\sin n$），或者$b$不是常数，主定理可能无法直接套用，需要回归到 递归树 或 代换法 进行分析  
 


![[Pasted image 20251122140600.png]]
[[Pasted image 20251118183428.png]]
这道题考察的是**算法时间复杂度分析**，特别是涉及 #位运算 和 #双重指数增长 的情况
1. 第一步：分析变量的变化规律  
	1. **变量$j$的变化**：
	    初始值为$1$。每次循环执行`j <<= 1`，即$j = j \times 2$。
	    第$k$次迭代时（从第0次开始算），$j$的值为$2^k$。
	*   **变量$i$的变化**：
	    初始值为$1$（即$2^0$）。
	    每次循环执行`i <<= j`，即$i = i \times 2^j$。在指数运算中，底数相同相乘，指数相加。
	    这意味着$i$的指数部分会累加当前的$j$值。
2. 第二步：列表找规律  
	1. 设$E_k$为第$k$次迭代后$i$的指数，即$i_k = 2^{E_k}$。、
		*   **第1次循环后 ($k=1$)**:
		    $j$从$1$变为$2$。
		    $i$左移$1$位：$i = 2^0 \times 2^1 = 2^1$。
		    指数和：$1 = 2^0$。
		*   **第2次循环后 ($k=2$)**:
		    $j$从$2$变为$4$。
		    $i$左移$2$位（此时$j$在上一轮末尾变成了2）：$i = 2^1 \times 2^2 = 2^3$。
		    指数和：$1+2 = 2^0 + 2^1$。
		*   **第3次循环后 ($k=3$)**:
		    $j$从$4$变为$8$。
		    $i$左移$4$位：$i = 2^3 \times 2^4 = 2^7$。
		    指数和：$1+2+4 = 2^0 + 2^1 + 2^2$。
		*   **第$k$次循环后**:
		    $i$的指数是等比数列求和：$2^0 + 2^1 + \dots + 2^{k-1}$。
		    根据等比数列求和公式，指数为$2^k - 1$。
		    所以，$i$的值为$2^{(2^k - 1)}$。
3. 第三步：建立不等式求解$k$  
	1. 循环终止条件是$i < n$。当$i \ge n$时循环结束。
		我们将$i$的表达式代入：
		$2^{(2^k - 1)} \approx n$
		
		两边同时取以2为底的对数（$\log_2$）：
		$2^k - 1 \approx \log_2 n$
		
		忽略常数$-1$，再次两边取以2为底的对数：
		$k \approx \log_2(\log_2 n)$
		
		因此，循环次数$k$与$n$的关系是$O(\log \log n)$
- 衍生 
	- 修改变量更新方式
		- 如果将代码改为：
```cpp
for (int i = 1, j = 1; i < n; j++) // j 每次只加 1
    i <<= j; // i = i * 2^j
```
*   **分析**：此时$j$是线性增长$1, 2, 3, \dots, k$。
	*   $i$的指数是等差数列求和：$1 + 2 + \dots + k = \frac{k(k+1)}{2} \approx \frac{k^2}{2}$。
	*   方程：$2^{k^2/2} < n \Rightarrow \frac{k^2}{2} < \log n \Rightarrow k^2 < 2\log n \Rightarrow k < \sqrt{\log n}$。
	*   **复杂度**：$O(\sqrt{\log n})$。
1. 退化为普通指数增长    
	1. 如果将代码改为：
```cpp
for (int i = 1; i < n; )
    i <<= 1; // i = i * 2
```
*   **分析**：$i$的变化为$1, 2, 4, 8, \dots, 2^k$。
*   方程：$2^k < n \Rightarrow k < \log n$。
*   **复杂度**：$O(\log n)$。

**变体 3：考察空间复杂度**
*   题目可能会问该函数的空间复杂度。由于只使用了常数个辅助变量（$i, j, n$），空间复杂度为$O(1)$。

**变体 4：数据溢出 (Overflow)**
*   题目中特意说明“假定字宽足够，运算不会溢出”。如果作为简答题，可能会问：当$n$很大时，这段代码在实际计算机（如32位或64位int）中会发生什么？
*   **答案**：$i$增长极快（双重指数级），只需极少的迭代次数（$k=5$时，$i \approx 2^{31}$；$k=6$时，$i \approx 2^{63}$）就会超出整数表示范围导致溢出。

**总结**：
看到`i`的增长速度非常快（比如每次变成原来的平方，或者像本题一样指数级左移），答案通常都包含$\log \log n$。





![[Pasted image 20251118183443.png]]![[Pasted image 20251118183450.png]]