![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=13&rect=27,578,572,809|826历年真题解析-数据结构篇（包括算法题）-12.15, p.13]]

![[Pasted image 20251214105500.png]]

题目考察的是  #二叉树的遍历与重构      #重构二叉树  
1. 题目给出了两个序列：
	1.  **中序序列 (Inorder Traversal)**：$\{D, B, A, E, C, F\}$
	2.  **层次序列 (Level-order Traversal)**：$\{A, B, C, D, E, F\}$
2. 推导逻辑如下  
	1. **第一步：确定整棵树的根节点**
		*   由**层次序列**的性质可知，序列的第一个元素一定是树的**根节点**。
		*   所以，根节点是$A$。
		
		**第二步：划分左右子树**
		*   在**中序序列**中找到根节点$A$的位置：$\{D, B, \mathbf{A}, E, C, F\}$。
		*   根据中序遍历“左-根-右”的规则：
		    *   $A$左边的$\{D, B\}$属于**左子树**的节点集合。
		    *   $A$右边的$\{E, C, F\}$属于**右子树**的节点集合。
		
		**第三步：确定左子树的结构**
		*   左子树包含节点$\{D, B\}$。
		*   回到**层次序列**，检查这两个节点谁先出现。在层次序列$\{A, \mathbf{B}, C, \mathbf{D}, E, F\}$中，$B$比$D$先出现。
		*   层次遍历越靠前，层级越高。因此，$B$是左子树的根（即$A$的左孩子）。
		*   再看**中序序列**$\{D, \mathbf{B}, ...\}$，$D$在$B$的左边，说明$D$是$B$的**左孩子**。
		
		**第四步：确定右子树的结构**
		*   右子树包含节点$\{E, C, F\}$。
		*   回到**层次序列**，检查这三个节点谁先出现。在层次序列中，$C$最先出现（在$E, F$之前）。
		*   因此，$C$是右子树的根（即$A$的右孩子）。
		*   再看**中序序列**$\{..., E, \mathbf{C}, F\}$：
		    *   $E$在$C$左边 $\rightarrow$ $E$是$C$的**左孩子**。
		    *   $F$在$C$右边 $\rightarrow$ $F$是$C$的**右孩子**。
	1. ![[Pasted image 20251214105917.png]] 

- 衍生 
	-  先序 + 中序 $\rightarrow$ 重构二叉树 (最常见)
		- **方法**：先序第一个定根，中序分左右。
		*   **公式**：若先序为$Pre=\{Root, L_{1} \dots L_{n}, R_{1} \dots R_{m}\}$，中序为$In=\{L_{1} \dots L_{n}, Root, R_{1} \dots R_{m}\}$。
		*   **考点**：递归分割。
	* 后序 + 中序 $\rightarrow$ #重构二叉树  
		* **方法**：后序最后一个定根，中序分左右。
		*   **注意**：看后序序列时要从后往前看。
	* 先序 + 后序 $\rightarrow$ 能否唯一确定二叉树？(易错点)  
		* **答案**：**一般不能**。
			*   **原因**：先序和后序都只能提供“根”的信息，无法区分左右子树。
			*   **例子**：若先序为$\{A, B\}$，后序为$\{B, A\}$。
			    *   情况1：$A$是根，$B$是$A$的左孩子。
			    *   情况2：$A$是根，$B$是$A$的右孩子。
			    *   这两种情况的先序和后序完全一样，因此无法唯一确定。
				*   **特殊情况**：如果是**真二叉树**（Full Binary Tree，每个节点度为0或2），则可以唯一确定
	- 已知二叉树构造森林/树 (树与二叉树的转换)   
		- **考点**： #左孩子右兄弟表示法  
			- **规则**：二叉树的左指针指向原树的长子，右指针指向原树的下一个兄弟。
			*   考试中可能会给你一个二叉树的图，让你把它还原成对应的普通树或森林。
	- #线索二叉树  
		-  **考点**：利用空指针域（$n$个节点的二叉树有$n+1$个空指针）来存放前驱或后继指针。
		*   题目可能会问：在中序线索二叉树中，节点$X$的后继是谁？或者画出线索化后的图。
- **总结：**
	这道题的根本在于利用**层次序列找根**，利用**中序序列分左右**，只要掌握这个逻辑，无论序列如何组合（只要包含中序），你都能轻松解题。

![[Pasted image 20251214105801.png]]
[[Pasted image 20251119101710.png]]
1. 题目的解题逻辑： #递归模拟  
	1. 手动模拟 #函数调用栈
		1.   **确定遍历类型**：根据给出的递归代码顺序判断是前序、中序还是后序。
		2.  **画出路径**：在深度为4的树上，按照递归逻辑手指画线。
		3.  **记录顺序**：每当代码执行到“访问/打印结点”这一行时，记下该结点。
2. 三种主要遍历方式
	这是最基础也是最核心的考点，根据根节点$N$被访问的时机不同来命名：
	
	*   **前序遍历 (Pre-order Traversal)**
	    *   顺序：根 $\to$ 左 $\to$ 右
	    *   逻辑公式：$N\to L\to R$
	    *   代码特征：`print(root); traverse(root.left); traverse(root.right);`
	
	*   **中序遍历 (In-order Traversal)**
	    *   顺序：左 $\to$ 根 $\to$ 右
	    *   逻辑公式：$L\to N\to R$
	    *   代码特征：`traverse(root.left); print(root); traverse(root.right);`
	
	*   **后序遍历 (Post-order Traversal)**
	    *   顺序：左 $\to$ 右 $\to$ 根
	    *   逻辑公式：$L\to R\to N$
	    *   代码特征：`traverse(root.left); traverse(root.right); print(root);`
3. 二叉树的性质（针对题目中“深度为4”）
	若树的深度为$h$（本题中$h=4$）：
	*   **最大结点数**：满二叉树的结点总数为$2^h-1$。对于深度为4的树，最多有$2^4-1=15$个结点。
	*   **第i层最大结点数**：第$i$层最多有$2^{i-1}$个结点。  
- 衍生 
	- 已知两种遍历序列，求二叉树或第三种序列  
		- **规则**：必须要有**中序遍历**，再加上前序或后序中的一种，才能唯一确定一棵二叉树。
			*   **公式逻辑**：
			    *   **前序**的第一个元素是**根**。
			    *   **后序**的最后一个元素是**根**。
			    *   利用根在中序序列中的位置，将序列切分为左子树集合和右子树集合，递归求解。
	- 结点性质计算 (叶子结点 vs 度为2的结点)  
		- 题目可能会问遍历过程中涉及到多少个叶子结点。
			*   **核心公式**：对于任意非空二叉树，如果叶子结点（度为0）数为$n_0$，度为2的结点数为$n_2$，则有：
				* $n_0=n_2+1$  
	* 递归转非递归 ( #栈的应用)  
		* 题目给的是递归算法，但有时会考“如果用非递归方式实现，栈的变化情况”。
			* **原理**：递归的本质是系统栈。非递归实现需要手动维护一个**栈      
			* **考点**：询问在访问到某个特定结点时，栈中保存了哪些元素（通常是该结点的所有祖先结点）  
	- 满二叉树与完全二叉树的下标关系
		如果题目给的是数组存储的完全二叉树：
		*   对于编号为$i$的结点：
		    *   左孩子编号为$2i$
		    *   右孩子编号为$2i+1$
		    *   父节点编号为$\lfloor i/2 \rfloor$

 ![[Pasted image 20251214105755.png]]
 [[Pasted image 20251119101716.png]]

- 推导的核心在于：即便二叉树的左右结构有歧义，其节点在层序遍历中的相对顺序是固定的   
1. 确定根节点
	*   **先序遍历（Pre-order）**的规则是：根$\rightarrow$左$\rightarrow$右。序列的**第一个**元素一定是根节点。   [[树的重构]]  
	*   **后序遍历（Post-order）**的规则是：左$\rightarrow$右$\rightarrow$根。序列的**最后一个**元素一定是根节点。 
	*   设先序序列为$Pre$，后序序列为$Post$。我们可以立刻确定$Pre[0]$（或$Post[n-1]$）是当前层的根。
2. 确定子树与分支情况
	解析中提到的核心步骤是比较先序的第二个节点和后序的倒数第二个节点：
	*   令$Pre[1]$为先序序列中根节点后的第一个节点。
	*   令$Post[n-2]$为后序序列中根节点前的第一个节点。
3. 会出现两种情况：
	
	**情况A：$Pre[1]\neq Post[n-2]$**
	这意味着根节点**同时拥有左子树和右子树**。
	*   $Pre[1]$是左子树的根。
	*   $Post[n-2]$是右子树的根。
	*   此时结构是确定的，我们可以根据这两个根节点在序列中的位置，把数组切割成“左子树区间”和“右子树区间”，然后递归处理。
	
	**情况B：$Pre[1]=Post[n-2]$**
	这意味着根节点**只有一个子树**（或者说只有一个孩子节点）。
	*   **结构上的歧义：** 我们不知道这个孩子是“左孩子”还是“右孩子”。
	*   **层序遍历的唯一性：** 无论这个孩子是左还是右，在层序遍历中，它都会紧跟在根节点之后出现。
	    *   例如：根$A$，子$B$。
	    *   若$B$是左孩子，层序为$AB$。
	    *   若$B$是右孩子，层序仍为$AB$。
	*   因此，虽然树的形状不唯一，但**层序序列是唯一的**。
**结论：**
	由于我们可以递归地确定每一层有哪些节点，以及它们属于哪个父节点，因此可以构建出唯一的层序遍历序列。所以题目中的说法是错误的。
- 衍生 
	- 什么情况下“先序+后序”能唯一确定二叉树结构？  
		- **答案：** 当二叉树中**没有度为1的节点**时（即也就是每个非叶子节点都有两个孩子，或者称为真二叉树  
			- **原理：** 回顾上面的推导，歧义只发生在“只有一个孩子”的情况（即$Pre[1]=Post[n-2]$）。如果题目保证任意节点要么没孩子，要么有两个孩子，那么一旦发现$Pre[1]$和$Post[n-2]$不同，就是两个孩子；如果相同，那就是叶子节点（递归结束）。不存在“单孩子”的模糊地带 
	- 计算二叉树的形态数量  
		- 如果给定先序和后序序列，问能够还原出多少种不同结构的二叉树？
			*   **方法：** 统计在递归过程中，出现“单孩子情况”（即$Pre[1]=Post[n-2]$）的次数，记为$k$。
			*   **公式：** 不同的二叉树总数为$2^k$。
				*   **解释：** 每遇到一个度为1的节点，它可以是左孩子也可以是右孩子，有2种选择。$k$个这样的节点就有$2^k$种组合。
总结
	题目中的$( \times )$是因为混淆了“结构唯一性”和“ #层序序列唯一性”。
	*   **结构：** 先序+后序 $\nrightarrow$ 唯一结构。
	*   **层序：** 先序+后序 $\rightarrow$ 唯一层序序列。


　
　![[Pasted image 20251214105749.png]]
　[[Pasted image 20251119101723.png]]

这道题目主要考察的是树的层序遍历（ #广度优先搜索BFS ）以及树的节点性质   [[层序遍历]] 
1. 在树的 #层序遍历 过程中，辅助队列中存储的是当前层未处理完的节点以及下一层刚刚加入的节点。队列中的每一个元素，实际上代表了一个“正在延伸的分支”。由于树中每一个分支最终至少都会延伸到一个叶子节点（Leaf Node），且这些分支在当前层是互不相交的，因此：**队列中元素的数量，永远不会超过树中总叶子节点的数量。**  
	1. 即**满二叉树**（或完全二叉树）的情况，因为这种树最“宽”，队列容易达到最大值。 
		1.  假设这棵树是一棵满二叉树，所有的叶子节点都在最底层。
		2.  题目已知叶子节点数量$n_0=2018$。
		3.  在层序遍历到达倒数第二层时，队列里会有一定数量的父节点。在满二叉树中，每个父节点有两个孩子。
		4.  为了凑够2018个叶子，倒数第二层需要有$2018/2=1009$个节点。
		5.  **入队出队过程**：当倒数第二层的这$1009$个节点依次出队时，每个节点会将它的$2$个孩子（也就是叶子节点）入队。
		6.  **极限情况**：虽然是一个进两个，但在最极端的情况下（例如上一层刚好出完，下一层全部进入），队列里最多也就是容纳所有的下一层节点。因为下一层全是叶子，共$2018$个，所以队列最大规模就是$2018$。

　- 衍生
	　- [[二叉树的性质]]   二叉树的性质公式推导    
		　- 最常考的计算题。对于任意非空二叉树，如果叶子节点数为$n_0$，度为2的节点数为$n_2$，则有：
				$n_0=n_2+1$
			*   **推导**：设总节点数为$n$，边数为$e$。
			    *   按节点度数求和：$n=n_0+n_1+n_2$
			    *   按边数求和（除根节点外每个节点对应一条入边）：$n=e+1$
			    *   总边数等于所有节点度数之和：$e=n_1+2n_2$
			    *   联立可得：$n_0+n_1+n_2=n_1+2n_2+1\Rightarrow n_0=n_2+1$
	- 完全二叉树的性质
		- 考点通常涉及节点数与树高的关系。
		*   **节点数与高度**：高度为$h$的完全二叉树，节点数$n$的范围是 $2^{h-1}\le n\le 2^h-1$。
		*   **由节点数求高度**：$h=\lfloor\log_2n\rfloor+1$。
		*   **叶子节点位置**：完全二叉树的叶子节点只能出现在最下两层。
		*   **判断节点$i$的性质**（根节点索引为1）：
			*   左孩子：$2i$
			*   右孩子：$2i+1$
			*   父节点：$\lfloor i/2\rfloor$
	- 遍历所需的辅助空间复杂度  
		- **层序遍历 (BFS)**：空间复杂度取决于**树的最大宽度**（最大叶子节点数），最坏情况（满二叉树）为$O(n)$，更精确地说是$O(n_0)$。
		*   **前/中/后序遍历 (DFS, 递归或非递归)**：空间复杂度取决于**树的高度**（栈的深度）。
		    *   最坏情况（单支树，退化为链表）：$O(n)$。
		    *   最好情况（完全二叉树）：$O(\log_2n)$。
	- **问题**：一棵度为$m$的树中，若有$n_1$个度为1的节点，$n_2$个度为2的节点，...，$n_m$个度为$m$的节点，问叶子节点$n_0$是多少？
		**解答**：利用**总度数=总节点数-1**的关系。
				$n_0=1+\sum_{i=1}^m(i-1)n_i$
			(即：$n_0=1+0\cdot n_1+1\cdot n_2+2\cdot n_3+\dots+(m-1)n_m$)　

　![[Pasted image 20251214105740.png]]
　[[Pasted image 20251119101730.png]]  [[树的重构]] 

- 很多同学通常记住了“**先序+后序不能确定唯一的二叉树**”这个结论，因此看到这道题容易直接判断为“不能”。但题目的陷阱在于它问的不是“二叉树结构是否唯一”，而是“**层次遍历序列是否唯一**”  
1. 假设一棵二叉树的根节点为$root$。
	1.  **先序序列**的规则是：$root \rightarrow LeftSubtree \rightarrow RightSubtree$。
	2.  **后序序列**的规则是：$LeftSubtree \rightarrow RightSubtree \rightarrow root$。
2. 可以通过以下步骤重构层次关系：
	
	1.  **确定根节点：** 先序序列的第一个元素一定是$root$。
	2.  **确定子树范围：**
	    *   查看先序序列中$root$后面的第一个节点，记为$x$。$x$必然是$root$某个子树的根节点。
	    *   在后序序列中找到这个$x$。根据后序遍历的特点，从后序序列开始一直到$x$的部分，构成了以$x$为根的子树。
	3.  **判断子节点情况（关键点）：**
	    *   **情况A（有两个子树）：** 如果在后序序列中，$x$之后、$root$之前还有其他节点，说明$root$有两个孩子。$x$所在的子树是左子树，剩余部分是右子树。此时结构唯一，左孩子在右孩子之前，层次遍历顺序确定（先$x$，再右孩子）。
	    *   **情况B（只有一个子树）：** 如果在后序序列中，从开始到$x$涵盖了除$root$以外的所有节点，说明$root$只有一个孩子$x$。
	        *   **结构的二义性：** 我们不知道$x$是$root$的左孩子还是右孩子。
	        *   **层次遍历的唯一性：** 无论$x$是左孩子还是右孩子，它都是$root$在下一层的**唯一**后继节点。在层次遍历的队列中，紧接着$root$被取出的就是$x$。因此，这一层的遍历顺序固定为$x$。
	
	**归纳：**
	由于每一层节点的**相对顺序**（即：左兄弟必然在右兄弟之前，且单个孩子必然排在父节点之后、下一层其他节点之前）完全由先序和后序序列中的“分组”逻辑确定，而“左/右悬挂”的区别并不改变节点所在的**层数**，也不改变它在队列中相对于其他分支节点的**先后次序**。

**结论：** 先序和后序序列可以确定唯一的层次遍历序列。
- 衍生 
	- 什么情况下先序+后序能确定唯一的二叉树？  
		- **答案：** 当该二叉树中**没有度为1的节点**（即所有非叶子节点都有左右两个孩子）时，也就是所谓的**真二叉树**（Full Binary Tree）。
			**理由：** 此时不存在“不知道是左孩子还是右孩子”的歧义情况。 
	- 根据遍历序列求其他序列  
		- **问题：** 给定先序序列为$ABC$，后序序列为$CBA$，求层次遍历序列。
			**解析：**
			*   根是$A$。
			*   先序中$A$后是$B$，后序中$B$前是$C$。这里要注意，$Pre: A, B, C$; $Post: C, B, A$。
			*   $Pre$中$A$后是$B$，意味着$B$是$A$的子树根。
			*   $Post$中$B$涵盖了$C$。即$C$是$B$的子树。
			*   结构链为：$A \rightarrow B \rightarrow C$。
			*   无论$B$是$A$的左/右，$C$是$B$的左/右，层次遍历顺序永远是$A, B, C$。
	- 将二叉树转换为树/森林  [[树和森林的存储结构]]  [[森林的性质]]
  
　![[Pasted image 20251214105732.png]]
　[[Pasted image 20251119101735.png]]

- [[哈夫曼树]]的构建原则是“**权值越小，离根节点越远（深度越大）；权值越大，离根节点越近（深度越小）**”  
- 具体推导步骤 
	1.  **构建过程回顾**：哈夫曼算法在构建树时，每次都会从当前的节点集合中选择两个**权值最小**的节点进行合并，生成一个新的父节点。
	2.  **层级变化**：
	    *   **小权值节点**：因为被最早选中并合并，它们会成为新节点的子节点，随着后续不断的合并操作，它们会被不断地“压”到树的底部。因此，权值越小的节点，其深度通常越大。
	    *   **大权值节点**：因为权值大，它们会在很晚的时候才被选中参与合并，或者一直作为合并后的结果留在上层。因此，权值越大的节点，离根节点越近，深度越小。
	3.  **对比题目**：题目中说“深度更小的节点（离根近）的权值**小于**深度更大的节点（离根远）的权值”。
	    *   这与上述性质完全相反。如果离根近的节点权值反而比底层的还小，说明在这个节点还是叶子节点或者中间节点的时候，它应该早就被优先合并并“沉”到树的下层去了，而不可能留在上层。
	4.  **结论**：因此，该陈述违反了哈夫曼树“最优性”和“贪心策略”的性质，判断为**错（$\times$）
- 衍生
	- 节点数量计算  
		- 对于一个度为$m$的哈夫曼树（通常考二叉，即$m=2$）：
			*   **只有度为0和度为2的节点**：哈夫曼树中不存在度为$1$的节点。
			*   **节点关系公式**：
			    设叶子节点（度为0）个数为$n_0$，总节点数为$N$。
			    则有：$N=2n_0-1$
			    *解释：如果有$n_0$个叶子节点，构建过程中需要进行$n_0-1$次合并，每次合并产生$1$个新节点，所以总节点数$=n_0+(n_0-1)$。
	- WPL 的计算  
		- 通常给出一组权值，让你构造哈夫曼树并计算 WPL。
		*   **技巧**：除了画树计算$\sum w_k l_k$外，还有一个简便算法：**WPL等于构建过程中所有非叶子节点的权值之和**。
		    例如权值$\{1,2,3,4\}$：
		    1. 合并$1,2$得$3$，当前WPL累加$3$。
		    2. 剩余$\{3,3,4\}$，合并$3,3$得$6$，当前WPL累加$3+6=9$。
		    3. 剩余$\{4,6\}$，合并$4,6$得$10$，当前WPL累加$9+10=19$。
		    最终$WPL=19$。
	- #哈夫曼树的非唯一性   
		-   **形状不唯一**：当集合中有权值相同的节点时，选择哪两个合并是任意的，或者左右子树的顺序互换，都会导致树的形态不同。
		*   **WPL唯一**：尽管树的形状可能不同，但最小的$WPL$值是唯一的。
	* #哈夫曼树编码长度问题 
		*   **最短平均码长**：哈夫曼编码能保证加权平均码长最短。
		*   **特定判断**：高频字符（权值大）对应短编码，低频字符（权值小）对应长编码。题目中那个判断题其实就是在考这个点。
	
　
![[Pasted image 20251214105721.png]]！！![[Pasted image 20251119101938.png]]
　#最优前缀编码  [[前缀编码]] [[哈夫曼编码]]   
1. **最优前缀编码的定义**：通常指通过哈夫曼算法构造的编码树，其核心指标是**带权路径长度（WPL）**最小。只要树的$WPL$保持不变且仍满足前缀性质（即叶子节点对应字符），它依然是最优前缀编码。  
 2. **WPL计算公式**：$WPL=\sum_{i=1}^{n}w_il_i$，其中$w_i$是第$i$个叶子节点的权值，$l_i$是该节点的深度（路径长度）。 
 3. #反例  
	 *   假设我们有两个叶子节点$A$和$B$，它们的权值相同，即$w_A=w_B=w$。
	*   假设$A$在深度$l_1$，$B$在深度$l_2$，且$l_1\neq l_2$（不同深度）。
	*   交换$A$和$B$的位置后，它们的新深度变为$l_2$和$l_1$。
	*   **交换前的贡献**：$w \cdot l_1 + w \cdot l_2 = w(l_1+l_2)$
	*   **交换后的贡献**：$w \cdot l_2 + w \cdot l_1 = w(l_2+l_1)$
	*   **结论**：总的$WPL$完全没有变化。既然$WPL$没有变大，这棵树依然保持了“最优”的性质。
	图片展示了一棵简单的树： 
	-  根节点权值为3。
	*   左子树：叶子节点（权值1），深度为1。
	*   右子树：内部节点（权值2），下挂两个叶子节点（权值均为1），深度为2。
	*   如果我们把**深度为1的那个权值为1的叶子**与**深度为2的任意一个权值为1的叶子**互换，树的结构变了，但所有叶子的权值都是1，无论怎么换，总的$WPL$都是$1\times 1+1\times 2+1\times 2=5$。性质未被破坏。
	

- 衍生  
	- 哈夫曼树的非唯一性  
		- 本题的直接推论。哈夫曼树的形态**不唯一**，但最小的$WPL$值是**唯一**的。
			*   **原因 1**：左右子树可以交换（例如编码0和1互换），不影响$WPL$。
			*   **原因 2**：如本题所示，如果有权值相同的节点，处理顺序不同或位置互换可能导致树的结构不同（深度可能不同），但$WPL$相同。
	* #固定长度编码vs可变长度编码   
		* 哈夫曼编码是**可变长度编码**。
		*   对比**固定长度编码**（如ASCII），哈夫曼编码能显著压缩数据，压缩率取决于字符频率的分布不均匀程度。频率分布越不均匀，压缩效果越好。
	


　![[Pasted image 20251214105708.png]]
　[[Pasted image 20251119101944.png]]


**推导逻辑：**
要证明一个“必然”发生的事情是错的，只需要举出一个 #反例 即可。
*   **正常情况：** 如果交换的是两个**权值不同**的子树，且让大权值的节点深度变深、小权值的节点深度变浅，那么编码成本确实会增加（破坏了哈夫曼树“权值大路径短”的原则）。
*   **反例情况（即解析图示）：** 如果被交换的两个子树（或叶子节点）的**权值相同**，即使它们处于不同的深度，交换位置后，总的带权路径长度（WPL）是**不变**的。


- 衍生 
	- #计算WPL  
		- 给出一组权值，要求构造哈夫曼树并计算$WPL$。
			*   **技巧：** 除了用定义公式$\sum w_k l_k$计算外，还有一个简便算法：**WPL 等于哈夫曼树中所有非叶子节点的权值之和**。
		    例如权值$\{1, 3, 5, 7\}$，构造过程中的中间节点和为$4, 9, 16$，则$WPL=4+9+16=29$（假设最后根节点是$16$）。
	- 前缀编码  
		- 哈夫曼编码是一种前缀编码。
			*   **定义：** 没有任何一个字符的编码是另一个字符编码的前缀。
			*   **考法：** 为什么哈夫曼编码能保证解码无歧义？因为字符只出现在叶子节点上，没有节点是另一个节点的祖先，所以路径编码不会重叠。
	* 哈夫曼树的构造过程 
		* 给定序列，问哪种合并不可能发生，或者问第三次合并后的权值是多少。
		*   **核心逻辑：** 每次必须从当前森林中选取**权值最小**的两棵树进行合并  
	* 相同权值的影响  
		* 题目可能会问：
			“若一组权值构建的哈夫曼树结构唯一，则说明这组权值必然互不相同。” —— **正确**。
			（反之，如果有相同权值，结构通常不唯一，正如本题所示）。




　
　
　![[Pasted image 20251214105700.png]][[Pasted image 20251119101952.png]]
- 这其实是一组 **斐波那契数列**  当权值符合斐波那契数列规律时，构造出的哈夫曼树是“最偏”的（即树的高度最高，也就是编码最长）。　
	具体构造步骤如下
1.  **第1步**：从集合中取出最小的两个数 $0$ 和 $1$。
    *   合并得到新节点：$0+1=1$。
    *   当前集合变为：$\{1, 1, 2, 3, 5, 8, 13, 21\}$（注意：这里新生成的 $1$ 和原有的 $1$ 再次成为最小的两个数）。
    *   *此时包含“0”的节点深度为 1。*
2.  **第2步**：取出最小的两个数 $1$（新生成的）和 $1$（原有的）。
    *   合并得到新节点：$1+1=2$。
    *   当前集合变为：$\{2, 2, 3, 5, 8, 13, 21\}$。
    *   *此时包含“0”的节点深度增加 1，变为 2。*
3.  **第3步**：取出最小的 $2$（新生成的）和 $2$（原有的）。
    *   合并得到：$2+2=4$。
    *   当前集合变为：$\{3, 4, 5, 8, 13, 21\}$。
    *   *此时包含“0”的节点深度变为 3。*
4.  **第4步**：取出最小的 $3$ 和 $4$。
    *   合并得到：$3+4=7$。
    *   当前集合变为：$\{5, 7, 8, 13, 21\}$。
    *   *此时包含“0”的节点深度变为 4。*
5.  **第5步**：取出最小的 $5$ 和 $7$。
    *   合并得到：$5+7=12$。
    *   当前集合变为：$\{8, 12, 13, 21\}$。
    *   *此时包含“0”的节点深度变为 5。*
6.  **第6步**：取出最小的 $8$ 和 $12$。
    *   合并得到：$8+12=20$。
    *   当前集合变为：$\{13, 20, 21\}$。
    *   *此时包含“0”的节点深度变为 6。*
7.  **第7步**：取出最小的 $13$ 和 $20$。
    *   合并得到：$13+20=33$。
    *   当前集合变为：$\{21, 33\}$。
    *   *此时包含“0”的节点深度变为 7。*
8.  **第8步**：取出最后剩下的 $21$ 和 $33$。
    *   合并得到根节点：$21+33=54$。
    *   *此时包含“0”的节点深度变为 8。*
**结论**：
	频率为 $0$（以及第一个频率为 $1$）的节点位于树的最底层。经过 8 次合并，其路径长度（编码长度）为 **8**。

　![[Pasted image 20251214105646.png]]
　[[Pasted image 20251119101958.png]][[Pasted image 20251119102005.png]]

这道题的核心在于计算出**平均每个字符所需的编码长度**，然后乘以总字符数。  

1. 第一步：构造哈夫曼树  
	1. 给定的频率为：$\{1,1,2,3,5,8,13,33,36\}$。这几乎是一个斐波那契数列，会导致生成一棵极度不平衡的树（如题目提供的第二张图所示）。
		
		1.  取最小的$1,1$，合并得$2$。集合变为$\{2,2,3,5,8,13,33,36\}$。
		2.  取最小的$2,2$，合并得$4$。集合变为$\{3,4,5,8,13,33,36\}$。
		3.  取最小的$3,4$，合并得$7$。集合变为$\{5,7,8,13,33,36\}$。
		4.  取最小的$5,7$，合并得$12$。集合变为$\{8,12,13,33,36\}$。
		5.  取最小的$8,12$，合并得$20$。集合变为$\{13,20,33,36\}$。
		6.  取最小的$13,20$，合并得$33$。集合变为$\{33,33,36\}$。（注意：这里新生成的33和原有的33再次成为最小的两个）
		7.  取最小的$33,33$，合并得$66$。集合变为$\{36,66\}$。
		8.  取最小的$36,66$，合并得$102$。构造完成。

**第二步：确定每个字符的编码长度（深度）**
根据第二张图的树结构，或者是上面的合并过程，我们可以确定每个权值对应的叶子节点到根节点的距离（即编码长度）：
*   权值$1$：深度$8$
*   权值$1$：深度$8$
*   权值$2$：深度$7$
*   权值$3$：深度$6$
*   权值$5$：深度$5$
*   权值$8$：深度$4$
*   权值$13$：深度$3$
*   权值$33$：深度$2$
*   权值$36$：深度$1$

**第三步：计算加权平均编码长度**
我们需要计算整棵树的带权路径长度（WPL），并除以总权值（总频率），得到平均每个字符的位数。

*   **总频率（分母）**：
    $1+1+2+3+5+8+13+33+36=102$
*   **带权路径长度之和（分子）**：
    $1\times8+1\times8+2\times7+3\times6+5\times5+8\times4+13\times3+33\times2+36\times1$
    $=8+8+14+18+25+32+39+66+36=246$
*   **平均编码长度**：
    $\frac{246}{102}=\frac{41}{17}$

**第四步：计算总期望位数**
题目要求的字符串长度为$2023$，因此总比特位数期望值为：
$2023\times\frac{41}{17}$
因为$2023=17\times119$，所以计算为：
$119\times41=4879$

- 衍生 
	- #压缩比的计算    
		- 题目可能会让你比较**哈夫曼编码**与**定长编码**（ASCII或等长二进制）。
			*   **计算方法**：
			    *   **定长编码**：9个字符至少需要$\lceil\log_29\rceil=4$位。总长度为$2023\times4=8092$位。
			    *   **压缩比**：$(1-\frac{4879}{8092})\times100\%$。
	- 最坏情况（斐波那契数列）**
		*   本题的权值设计非常接近斐波那契数列。当权值为斐波那契数时（$F_n$），构建出的哈夫曼树是**最不平衡**的（也就是深度最深的），这种树被称为斐波那契树。这是一类典型的考察树深度的极端情况。


　
　![[Pasted image 20251214105638.png]]
　[[Pasted image 20251119102012.png]]
- 要得出共有24种编码方案，我们需要分析哈夫曼树构造过程中的“分支”选择（即当权值相同时如何选择）以及左右子树交换带来的不同编码。  
1. 初始状态
	给定字符出现的频率（权值）集合为$\{1, 2, 3, 3\}$。设这四个字符分别为$x(1), y(2), z(3), w(3)$。 
2.  第一步合并 
	1. 选取权值最小的两个节点$x$和$y$进行合并。
		新节点权值：$1+2=3$。
		当前森林中的权值集合变为：$\{3_{(x+y)}, 3_z, 3_w\}$。
		此时，我们有三个权值为3的节点：一个是新生成的组合节点（包含$x,y$），另外两个是原始的叶子节点$z$和$w$。
3.  第二步合并（关键分歧点）  
	1. 需要从这三个权值为3的节点中选出两个进行合并。这里产生了两种不同的拓扑结构情况：  
		1. **情况一：合并两个原始叶子节点$z$和$w$**
		    *   合并$z$和$w$，生成新节点权值为$3+3=6$。
		    *   剩余节点：$3_{(x+y)}$和$6_{(z+w)}$。
		    *   **最后一步**：合并这两个节点，根节点权值为9。
		    *   **结构特征**：这是一棵比较“对称”的树，形态为$((1,2),(3,3))$。
		    *   **计算方案数**：
		        *   这棵树有3个非叶子节点（根节点、$(1,2)$的父节点、$(3,3)$的父节点）。
		        *   哈夫曼编码中，每个非叶子节点的左右分支交换（例如左0右1还是左1右0）都会产生不同的编码。
		        *   方案数 = $2^3=8$种。
		2.  **情况二：合并组合节点$3_{(x+y)}$和其中一个原始叶子节点（$z$或$w$）**
		    *   这里有两个选择：选$z$或者选$w$。因为$z$和$w$是不同的字符，所以这会导致两种不同的逻辑组合。
		    *   假设选$z$：合并$(x+y)$与$z$，生成新节点权值为$3+3=6$。
		    *   剩余节点：$6_{((x+y)+z)}$和$3_w$。
		    *   **最后一步**：合并这两个节点。
		    *   **结构特征**：这是一棵“瘦高”的树，形态为$(((1,2),3),3)$。
		    *   **计算方案数**：
		        *   **选谁在底层**：我们可以让$z$参与深层合并，也可以让$w$参与深层合并。这是$2$种不同的节点分配方式。
		        *   **左右交换**：这种结构的树同样有3个非叶子节点。
		        *   对于每种节点分配方式，左右交换带来的方案数 = $2^3=8$种。
		        *   总计 = $2 \times 8 = 16$种。
		3. 总方案数
			将两种情况相加： $Total = 8 + 16 = 24$
　
　![[Pasted image 20251214131551.png]]  
　[[Pasted image 20251119102027.png]][[Pasted image 20251119102035.png]]
　
　
　**推导过程：**
我们可以采用**自底向上**的贪心策略来构造这棵树，为了让轻祖先的数量最大化，我们要让每一层的节点规模尽可能小，刚好满足轻节点的临界条件。

1.  **叶子节点**：设路径最底部的节点（非祖先）规模为$1$。
2.  **第1个轻祖先**：要是轻节点，父节点规模至少是子节点的2倍。最小规模为$1\times2=2$。
3.  **第2个轻祖先**：最小规模为$2\times2=4$。
4.  **第3个轻祖先**：最小规模为$4\times2=8$。
    ...
    以此类推，轻祖先的规模序列呈现$2^k$的增长趋势。

我们需要找到满足$2^k<2024$的最大整数$k$，且要考虑到根节点和路径顶端的情况。让我们列出满足条件的祖先规模序列：
$2,4,8,16,32,64,128,256,512$。
这里一共有**9**个数。

**为什么不是10个？**
如果继续往下推：
下一级是$512\times2=1024$。这个节点可以是轻祖先吗？它的父节点即根节点必须至少有$1024\times2=2048$个节点。
但题目限制总节点数为$2024$，因为$2048>2024$，所以规模为$1024$的节点无法成为轻节点（因为它的父节点不够大，无法满足$2倍$条件）。
　
　
　
　![[Pasted image 20251119102040.png]]![[Pasted image 20251119102049.png]]