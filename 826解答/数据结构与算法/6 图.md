![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=18&rect=27,730,572,807|826历年真题解析-数据结构篇（包括算法题）-12.15, p.18]]![[Pasted image 20251214145429.png]] 

简单来说，Dijkstra 算法的核心思想是“贪心策略”，它要求图中**不能存在负权边**。题目中明确指出了“权值都为正整数”，这满足了非负权值的条件，因此使用 Dijkstra 算法是完全可行且正确的

[[Dijkstra 算法]] 

- 衍生 
	- 负权边问题 (高频考点)  
		- **考点**：如果题目将条件改为“权值包含负整数”，Dijkstra 还能用吗？
			*   **答案**：**不能**。Dijkstra 无法处理带有负权边的图。因为它的贪心策略假设“路径越走越长（或不变）”，一旦有负权边，前面确定的“最短路径”可能会被后面经过负权边的“绕道”路径更新从而变短，导致结果错误。
			*   **对策**：如果存在负权边（但无负权回路），需要使用**Bellman-Ford算法**或**SPFA算法** 
	*  算法时间复杂度
		-  **朴素实现**：使用数组或邻接矩阵寻找最小距离节点。
		    复杂度为$O(n^2)$，其中$n$是节点数。
		*   **堆优化实现**：使用二叉堆（优先队列）来寻找最小距离节点。
		    复杂度为$O(m\log n)$，其中$m$是边数。
		    *   **衍生题**：如果图是稠密图（边很多，接近$n^2$），朴素写法更好；如果是稀疏图，堆优化更好。
	- 多源最短路径  
		- **考点**：如果题目问的是“求任意两点间的最短路径”？
		*   **对策**：虽然可以运行$n$次 Dijkstra，但更典型的解法是**Floyd-Warshall算法**。
		    Floyd 算法的核心状态转移方程为：$D_{ij}=\min(D_{ij},D_{ik}+D_{kj})$。
		    时间复杂度为$O(n^3)$，可以处理负权边，但不能处理负权回路。
	- 与最小生成树 (MST) 的混淆    
		- **考点**：Dijkstra 算法与 **Prim 算法**（普里姆算法）长得非常像。
		*   **区别**：
		    *   **Dijkstra**：关注的是从**源点**到各点的累加距离，$dist[v]$表示源点到$v$的路径长度。
		    *   **Prim**：关注的是节点到**生成树集合**的最小距离，$lowcost[v]$表示$v$与当前树相连的最小边权。
- 只要记住：**Dijkstra必须无负权，处理负权用Bellman-Ford，全源最短路用Floyd**，即可应对此类选择题。  


![[Pasted image 20251214145440.png]]
[[Pasted image 20251119102402.png]]

- 证明 **Prim算法（普里姆算法）** 的正确性。图片中的解析是通过 #反证法 结合 #割性质 推导出来的
1. 建立模型与假设
	*   **算法行为：** Prim算法总是维护一个已确定的顶点集合$U$，并在$U$和剩余顶点集合$V-U$之间寻找一条权值最小的边（称为轻量级边）。
	*   **反证法假设：** 假设Prim算法选择的这条权值最小的边$uv$（其中$u\in U$，$v\notin U$），**不**包含在某个最小生成树（MST）$T$中。  
2. 构造冲突（利用树的性质）  
	1.  **连通性：** 既然$T$是一棵生成树，那么它必须连通所有的点。虽然$T$中没有直接连接$u$和$v$的边$uv$，但在$T$中必然存在一条从$u$到$v$的路径。
	*   #跨越割 （The Cut）： 这条路径起于$U$中的$u$，终于$V-U$中的$v$，因此这条路径上必然有一条边$st$跨越了集合$U$和$V-U$（即$s\in U$，$t\notin U$）。
3. 比较与交换（关键步骤）  
	1.    **权值对比：** 根据Prim算法的规则，我们在当前步骤选择了$uv$，说明$uv$是连接$U$和$V-U$的所有边中权值最小的。因此，我们可以确定边权关系：$w(uv)\le w(st)$。
		*   *注：题目解析为了简化，假设权值互异，则有$w(uv)<w(st)$。
		*   **生成新树$T'$：** 我们可以构造一个新的图$T'$。做法是：把$uv$加入$T$，同时把$st$从$T$中删去。
		    *   加入$uv$：由于$T$是树，加入一条边会形成唯一的环（图c）。
		    *   删除$st$：删除环上的边$st$（图d），环被打破，但图依然保持连通，且顶点数不变，边数依然是$|V|-1$。因此，$T'$也是一棵生成树。
4. 得出矛盾 
	*   计算总权重：$T'$的总权重$W(T')=W(T)+w(uv)-w(st)$。
	*   因为$w(uv)<w(st)$，所以$W(T')<W(T)$。
	*   **结论：** 我们构造出了一棵比假设中的“最小生成树$T$”权重更小的生成树$T'$。这与“$T$是最小生成树”的前提矛盾。
	*   **推论：** 假设不成立，Prim算法选择的边$uv$必然包含在最小生成树中。

- 衍生 
	- #最小生成树的唯一性  
		- **考点：** 如果图中所有边的**权值互不相同**，那么最小生成树是**唯一**的。如果有相同的边权，MST可能不唯一，但最小的总权值是唯一的 
	- #环性质 
		- **定义：** 与割性质相对。在一个环中，权值最大的边**一定不**在最小生成树中（如果是严格最大）。
		*   **应用：** 用来判断某条边是否一定*不*属于MST。  

![[Pasted image 20251214145448.png]]
[[Pasted image 20251119103442.png]]
- 图论算法中深度优先搜索（DFS）边分类的经典考题  
1. （1）关于后向边  
	-   **观察代码：** 在 `switch(status(u))` 语句中，查看 `case DISCOVERED` 分支。
	*   **逻辑：** 当前顶点为$v$，正在考察其邻居顶点$u$。如果$u$的状态是 `DISCOVERED`（已被发现但尚未访问完毕，即处于递归栈中），说明$u$是$v$的**祖先**。
	*   **结论：** 此时边$(v,u)$是从后代指向祖先的边，因此标记为**后向边 (BACKWARD)**。
2. （2）关于前向边 
	*   **观察代码：** 查看 `default` 分支（对应 `case VISITED`，即$u$已访问完毕）。
	*   **逻辑：** 当$u$处于 `VISITED` 状态时，边$(v,u)$可能是前向边或跨边。代码中使用三元运算符 `dTime(v) < dTime(u) ? FORWARD : CROSS` 进行判断。
	    *   $dTime$表示顶点的被发现时间（开始访问的时间戳）。
	    *   若$dTime(v)<dTime(u)$，说明祖先$v$比后代$u$更早被发现，且存在直接相连的边$(v,u)$，但$u$是通过其他路径先被访问完的。
	*   **结论：** 试图从当前顶点$v$进入处于 `VISITED` 状态的$u$，且$v$比$u$更早被发现（即$dTime(v)<dTime(u)$），此时$(v,u)$标记为**前向边 (FORWARD)**。
[[边的分类（DFS）]] 

- 衍生 
	- #环的检测  
		*   **问题：** 如何判断一个有向图是否存在环？
		*   **答案：** 在 DFS 过程中，如果发现了**后向边**，则图中一定存在环。
		*   **数学描述：** 存在边$(v,u)$且$u$处于 `DISCOVERED` 状态。
	- 拓扑排序  
		- **问题：** 什么样的图可以进行拓扑排序？DFS 如何实现？
		*   **答案：** 有向无环图 (DAG) 才能进行拓扑排序。即 DFS 过程中**不包含后向边**。
		*   **实现：** 按顶点被标记为 `VISITED` 的时间顺序的**逆序**（即完成时间 $fTime$ 从大到小）排列即为拓扑序列。
	- 时间戳的性质
		- **问题：** 给定两个节点$u$和$v$的时间戳区间$[dTime(u),fTime(u)]$和$[dTime(v),fTime(v)]$，如何判断它们的亲缘关系？
		*   **答案：**
		    *   如果是**后向边**$(v,u)$，则区间关系为包含关系：$[dTime(v),fTime(v)]\subset[dTime(u),fTime(u)]$（祖先$u$包住后代$v$）。
		    *   如果是**前向边**$(v,u)$，则区间关系为包含关系：$[dTime(u),fTime(u)]\subset[dTime(v),fTime(v)]$（祖先$v$包住后代$u$）。
		    *   如果是**跨边**，则两个区间完全分离。
	- 无向图的 DFS  
		- **问题：** 无向图的 DFS 边有哪些类型？
		*   **答案：** 无向图只有**树边**和**后向边**。因为边是双向的，前向边和跨边在无向图的遍历逻辑中等同于已经访问过的树边或反向视角的后向边。

![[Pasted image 20251214145916.png]]
[[Pasted image 20251119103500.png]]

- 题目的陈述是：“有向图经过 DFS 后有 $k$ 条边被标记为后向边，则它 **不一定** 恰有 $k$ 个环路。”  
1. #后向边 在 DFS 过程中，如果一条边 $(u,v)$ 连接的顶点 $v$ 是 $u$ 在 DFS 树中的祖先节点（即 $v$ 已经被访问但尚未结束访问，处于递归栈中），那么这条边被称为后向边。  [[边的分类（DFS）]] 
2.  **后向边与环的关系**：每一条后向边确实至少对应一个环路。这个环路由 DFS 树上的路径（从 $v$ 到 $u$）加上后向边 $(u,v)$ 组成。
3.  **反例分析（图中的例子）**：
    *   图中有一个有向图，包含节点 $A,B,C,D$ 和边 $A\to B,A\to C,B\to D,C\to D,D\to A$。
    *   假设 DFS 的遍历顺序是 $A\to C\to D$。
    *   当遍历到 $D$ 时，发现有一条边 $D\to A$，而 $A$ 是 $D$ 的祖先（根节点），所以 $D\to A$ 是一条 **后向边**。此时后向边数量 $k=1$。
    *   此时我们发现了一个环路：$A\to C\to D\to A$。
    *   接着回溯到 $A$，继续遍历 $B$，走路径 $A\to B\to D$。此时 $D$ 已经访问完毕（黑色），所以 $B\to D$ 是一条 **横叉边（Cross Edge）** 或前向边，不是后向边。
    *   然而，图中实际上还存在另一个环路：$A\to B\to D\to A$。这个环路是由树边 $A\to B$、横叉边 $B\to D$ 和后向边 $D\to A$ 共同构成的。
4.  **结论**：虽然只有 **1** 条后向边（$D\to A$），但图中却包含了 **2** 个环路（$A-C-D-A$ 和 $A-B-D-A$）。因此，后向边的数量 $k$ 不一定等于环路的总数。

 - 衍生 
	 - 拓扑排序
		 - **考点**：一个有向图能进行拓扑排序的充要条件是什么？
		*   **答案**：该图是一个 **有向无环图 (DAG)**。
		*   **联系**：如果 DFS 过程中 **没有发现任何后向边**（即 $k=0$），则说明图中没有环，可以进行拓扑排序。
	- #环路检测   
		-   **考点**：如何判断有向图中是否存在环？
		*   **算法**：使用 DFS。如果在遍历过程中遇到任何一条后向边，则图中存在环。时间复杂度为 $O(V+E)$。  
	* #强连通分量   
		-    **考点**：如何找到图中所有的强连通分量？
		*   **算法**：**Tarjan 算法** 或 **Kosaraju 算法**。这些算法都深度依赖于 DFS 的遍历顺序（DFN 序）和回溯值（Low 值），其本质就是利用后向边构成的环路将节点“捆绑”在一起。
	-  基础环与环空间 
		- **考点**：虽然题目说 $k$ 个后向边不等于 $k$ 个环，但在无向图或特定定义下，后向边决定了“基本环”的数量。
		*   **公式**：在连通图的 DFS 树中，基本环的数量（Cycle Basis 的维度）由公式 $\nu(G)=|E|-|V|+1$ 给出。每一个后向边确实对应一个唯一的“基本环”，但图中的复杂环路往往是这些基本环的线性组合（异或和）。
	-  边的状态判定  
		- **考点**：给定 DFS 的开始时间和结束时间（例如 $d[u]$ 为发现时间，$f[u]$ 为完成时间），判断边 $(u,v)$ 的类型。
		*   **判定公式**：
		    *   **后向边**：$v$ 是 $u$ 的祖先 $\Rightarrow d[v]<d[u]<f[u]<f[v]$。
		    *   **横叉边**：$v$ 已经完成访问 $\Rightarrow d[v]<f[v]<d[u]$。


![[Pasted image 20251214145927.png]]
[[Pasted image 20251119103509.png]]
- 这道题考查的是**深度优先搜索（DFS）**与**拓扑排序**之间的内在数学关系   
1. #拓扑排序 的定义   [[拓扑排序]] 
	1.  对于有向图中的任意一条边$u\to v$，在拓扑排序的序列中，顶点$u$必须出现在顶点$v$的前面。 
2. DFS 的回溯（完成）时刻   [[顶点的度]]
	1. 在 DFS 过程中，当我们访问节点$u$时，会递归地访问它的所有邻接点（比如$v$）。
	    *   如果$u$指向$v$（即存在边$u\to v$），DFS 会先深入去处理$v$及其子孙节点。
	    *   只有当$v$及其所有后代都被访问完毕并**回溯**（Backtrack）结束后，程序才会回到$u$，最后完成对$u$的处理。
3.   **时间关系：** 因此，对于边$u\to v$，节点$v$的“完成时间”（回溯时间）一定**早于**节点$u$的“完成时间”。即$finishTime(v)<finishTime(u)$ 
4. 结论：
    *   按照**回溯的顺序**（完成时间从小到大），我们得到的是子节点在前，父节点在后（例如$v, \dots, u$）。
    *   而**拓扑排序**要求父节点在前，子节点在后（例如$u, \dots, v$）。
    *   所以，拓扑排序不仅与回溯顺序有关，而且正好是**回溯顺序的逆序**。
5. 图中右侧的“零出度算法” 
	1. 图中的右半部分（Zero Out-degree Algorithm）其实演示的就是基于 DFS 的思想。在这个算法中，当一个节点没有出度（或所有指向的子节点都已处理完）时，将其加入序列。这实际上就是记录了节点“完成/回溯”的时刻。由于最后完成的节点（源头）最后才进列表，如果把列表看作一个栈（后进先出），或者把记录下来的序列反转，就得到了拓扑排序
![[Pasted image 20251214155217.png]]

- 衍生 
	- #Kahn算法   (零入度算法)   [[Kahn算法]]
		- **题目图中左侧展示的算法**。
		*   **原理：** 维护一个“入度数组”。
		    1.  将所有入度为$0$的节点加入队列。
		    2.  当队列不为空时，取出队首节点$u$放入结果集。
		    3.  将$u$的所有邻接点$v$的入度减$1$。
		    4.  若$v$的入度变为$0$，则将$v$入队。
			*   **考点：** 这种方法生成的顺序是“被发现/处理的顺序”，而不是逆序
	* #环的检测     
		* **DFS 判环：** 如果在 DFS 过程中遇到一条边指向“灰色”节点（即正在访问但尚未回溯完成的祖先节点），说明图中存在环（Back Edge）。
		*   **拓扑排序判环：** 如果使用 Kahn 算法（零入度法）结束后，输出的顶点数小于图的总顶点数$|V|$，说明图中存在环，无法完成完整的拓扑排序。
	* 拓扑排序的的唯一性 
		*  **考点：** 拓扑排序的结果通常**不唯一**。
		*   **唯一性条件：** 如果一个有向无环图的拓扑排序是唯一的，那么该图必须包含一条**哈密顿路径**（即图中任意两个相邻排名的顶点之间都有直接相连的边，对于排序序列$v_1, v_2, \dots, v_n$，必须存在边$v_i\to v_{i+1}$）。
	-  时间复杂度
		*   无论是基于 DFS 还是基于 Kahn 算法（使用邻接表存储），拓扑排序的时间复杂度通常都是$O(|V|+|E|)$，其中$|V|$是顶点数，$|E|$是边数。  
	* #逆拓扑排序
		*   如果题目问“逆拓扑排序”（即子节点排在父节点前面），那么答案就是 DFS 的**回溯顺序**（无需逆序）。  


![[Pasted image 20251214145934.png]]
[[Pasted image 20251119103519.png]]

- 核心在于理解**DFS（深度优先搜索）的结束时间**与**拓扑排序**  
	- 题目问的是：为什么DFS的回溯顺序（即节点完成搜索的顺序）的逆序，一定是一个[[拓扑排序]]？ 
		- 我们需要抓住两个关键点：**DFS的递归特性**和**拓扑排序的定义**
1. 拓扑排序的定义  
	1. 对于有向无环图(DAG)中的任意一条边$u\to v$，在拓扑排序序列中，顶点$u$必须出现在顶点$v$之前。
2. DFS的回溯（完成）逻辑
	在DFS过程中，当一个顶点$u$的所有邻接点（即$u$指向的所有节点）都被访问并回溯完成后，顶点$u$本身才会标记为“完成”（Finished/Visited）。这对应了题目中提到的“回溯的次序”。  
3. 证明推导
	假设图中存在一条边$u\to v$。当我们对图进行DFS时，只有两种情况：
	*   **情况A（$u$先被访问）：** DFS访问到$u$，然后通过边$u\to v$递归访问$v$。根据递归栈的特性，子节点$v$必须先执行完DFS并出栈（回溯），然后父节点$u$才能完成。因此，完成时间$f[v]<f[u]$。
	*   **情况B（$v$先被访问）：** DFS先访问了$v$，并且由于图是DAG（无环），从$v$出发无法到达$u$。$v$的搜索过程会完全结束，$u$还未被发现。之后DFS才在某个时刻访问到$u$。显然，$v$早就完成了，因此完成时间依然是$f[v]<f[u]$。
	
	**结论：** 对于DAG中的任意边$u\to v$，都有$f[v]<f[u]$。这意味着，如果我们按**完成时间从大到小**（即回溯次序的逆序）排列节点，$u$一定排在$v$前面，完全符合拓扑排序的要求。
1. 图片中的解析提供了一个更直观的视角：
	*   在DFS中，**第一个完成回溯的节点**，必然是没有任何未访问邻居的节点。逻辑上，这等同于一个“出度为0”的节点（或者其所有后继都已经变成了“死”节点）。
	*   在拓扑排序中，出度为0的节点应当排在最后。
	*   因此，按照“谁先回溯谁排在后面”的逻辑（即逆序），就能得到正确的拓扑序列。
- 衍生 
	- 检测环路（DAG判定） #环的检测  [[环的检测]] 
		-    **考点：** 只有无环图（DAG）才有拓扑排序。DFS如何检测环？
			*   **解析：** 在DFS过程中，如果遇到一条边指向“正在访问中”（灰色/在递归栈中）的节点，说明存在**后向边**（Back Edge），即存在环。
			*   **公式/判定：** 若存在边$u\to v$且$v$在当前递归栈中，则非DAG。
	- #括号引理    
		- **考点：** 涉及DFS的时间戳$d[u]$（发现时间）和$f[u]$（完成时间）。
		*   **内容：** 对于任意两个节点$u$和$v$，其区间$[d[u],f[u]]$和$[d[v],f[v]]$要么完全分离，要么一个包含另一个，绝不会交叉。
		*   **应用：** 若$v$是$u$的后代，则$[d[v],f[v]]\subset[d[u],f[u]]$。这再次印证了为什么$f[v]<f[u]$。
- 通过这道题，不仅要记住“DFS逆序是拓扑排序”，更要理解背后的“父节点必须等子节点结束后才能结束”的递归逻辑。    


![[Pasted image 20251214145940.png]]
[[Pasted image 20251119103547.png]]
[[DFS生成树]] 
1.  **前提确认：** 题目指出“对无向图某一顶点$s$进行DFS”。在DFS算法中，作为起点的顶点$s$即为**DFS树的根节点(Root)**。
2.  **根节点的判定准则：** 在DFS生成树中，根节点$s$是[[关节点]]（割点）的**充要条件**是：$s$在DFS树中至少有两个子节点（即$s$至少有两条树边连向不同的子树）。
    *   *原因：* 如果根节点有两个或以上的子节点，说明这几个子树之间没有边相连（否则DFS会通过那条边直接访问另一棵子树，从而使它们合并为同一棵子树）。因此，去掉根节点后，这些子树就会断开，导致图的连通分量增加。  [[结点总数与度]] 
3.  **题目条件结合：** 题目中给出“DFS树中$s$度数为1”。
    *   在树结构中，根节点的度数等于它的子节点数量。
    *   度数为1意味着根节点$s$只有**1个子节点**。
4.  **结论：** 因为根节点$s$只有一个子节点，去掉$s$后，剩下的部分依然是一个连通的子树（或者$s$本身就是叶子节点，去掉也不影响连通性）。因此，$s$**必不为关节点**。

**综上所述，题目的陈述是正确的。**

- 衍生 
	- 非根节点的判断（计算题）  
		- 题目可能会给出一个具体的图和DFS遍历顺序，要求计算某个非根节点的$dfn$和$low$值，或者判断其是否为关节点。
			*   **关键判据：** 对于非根节点$v$，若存在子节点$u$使得$low[u]\ge dfn[v]$，则$v$为关节点。 
	* #桥（割边）的判定   #割边 #桥的判断 
		* 与关节点类似，桥是指删除该边后图不再连通的边。
		*   **关键判据：** 对于边$(u,v)$（其中$u$是$v$的父节点），若满足$low[v]>dfn[u]$，则边$(u,v)$是桥。
		*   *注意区别：* 关节点是$\ge$，桥是$>$。因为如果$low[v]==dfn[u]$，说明$v$能回到$u$本身，删除边$(u,v)$并不能断开回路（可能有重边除外），但删除顶点$u$则可能断开。
	* #双连通分量   
		* **点双连通分量：** 极大的不包含关节点的子图（任意两点间至少有两条点不重复的路径）。
		*   **边双连通分量：** 极大的不包含桥的子图（任意两点间至少有两条边不重复的路径）。
		*   **考法：** 询问一个图中有几个双连通分量，或者求缩点后的图结构。
- 总结公式速记
	*   根节点$s$是关节点 $\iff$ DFS树中$s$的子节点数$\ge2$
	*   非根节点$v$是关节点 $\iff$ $\exists u \in children(v), low[u]\ge dfn[v]$
	*   边$(u,v)$是桥 $\iff$ $low[v]>dfn[u]$ 
		

![[Pasted image 20251214145948.png]]
[[Pasted image 20251119103556.png]]
BFS 的本质是按层级向外扩展。我们可以通过 #归纳法 来理解这个过程  

1.  **初始状态**：队列中只有起点$s$，其距离$dist(s)=0$。此时队列中最大距离差为$0$。
2.  **扩展过程**：
    *   假设当前正在处理距离起点为$k$的节点。
    *   当我们从队列头部取出一个距离为$k$的节点$u$进行扩展时，其所有未被访问过的邻接点$v$将被加入队列尾部。
    *   根据 BFS 性质，这些新加入的邻接点$v$距离起点的距离必然是$dist(v)=k+1$。
3.  **队列状态**：
    *   在 BFS 的任意时刻，队列中的节点只可能来自**两个相邻的层级**：正在被处理的第$k$层，以及刚刚被发现的第$k+1$层。
    *   队列的结构会呈现为：前半部分是若干个距离为$k$的节点，后半部分是若干个距离为$k+1$的节点。
    *   随着处理的进行，第$k$层的节点不断出队，第$k+1$层的节点不断入队。当第$k$层全部处理完，队列中就只剩下第$k+1$层的节点（此时距离差为 0），紧接着开始加入第$k+2$层的节点。

**结论**：
队列中任意时刻，队首节点距离$dist_{head}$和队尾节点距离$dist_{tail}$的关系只可能是$dist_{head}=dist_{tail}$（同层）或$dist_{tail}=dist_{head}+1$（跨一层）。因此，任意两点的距离之差最大为$1$。
[[ BFS辅助队列的单调性与层次性]]  [[广度优先搜索（BFS）和深度优先搜索（DFS）]]

- 衍生 
	- 最短路径的应用（无权图） 
		-    **考点**：BFS 是求解**无权图**（或所有边权值相等）中单源最短路径的最优算法。
		*   **结论**：BFS 遍历生成的生成树即为最短路径树。对于任意顶点$v$，BFS 首次访问到$v$时经过的路径长度就是全局最短路径$dist(v)$。
	- 边的分类（BFS 树的性质）  
		- 图片右侧文字提到了“树边”和“跨边”，这是 BFS 分析中的重要概念：
		*   **树边 (Tree Edge)**：在 BFS 过程中，如果通过边$(u, v)$首次访问了$v$，则该边为树边。性质：$dist(v) = dist(u) + 1$。
		*   **跨边 (Cross Edge)**：连接两个已访问节点的边。在无向图中，跨边连接的两个顶点$u$和$v$，其层级差至多为 1。
		    *   数学表示：$|dist(u) - dist(v)| \le 1$。
		    *   **注意**：BFS 中**不存在**连接跨越两个以上层级的边（例如连接第$k$层和第$k+2$层的边是不存在的），也不存在“回边”（Back Edge，指回连到祖先的边，这在 DFS 中才存在）。
	- 空间复杂度与队列大小  
		- **考点**：BFS 的空间复杂度取决于队列的最大容量。
		*   **结论**：最坏情况下，队列可能存储图中的大多数顶点（例如星型图或完全图），空间复杂度为$O(|V|)$。 
	- 图的连通性与 #二部图判定  
		-  **连通性**：一次 BFS 可以遍历一个连通分量。如果 BFS 结束后还有未访问节点，说明图是非连通的。
		*   **二部图 (Bipartite Graph) 判定**：利用 BFS 的层次特性进行染色。
		    *   原理：将起点染为颜色 1，邻接点染为颜色 2，以此类推。
		    *   判定：如果发现边$(u, v)$且$dist(u)$和$dist(v)$处于同一层（即$dist(u) = dist(v)$），说明存在奇环，该图不是二部图。



![[Pasted image 20251214145958.png]]
[[Pasted image 20251119103808.png]]

[[求解MST的经典算法（Prim,Kruskal)]] 
- **Prim 算法（普里姆算法）：**
    *   **朴素版（未改进）：** 通常使用邻接矩阵存储，不使用堆优化。每次寻找距离生成树最近的节点需要遍历所有节点。
        *   时间复杂度：$O(n^2)$。
        *   特点：复杂度只与点数有关，与边数无关。因此，在**稠密图**（边数$e$接近$n^2$）中，它非常高效，因为它避免了像 Kruskal 那样对大量边进行排序的开销。
    *   **改进版（堆优化）：** 使用邻接表存储，并配合二叉堆（优先队列）来维护节点距离。
        *   时间复杂度：$O((n+e)\log n)$或简化为$O(e\log n)$。
        *   特点：虽然改进后的 Prim 算法也适合稀疏图，但在算法原本的定义和最经典的对比中，Prim 通常指代朴素版。

*   **Kruskal 算法（克鲁斯卡尔算法）：**
    *   核心逻辑是**按权值从小到大排序所有的边**，然后使用并查集判断是否形成环。
    *   时间复杂度：主要消耗在排序上，为$O(e\log e)$。
    *   特点：复杂度直接取决于边数$e$。在**稀疏图**（边数$e$远小于$n^2$，接近$n$）中，由于$e$很小，Kruskal 算法极其高效。

- 衍生 
	- 复杂度计算细节
		**问：** 如果使用斐波那契堆（Fibonacci Heap）优化 Prim 算法，时间复杂度是多少？
		**答：** 使用斐波那契堆优化后，Prim 算法的时间复杂度可以降低到$O(e+n\log n)$。在超大规模的稀疏图中，理论上这比二叉堆优化版$O(e\log n)$更快，但在实际工程中由于斐波那契堆常数较大且实现复杂，并不常用。
	- #并查集的时间复杂度
		**问：** Kruskal 算法中使用了并查集，其操作的时间复杂度是多少？
		**答：** 如果同时使用了**路径压缩 (Path Compression)** 和 **按秩合并 (Union by Rank)** 优化，并查集的单次操作时间复杂度近似为常数，具体为$O(\alpha(n))$，其中$\alpha$是反阿克曼函数，增长极慢（对宇宙中所有实际数据可视为小于 5）。因此 Kruskal 的瓶颈完全在于边的排序$O(e\log e)$。
	- #实际场景判断（Prim，Kruskal） 
		**问：** 现有 1000 个城市，需要铺设光缆连通所有城市。城市间已有 2000 条可选路线。应该用哪种算法？如果是 1000 个城市，任意两个城市间都可以铺设（即有约 500,000 条边），又该用哪种？
		**答：**
		1.  $n=1000, e=2000$：这是一个典型的**稀疏图** ($e \approx 2n$)，应选择 **Kruskal 算法**。
		2.  $n=1000, e \approx 500,000$：这是一个**稠密图** ($e \approx n^2/2$)，应选择 **朴素 Prim 算法**。

![[Pasted image 20251214150006.png]]
[[Pasted image 20251119103818.png]]
- Dijkstra 算法是一种基于 贪心策略 的算法。它有一个核心假设：**已经确定最短路径的节点，其距离不会再被更新变小。** 这就要求图中所有的边权必须非负。
![[Pasted image 20251214182939.png]]
  1. **图结构：**
    *   $A \to C$，权重为 $2$
    *   $A \to B$，权重为 $3$
    *   $B \to C$，权重为 $-2$

2. #Dijkstra算法 执行过程：
    1.  **初始化：** 起点为 $A$，距离 $dist[A]=0$，其他点距离无穷大。集合 $S$ (已确定最短路的点集) 为空。
    2.  **第一轮：** 从 $A$ 出发，更新邻居。$dist[B]=3$，$dist[C]=2$。
    3.  **贪心选择：** 在未进入 $S$ 的点中选择距离最小的点。此时比较 $dist[B]=3$ 和 $dist[C]=2$。显然 $C$ 最近。
    4.  **锁定 C：** 算法将 $C$ 加入集合 $S$，并**断定** $A$ 到 $C$ 的最短路径就是 $2$。**（此处发生错误）**
    5.  **第二轮：** 接下来处理 $B$。将 $B$ 加入 $S$。检查 $B$ 的邻居 $C$。
    6.  **松弛操作：** 此时发现通过 $B$ 到达 $C$ 的距离是 $dist[B] + weight(B,C) = 3 + (-2) = 1$。
    7.  **矛盾：** 虽然 $1 < 2$，但在标准的 Dijkstra 算法中，节点 $C$ 已经被标记为“已解决（Settled）”，算法通常不会回过头去更新已解决节点的后续影响，或者即使更新了 $dist[C]$，也不会再次探索从 $C$ 出发的路径（如果 $C$ 后面还有节点）。


**结论：** Dijkstra 算法输出的 $A \to C$ 最短距离是 $2$，但实际最短距离是 $1$（路径 $A \to B \to C$）。因此，**只要存在负权边，Dijkstra 算法就可能失效**，输出的不一定是最短路径。

- 负权边的破坏性
	当存在负权边时，上述单调性被破坏。即可能存在 $dist[u] + weight(u, v) < dist[u]$。这意味着哪怕我们先选择了看起来更近的节点，后来经过一条“绕远路但有负权边补偿”的路径，可能会发现更短的距离。Dijkstra 的“不回头”机制无法处理这种情况。
	
- 衍生 
	- 能够处理负权边的算法  
		- **Bellman-Ford 算法：** 可以处理带有负权边的图。它对所有边进行 $V-1$ 次松弛操作。时间复杂度为 $O(VE)$。
		*   **SPFA 算法 (Shortest Path Faster Algorithm)：** Bellman-Ford 的队列优化版本。在平均情况下很快，但在最坏情况下（特定构造的网格图）复杂度会退化为 $O(VE)$。
	* #负权环   
		* 如果图中存在一个环，其边权之和 $<0$，那么最短路径是**无解的**（或者说 $-\infty$）。因为可以在这个环里无限转圈，路径长度会无限减小。
		*   **考点：** 如何判断图中是否存在负权环？
		    *   使用 Bellman-Ford 算法：在进行 $V-1$ 次松弛后，再进行第 $V$ 次松弛。如果此时 $dist$ 数组还能更新，说明存在负权环。
	* #全源最短路径  
		* #Floyd-Warshall算法 ：  采用动态规划思想，可以处理负权边，但不能处理负权环。时间复杂度 $O(V^3)$。状态转移方程：$dp[k][i][j] = \min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])$。
		*   #Johnson算法 ： 如果想在稀疏且有负权边的图上跑全源最短路，可以使用 Johnson 算法。它先利用 Bellman-Ford 计算势能 $h(v)$，将所有边权重置为非负值 $w'(u,v) = w(u,v) + h(u) - h(v)$，然后再对每个节点运行 Dijkstra。

![[Pasted image 20251214150011.png]]
[[Pasted image 20251119103827.png]]

 **正确结论：存在拓扑排序的有向图，一定是无环的。**

**核心逻辑：**
所谓**拓扑排序**（Topological Sort），是对有向图顶点的一种线性排序。使得对于图中的任意一条有向边$(u,v)$，在排序序列中，顶点$u$一定出现在顶点$v$之前。

**为什么必须无环？**
我们用反证法来理解：
假设一个有向图包含一个环（Cycle），例如：$A \to B \to C \to A$。
如果要对这个图进行拓扑排序：
1.  因为有边$A \to B$，所以在序列中$A$必须在$B$前面。
2.  因为有边$B \to C$，所以在序列中$B$必须在$C$前面。
3.  根据传递性，$A$必须在$C$前面。
4.  但是，因为有边$C \to A$，所以在序列中$C$必须在$A$前面。

这里出现了矛盾：$A$既要在$C$前面，又要$C$在$A$前面。这在通过线性序列中是不可能实现的。因此，**如果图中有环，就不存在拓扑排序。** 反之，**如果一个图能进行拓扑排序，它必然没有环。**

这种图在计算机科学中有一个专门的术语：**DAG**
### 总结
这道题考察的是DAG（有向无环图）的定义性质。只要记住：有环必死循环，无法排序；能排序则必定无环




![[Pasted image 20251119103844.png]]



![[Pasted image 20251119103952.png]]