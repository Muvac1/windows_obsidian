![[826历年真题解析-数据结构篇（包括算法题）-12.15.pdf#page=28&rect=28,531,577,806|826历年真题解析-数据结构篇（包括算法题）-12.15, p.28]]

![[Pasted image 20251214145811.png]]
1. **核心逻辑**：
	题目要求“最多”启动多少次I/O，这意味着我们需要计算B树在**最坏情况下的高度**（即树最高、节点最稀疏的情况）。然后根据“根节点在内存中”这一条件，减去1次I/O。
2. 答案推导过程  
3. **第一步：确定B树的参数**  [[B树的定义与分支限制]]  
	*   **阶数（Order）**：$m=7$。
	*   **关键字数量**：$n=2016$。
	*   **最坏情况条件**：为了让树尽可能高，每个节点包含的关键字要尽可能少（即分支尽可能少）。
	    *   根据B树定义，除根节点外的内部节点，其子树个数最少为 $\lceil m/2 \rceil$。
    *   计算最少分支数：$\lceil 7/2 \rceil=4$。这意味着除了根节点至少有2个分支外，其他节点至少有4个分支。
4. **第二步：利用高度公式估算**
	B树最坏情况下的高度 $h$ 与关键字数 $n$ 的关系满足如下不等式（这是考研数据结构中的标准公式）：
	$n+1 \ge 2 \cdot \lceil m/2 \rceil^{h-1}$
	1. 将数值代入：
		1.  $2016+1 \ge 2 \cdot 4^{h-1}$
		2.  $2017 \ge 2 \cdot 4^{h-1}$
		3.  $1008.5 \ge 4^{h-1}$
	2. 需要找到满足这个不等式的最大整数 $h$：
		*   当 $h-1=4$ 时，$4^4=256$，满足 $1008.5 \ge 256$。
		*   当 $h-1=5$ 时，$4^5=1024$，不满足 $1008.5 \ge 1024$。
	3. 因此，$h-1$ 最大只能是4，即树的最大高度 $h=5$。
		这意味着这棵树最多有5层存放数据的节点。
5. **第三步：计算I/O次数**   #磁盘I/O模型  #文件块访问次数（磁盘IO次数） [[文件块访问次数（磁盘IO次数）]]
	*   在最坏情况下，搜索一个关键字需要访问从根节点到叶子节点的一条路径，涉及的节点数为 $h=5$。
	*   **关键条件**：题目说明“**根节点在内存中**”。
	*   因此，访问根节点不需要磁盘I/O。
	*   **总I/O次数** = 总层数 - 根节点层 = $5-1=4$。
		  -   B树是为磁盘存储设计的数据结构，树的高度直接决定了磁盘I/O的次数。
	    *   通常访问一个节点 = 1次I/O。
	    *   **考点陷阱**：注意题目是否提及“根节点常驻内存”，这会减少1次I/O。
**答案**：**(A) 4**

- 衍生 
	- **计算最小高度（最好情况）**
	    *   **问题**：同样2016个关键字，7阶B树，最少需要几次I/O？
	    *   **思路**：让每个节点分支最大化（7个分支）。
	    *   **公式**：$h_{min} = \lfloor \log_m(n+1) \rfloor + 1$ 或近似计算 $7^{h-1} \approx n$。
	    *   **计算**：$7^3=343, 7^4=2401$。所以高度为4。若根在内存，I/O为3
	- B+树的区别 
		- **考点**：B+树的所有关键字都在叶子节点，内部节点只存索引。
	    *   **题目**：B+树进行范围查询（Range Query）的优势是什么？（答：叶子节点构成了链表，适合顺序遍历）。
	    *   **题目**：B+树查找成功和失败的路径长度是否一致？（答：基本一致，都必须走到叶子节点）。
	- #节点分裂与合并   
		- **考点**：插入关键字导致节点满（$>m-1$个关键字）时，节点如何分裂？（答：中间关键字上移）。
	    *   **考点**：删除关键字导致节点过少（$<\lceil m/2 \rceil - 1$个关键字）时，如何借位或合并？  
	* 根据磁盘块大小计算阶数 $m$  
		* **题目**：给定磁盘块大小为4KB，关键字大小为KeySize，指针大小为PtrSize，求最大阶数 $m$。
	    *   **公式**：$(m \cdot \text{PtrSize}) + ((m-1) \cdot \text{KeySize}) \le \text{BlockSize}$  
* **B树最大高度（最坏情况）**：
    $h \le \lfloor \log_{\lceil m/2 \rceil}(\frac{n+1}{2}) \rfloor + 1$
    或者使用不等式：
    $n+1 \ge 2 \cdot \lceil m/2 \rceil^{h-1}$

*   **B树最小高度（最好情况）**：
    $h \ge \lceil \log_m(n+1) \rceil$

*   **阶数计算**：
    $m \cdot P + (m-1) \cdot K \le B$
    （其中 $P$ 是指针大小，$K$ 是关键字大小，$B$ 是磁盘块大小）。



![[Pasted image 20251214145804.png]]
[[Pasted image 20251119113921.png]]

- 一道关于 **B树（B-Tree）高度与I/O次数计算** 的经典题目    
1. **题目关键信息：**
	*   关键码数量 $n=2017$。
	*   B树阶数 $m=7$。
	*   **根节点常驻内存**（这是一个非常重要的陷阱条件）。
	*   目标：求一次查找**最多**进行的 I/O 操作次数。

2.  **查找 I/O 次数与树高的关系：** 在 B 树中查找一个关键字，最坏的情况是查找到叶子节点。每一次进入下一层节点都需要一次 I/O 操作（磁盘读取）。  [[B树的高度公式]]
	1. **最小高度（最好情况）**：节点全满（每个节点有 $m$ 个分支）。公式为 $h \ge \log_m(n+1)$。
    *   **最大高度（最坏情况）**：节点最稀疏。公式推导基于第 $h$ 层至少有的节点数。若树高为 $h$，则关键字总数 $n$ 满足：
	        $n+1 \ge 2 \cdot (\lceil m/2 \rceil)^{h-1}$
	1.  **最大 I/O 意味着最大高度：** 题目问“最多”进行多少次，意味着我们需要计算这棵树在最坏情况下的高度（即树最高、最稀疏的时候）。
	2.  **计算最大高度 $h$：**
	    根据 B 树的性质，若要让树最高，每个节点包含的关键字应该尽可能少。
	    *   $m$ 阶 B 树中，除根节点外，每个节点至少有 $\lceil m/2 \rceil$ 个分叉（子树），即至少有 $\lceil m/2 \rceil - 1$ 个关键字。
	    *   令 $t=\lceil m/2 \rceil$。本题中 $m=7$，所以 $t=\lceil 7/2 \rceil=4$。
	    *   B 树最大高度 $h$ 与关键字总数 $n$ 的关系满足不等式：
	        $n+1\ge 2\cdot t^{h-1}$
	    *   将数据代入：
	        $2017+1\ge 2\cdot 4^{h-1}$
	        $2018\ge 2\cdot 4^{h-1}$
	        $1009\ge 4^{h-1}$
	    *   两边取以4为底的对数：
	        $\log_4 1009\ge h-1$
	    *   因为 $4^4=256$，$4^5=1024$，所以 $\log_4 1009$ 的值约为 $4.99$（非常接近5但小于5）。
	        $4.99\ge h-1$
	        $h\le 5.99$
	    *   因为高度 $h$ 必须是整数，所以最大高度 $h=5$。
	3. **计算 I/O 次数：**
	    *   树的总高度为 5，说明查找路径上最多涉及 5 个节点。
	    *   由于题目条件指出 **“根节点常驻内存”**，因此访问根节点不需要进行磁盘 I/O。
	    *   I/O 操作次数 = 总层数 - 根节点层数 = $5-1=4$ 次。
	**结论：**
	答案选 **(D) 4**。

- 衍生 
	- #求最小I/O次数   
		-  **问题：** 同样的条件，一次查找**最少**进行多少次 I/O？
		*   **解法：** 此时需要让树尽可能矮（胖），即每个节点都塞满关键字（$m-1$ 个）。
		    利用公式 $h\ge\log_m(n+1)$。
		    $h\ge\log_7(2018)$。
		    因为 $7^3=343$，$7^4=2401$，所以 $\log_7 2018$ 约为 3.x。
		    最小高度 $h=4$。
		    扣除根节点内存访问，最少 I/O = $4-1=3$ 次。
	- 根节点不在内存  
		- **问题：** 如果去掉“根节点常驻内存”这个条件。
		*   **解法：** 直接就是树的高度。最大 I/O 为 5，最小 I/O 为 4 
	* B+ 树的区别   
		*  **问题：** 如果题目把 "B 树" 换成 "B+ 树"。
		*   **知识点：** B+ 树的所有数据都在叶子节点，非叶子节点只起索引作用。
		    *   **查找差异：** B 树可以在非叶子节点命中结束查找；**B+ 树无论如何都必须走到叶子节点**。
		    *   **扇出率：** B+ 树非叶子节点不存数据，同样大小的磁盘块能存更多关键字，因此 B+ 树通常比 B 树更矮胖，I/O 次数更少。
	- 节点分裂与合并  
		-   **问题：** 插入第 2018 个元素时，最坏情况下发生多少次分裂？
		*   **知识点：** 考察 B 树的动态维护，这通常涉及对特定树结构的具体操作分析。


![[Pasted image 20251214145758.png]]
[[Pasted image 20251119113932.png]]
[[Pasted image 20251119113938.png]]

- 非常经典的 B树 性质分析题。题目旨在考察你对B树的高度计算、节点关键字数量约束以及极限情况下的构造能力的理解 
	- #B树节点的关键字数量约束   [[B树的定义与分支限制]]
		-   根节点：至少有$1$个关键字（除非树为空），至多有$m-1$个。
	    *   非根节点：至少有$\lceil m/2 \rceil - 1$个关键字，至多有$m-1$个。
	    *   本题中 $m=20$，非根节点最少关键字为$\lceil 20/2 \rceil - 1=9$个，最多为$19$个。
	- 节点的分支（子树）数量约束 
		-   节点有 $n$ 个关键字，则必然有 $n+1$ 个子树（分叉）。
	    *   非根节点最少有$\lceil m/2 \rceil=10$个分叉。
	* 查找比较次数 
		* 题目隐含假设节点内部使用 #顺序查找 （Sequential Search）。因此，在某个节点内查找，最坏情况下的比较次数等于该节点的关键字总数。
	    *   总比较次数 = 路径上所有节点的关键字数量之和。
			1. 第一步：确定B树的高度  
				1. 给定关键字总数$N=400$，阶数$m=20$。
					根据B树高度 $h$ 的估算公式：
					$\log_m(N+1)\le h\le 1+\log_{\lceil m/2 \rceil}((N+1)/2)$
				2. 代入数值：
					*   下界：$\log_{20}(401)\approx 2.0008$，意味着高度至少超过2，即$h\ge 3$。
					*   上界：$1+\log_{10}(200.5)\approx 3.3$，意味着高度不超过3.3。
					*   结论：B树的高度$h=3$。第一层是根，第二层是中间节点，第三层是叶子节点。
			2. 第二步：构造“最坏”查找路径 
				1. 为了使比较次数最大，我们需要构造一条路径，使得这条路径上的每一个节点包含的关键字数量尽可能多（最大为$m-1=19$） 
				2. 设根节点有$k$个关键字，第二层目标节点有$19$个，第三层目标节点有$19$个。
					那么最大比较次数为：$k+19+19$。  
			3. 第三步：利用总数 $N=400$ 进行约束分析 
				1. 为了让刚才那条路径上的节点尽可能“胖”（关键字多），在关键字总数有限（只有400个）的情况下，我们需要让树中**其他所有节点尽可能“瘦”**
					1. 我们假设根节点有$k$个关键字，通过计算总关键字数来判断 $k$ 能取多大。
						1.  **根节点 (Layer 1)**：
						    *   关键字数：$k$
						    *   分叉数：$k+1$
						2.  **第二层 (Layer 2)**：
						    *   共有$k+1$个节点。
						    *   为了让查找路径最长，我们保留**1个**节点是“满”的（$19$个关键字，对应$20$个分叉）。
						    *   其余$k$个节点是“最瘦”的（每个有$9$个关键字，对应$10$个分叉）。
						    *   **Layer 2 关键字总数**：$19+9k$。
						    *   **Layer 2 总分叉数（即Layer 3的节点总数）**：$20+10k$。
						3.  **第三层 (Layer 3)**：
						    *   共有$20+10k$个节点。
						    *   同样，为了让查找路径最长，上述那个“满”的第二层节点下，只有**1个**子节点是“满”的（$19$个关键字）。
						    *   其余所有节点（包括满节点的其余$19$个孩子，以及瘦节点的所有孩子）都只放最少的关键字（$9$个）。
						    *   **Layer 3 关键字总数**：$1\times19+(20+10k-1)\times9$。即$19+(19+10k)\times9$。
						4.  **建立不等式**：
						    全树关键字总数 $\le 400$：
						    $k+(19+9k)+[19+(19+10k)\times9]\le 400$
						    $k+19+9k+19+171+90k\le 400$
						    $100k+209\le 400$
						    $100k\le 191$
						    $k\le 1.91$
		1. 第四步：得出结论
			 由于 $k$ 必须是整数：
			*   **情况 A：$k=1$**
			    *   不等式成立。
			    *   此时根节点有$1$个关键字。
			    *   最大比较路径：根($1$) -> 第二层某节点($19$) -> 第三层某节点($19$)。
			    *   总比较次数：$1+19+19=39$。
			*   **情况 B：尝试 $k=2$（验证解析中的第二张图逻辑）**
			    *   如果根节点非要放$2$个关键字，根据公式，需要的最小总字数为$100(2)+209=409$，超过了$400$。
			    *   这意味着，如果根是$2$，我们就无法在第二层和第三层同时维持“除了目标路径外全是最简，目标路径全是最大”的状态。我们需要从“最大路径”中削减一些关键字来满足总数$400$的限制。
			    *   比如，我们可能需要把第二层那个最大的$19$减小，或者把第三层的$19$减小。
			    *   解析中指出：如果$k=2$，第二层最右侧节点只能是$18$（而不是$19$），这样比较次数变成$2+18+19=39$。或者第三层减小，结果也是类似。
			    *   因此，无论如何调整，最大比较次数都无法超过**39**。
**最终答案：39** 

- 衍生  数据结构考研中B树部分的难点  
	- 高度计算  
		- **考点**：给定 $N$ 和 $m$，求B树的最大高度（每个节点关键字最少）和最小高度（每个节点关键字最多）。
	    *   **公式**：
	        *   最小高度：$h\ge\log_m(N+1)$
	        *   最大高度：$h\le\log_{\lceil m/2 \rceil}((N+1)/2)+1$
	- #B树节点分裂与合并     
		- **考点**：虽然本题是静态计算，但动态插入删除时，节点何时分裂（关键字达到$m$）、何时合并（关键字少于$\lceil m/2 \rceil - 1$）是高频考点。
	    *   **注意**：根节点的分裂是B树高度增加的唯一途径。
	- B树与B+树的区别 
		-  **考点**：如果这道题换成B+树，答案会完全不同。
	    *   B+树只在叶子节点存储数据，非叶子节点只起索引作用。
	    *   B+树的查找必须走到叶子节点，而B树可以在非叶子节点命中结束。
	- 折半查找  
		- **衍生**：本题默认节点内是**顺序查找**（比较次数为 $n$）。如果题目改为“节点内部使用**折半查找**”，那么单节点的比较次数变为 $\lfloor \log_2 n \rfloor + 1$。
	    *   **计算**：若用折半查找，满节点（19个）的查找次数是 $\lfloor \log_2 19 \rfloor + 1 = 5$ 次。总比较次数会大大减少。
	- 最少/最多关键字总数 
		- **考点**：给定高度 $h$ 和阶数 $m$，问一棵B树最少有多少个关键字？
	    *   **公式**：$N_{min} = 2\lceil m/2 \rceil^{h-1} - 1$ （除了根节点至少2个孩子，其余尽量少）。这需要熟练掌握递归推导。


![[Pasted image 20251214145744.png]]
[[Pasted image 20251119113944.png]]
- 这道题目的核心考察点在于**B树中不同类型节点的分支数（子树个数）取值范围**，特别是**根节点**的特殊性 
1. 假设这棵 B 树的阶数为$m$。    [[B树的阶数计算]]   [[B树的定义与分支限制]] 
	1.  **最大分支数：** 根据 B 树定义，任意节点最多拥有$m$个分支（子树）。
	2.  **非根节点的最少分支数：** 除根节点外的所有非叶节点，最少拥有$\lceil m/2 \rceil$个分支。
	3.  **根节点的特殊性（陷阱所在）：** 根节点如果不是叶子节点，它最少只需要拥有$2$个分支，而不需要满足$\lceil m/2 \rceil$的限制。
	**验证：**
	题目声称：$Max_{branches} \le 2 \times Min_{branches}$。
	*   如果我们将根节点考虑在内，整棵树中分支数最少的节点（非叶）的分支数为$2$。
	*   整棵树中分支数最多的节点的分支数为$m$。
	*   题目变成了判断不等式$m \le 2 \times 2$（即$m \le 4$）是否恒成立。
	
	显然，当 B 树的阶数$m \ge 5$时，这个命题就不成立了。
	
	*   **举例 ($m=5$)：**
	    *   最多分支数 = $5$。
	    *   最少分支数（根节点）= $2$。
	    *   $5 > 2 \times 2$，即$5$超过了$4$。所以题目说法错误。

- 衍生 
	- [[B树的高度公式]]  
		- 考察给定$N$个关键字和阶数$m$，求 B 树的最大高度和最小高度。
			*   **最小高度$h_{min}$：** 尽可能让每个节点分支填满（满$m$叉树）。
			    *   公式：$h_{min} \approx \log_m(N+1)$
			*   **最大高度$h_{max}$：** 尽可能让每个节点分支最少（根为2，其余为$\lceil m/2 \rceil$）。
			    *   公式：$h_{max} \le \log_{\lceil m/2 \rceil}((N+1)/2) + 1$
	- #B树节点分裂与合并    
		- **插入时分裂：** 当节点关键字数量达到$m$（即超过$m-1$）时，节点必须分裂。
			*   **删除时合并：** 当非根节点关键字数量小于$\lceil m/2 \rceil - 1$时，需要与兄弟节点借位或合并。
		    *   **考题形式：** “在 5 阶 B 树中，节点关键字最少为多少时不会发生下溢？”（答案：$\lceil 5/2 \rceil - 1 = 2$）
	- 题目可能会给出一个具体的阶数，比如 $m=5$（(3,5)-树）或 $m=3$（(2,3)-树），让你计算边界值。
		*   **例如：** 5阶 B 树，非根节点至少有几个分支？
	    *   计算：$\lceil 5/2 \rceil = 3$个分支。
- 这道题的陷阱在于**忽略了根节点下限仅为2**这一特殊规则。只要记住 B 树中“根节点最少2个孩子，其余节点最少$\lceil m/2 \rceil$个孩子”，就能轻松应对此类题目




![[Pasted image 20251214145735.png]]
[[Pasted image 20251119113950.png]]

[[伸展树]]  
	**核心结论：**
	伸展树（Splay Tree）进行$m$次连续操作（包括插入、删除、查找），在包含$n$个节点的树中，总的时间复杂度为$O(m\log n)$。因此，**单次操作的分摊（Amortized）时间复杂度**为$O(\log n)$。
1. **推导逻辑：**
	1.  **定义理解：** 题目中提到的“理想随机”其实是一个相对宽松的条件。事实上，伸展树最强大的特性在于它**不需要**输入序列是随机的。无论输入序列多么糟糕（例如有序插入导致树退化成链），伸展树通过自身的“伸展（Splaying）”操作，都能保证在长期的一系列操作中，平均每次操作的代价是对数级别的。
	2.  #势能分析法计算复杂度 （Potential Method）： 在算法导论或高级数据结构课程中，通常使用势能分析法（由Tarjan和Sleator提出）来证明。定义树的势能$\Phi$，通过计算操作前后的势能变化，可以证明任何一次伸展操作的分摊代价上限是$3\log n+1$。
	3.  **结论对应：** 因此，插入操作的分摊时间复杂度确实是$O(\log n)$，题目叙述正确。
	
- 衍生 
	- 最坏情况 vs 分摊复杂度（高频）   #伸展树的最坏时间复杂度  
		- **问题：** 伸展树单次查找的最坏时间复杂度是多少？
			*   **答案：** $O(n)$。
			*   **解析：** 伸展树不强制保持严格平衡。如果一直顺序插入$1, 2, \dots, n$，树会变成一条链。此时访问最深节点的代价是$O(n)$。但访问后该节点会变成根，树的结构会变得平衡一些，所以后续操作会变快（这也是为什么叫“分摊”复杂度）。
	- 与其他平衡树的对比  
		- **问题：** 相比于AVL树，伸展树的优缺点是什么？
		*   **答案：**
		    *   **优点：** 代码实现简单（无需维护平衡因子）；对于**局部性强**的访问模式（即某些数据被频繁访问），效率甚至高于$O(\log n)$，接近$O(1)$；节省空间。
		    *   **缺点：** 单次操作性能不稳定；**查找操作也会修改树结构**（因为要Splay到根），这导致它**不是线程安全**的，也不易于在只读介质中使用。
	- 核心操作——旋转   #伸展树的旋转操作  
		- **问题：** 伸展树将节点移至根部使用了哪几种旋转模式？
		*   **答案：** 主要有三种情况（根据当前节点$x$、父节点$p$、祖父节点$g$的位置关系）：
		    1.  **Zig** (单旋)：$p$是根节点。
		    2.  **Zig-Zig** (一字型旋转)：$x$和$p$同为左孩子或同为右孩子。需要先旋转$p$，再旋转$x$（双旋）。
		    3.  **Zig-Zag** (之字型旋转)：$x$是左孩子而$p$是右孩子，反之亦然。需要连续旋转$x$两次。
		    *   *注意：考试通常不会考具体代码，但可能会问Zig-Zig操作不仅移动节点，还能起到什么作用？（答案：将链状结构折叠，使树的高度减半，起到平衡作用）。*
	- #工作集定理   
		- **问题：** 图片中提到的$O(\log k)$对应什么性质？
		*   **答案：** 对应**静态指纹定理（Static Finger Theorem）**或**工作集定理**。如果查找的元素属于最近访问过的$k$个元素之一，那么查找时间复杂度为$O(\log k)$。这解释了为什么它适合做缓存算法（如LRU的近似实现）。
总结公式
*   单次最坏时间复杂度：$O(n)$
*   分摊（平均）时间复杂度：$O(\log n)$
*   连续$m$次操作的总时间：$O(m\log n)$

![[Pasted image 20251214145727.png]]
[[Pasted image 20251119113956.png]]

#伸展树的分摊复杂度  
- 题目的核心在于理解伸展树的**基本性能保证**与**局部性原理**之间的关系  
1. #伸展树的基本定理 Sleator 和 Tarjan 在提出伸展树时证明了，对于任何包含$n$个节点的伸展树，进行$m$次连续操作（查找、插入、删除），其总时间复杂度为$O(m\log n)$。  
	1. **结论**：这意味着，**无论访问顺序如何**（哪怕完全随机、没有任何局部性），伸展树每一操作的**分摊时间复杂度**始终保证是$O(\log n)$。
2. 题目声称“如果不具有局部性，就不能保证分摊$O(\log n)$”。实际上，**分摊$O(\log n)$是伸展树的底线
	*   如果没有局部性：性能是分摊$O(\log n)$。
	*   如果有局部性：性能会**优于**$O(\log n)$，甚至接近$O(1)$。
	- 所以，缺乏局部性并不会导致性能恶化到超过$O(\log n)$（分摊），它只是无法享受到局部性带来的额外加速而已。 
- [[工作集定理（伸展树）]] 
	**解析的逻辑是**：
	如果访问具有极强的局部性（例如我们只反复访问最近的$k$个元素，且$k$很小，远小于$n$），那么$\log k$会远小于$\log n$。在这种极端局部性的情况下，分摊复杂度会趋向于$O(1)$。
	
	解析想表达的是：局部性让它变得更快（趋近$O(1)$），但题目说“没有局部性就不能保$O(\log n)$”是错的，因为即便$k=n$（无局部性），公式退化为$O(m \log n)$，依然满足分摊$O(\log n)$。

- 衍生 
	- #局部性原理（伸展树）     
		-  **考点：**  伸展树相比于AVL树或红黑树，最大的应用优势是什么？ 
		- **时间局部性**：刚被访问过的节点，很可能再次被访问。
			*   伸展树利用了**局部性原理**。刚被访问过的节点会被旋转到根节点（Splay操作）。如果一个数据被频繁访问（热点数据），它会一直处于树的顶部，访问速度极快，接近$O(1)$。这使得它非常适合作为缓存或处理非均匀分布的访问请求。
	* 单次 vs 分摊     #伸展树均摊复杂度vs最坏复杂度 
		* 问：伸展树单次查找的最坏时间复杂度是多少？
		    *   答：$O(n)$。
		*   问：伸展树一系列操作的分摊时间复杂度是多少？
		    *   答：$O(\log n)$。
		*   *对比*：AVL树单次最坏就是$O(\log n)$。
	- 是否需要额外空间 
		-  问：伸展树节点是否需要存储平衡信息？
		    *   答：不需要。AVL需要平衡因子，红黑树需要颜色位，而伸展树只需要左右孩子指针和键值。 
	* #伸展树查找操作的副作用 
		* 问：在伸展树中查找一个已存在的元素，树的结构会改变吗？
		    *   答：会。查找操作会触发Splay，改变树的拓扑结构（将目标移至根）。这是它与AVL/红黑树最大的不同（后者的单纯查找不改变结构）。 
	- #静态最优性与动态指纹   #伸展树深度考点 
		- 如果考题很深，可能会问到 #静态最优性定理 （Static Optimality Theorem）：伸展树的性能足以通过常数因子逼近最优静态查找树的性能  [[静态最优性原理（伸展树）]]  
	- 不能保证的情况  
		- 伸展树**不能**保证每一时刻树的高度都是$O(\log n)$。树的高度在最坏情况下可以是$O(n)$  
- 这道题考察的是对**分摊复杂度**定义的理解。记住一句话：**伸展树就是为了保证分摊$O(\log n)$而设计的，局部性只是它的“加分项”，而不是“及格线”。** 

![[Pasted image 20251214145720.png]]
[[Pasted image 20251119114043.png]]

#伸展树的势能 的定义以及它在最坏情况下的上界  
1. 定义势能函数  
	1. 根据图片中的定义，对于一棵伸展树$S$，其任意节点$v$的**秩通常定义为该节点子树大小（size）的对数。即： 
		1. $rank(v)=\log(size(v))$
			1. 整棵树的**总势能**$\Phi(S)$定义为所有节点秩的总和：
				$\Phi(S)=\sum_{v \in S} rank(v)=\sum_{v \in S} \log(size(v))$
2. 寻找最大势能（最坏情况）   
	1. 为了证明势能不会超过$O(n\log n)$，我们需要考虑树在什么形态下势能最大。 
		1.  **直觉：** 树越平衡，子树的大小$size(v)$就会越小（收敛得快），势能越低；树越倾斜（变成链状），子树的大小$size(v)$就会越大，势能越高。
			*   **单链情况（Worst Case）：**
			    当伸展树退化成一条单链时，节点的子树大小分别为$1,2,3,\dots,n$（从叶子到根）。
			    此时总势能为：
			    $\Phi(S)=\sum_{i=1}^{n} \log(i)$
			    根据对数性质，$\sum \log i=\log(1 \times 2 \times \dots \times n)=\log(n!)$。
			    根据 [[斯特林公式]] ，$\log(n!) \approx n\log n$
3.  结论
	1. 因此，伸展树在最“不平衡”的单链状态下，势能达到最大值，即$O(n\log n)$。除此之外的任何形态，势能都小于这个值。所以题目表述“不可能超过$O(n\log n)$”是**正确**的。

- 衍生 
	- 均摊复杂度 vs 最坏复杂度  #伸展树均摊复杂度vs最坏复杂度  
		- 考点： 伸展树的单次操作最坏时间复杂度是多少？均摊时间复杂度是多少？
			*   **解答：** 伸展树不做严格平衡限制，单次操作（查找、插入、删除）的最坏时间复杂度是$O(n)$（对应单链情况）。但是，通过“双旋”操作，一系列$m$次操作的总时间为$O(m\log n)$，因此**均摊时间复杂度**是$O(\log n)$。
			*   **易错点：** 如果题目问“伸展树的最坏查找效率”，选$O(n)$；如果问“均摊效率”或“期望效率”，选$O(\log n)$。
	- #伸展树的旋转操作   （Zig, Zig-Zig, Zig-Zag） [[伸展树的旋转操作]]  
		- **考点：** 给定一个特定的树结构，要求画出访问某个节点后的树形变化。
			*   **核心逻辑：**
			    *   **Zig:** 简单的单旋（类似AVL），用于父节点是根的情况。
			    *   **Zig-Zig（一字型）:** 当目标节点和父节点在同一侧（都是左孩子或都是右孩子）时，**先旋父节点，再旋目标节点**（这是Splay的关键，能将链折叠，减半深度）。
			    *   **Zig-Zag（之字型）:** 当目标节点和父节点在异侧时，进行双旋（类似AVL的LR或RL旋转）。
	- [[平衡树对比]]   [[树的种类]]
		-  **AVL树：** 严格平衡，查找效率最高，但插入删除时旋转次数多，维护成本高。每个节点需要额外存储高度信息。
		*   **红黑树：** 弱平衡，查找略逊于AVL，但插入删除效率高（旋转少）。每个节点需存储颜色位。
		*   **伸展树：** **不需要存储任何平衡信息**（如高度、颜色），空间最省，代码相对简洁（虽然逻辑复杂），但常数因子可能较大。
- 总结公式
	*   总势能定义：$\Phi(S)=\sum_{v \in S} \log(size(v))$
	*   最坏势能（单链）：$\Phi(S) \approx n\log n$
	*   最好势能（满二叉树）：$\Phi(S) \approx O(n)$
	*   均摊复杂度：$O(\log n)$

![[Pasted image 20251214145714.png]]
[[Pasted image 20251119114947.png]]

1. 推导逻辑： 
	1.  伸展树（Splay Tree）的核心操作是**Splay**（伸展），即通过一系列旋转操作将原本在树中较深位置的某个节点移到根节点（Root） 
	2. 虽然 Splay 操作的长期目标是让频繁访问的节点处于靠近根的位置，从而使整棵树的**平均**（摊还）查询效率达到$O(\log n)$，但它**并不保证**在单次操作后树的高度一定会降低，也不像 AVL 树那样严格维持树的高度平衡 
2. 具体来说：
	1.  **被访问节点**：深度变为$0$（成为根）。
	2.  **其他节点**：为了把被访问节点“顶”上去，原本在路径上的父节点、祖父节点等会被“挤”下去，导致这些节点所在的子树深度增加。
	3.  **整体高度**：如果树的“重”部分（深度最深的那条分支）恰好挂在被旋转下去的节点上，那么整棵树的高度甚至可能**增加**。
-  解析特别提到了`zig/zag`（单次旋转），这是 Splay 操作的最后一步（当被访问节点的父节点是根节点时）。在这种情况下，如果原根节点的另一侧子树非常深，旋转后原根节点变为新根的孩子，那条深子树的路径长度就会加$1$，从而导致树高增加
1. 为什么树高可能增加？（数学/结构解释） 
	我们以题目图片中的**Zig（单旋）**为例说明高度增加的情况：
	
	假设当前树的根节点是$r$，我们要访问其左孩子$v$。
	*   **旋转前：**
	    *   根节点是$r$。
	    *   $r$的右子树为$Z$。假设$Z$是一条非常长的链，深度为$h$。
	    *   整棵树的高度为$1+h$（根$r$到$Z$的最底端）。
	
	*   **旋转后（Zig操作）：**
	    *   $v$变成新的根节点。
	    *   $r$变成了$v$的**右孩子**。
	    *   原来的右子树$Z$依然挂在$r$的右边。
	    *   现在到达$Z$最底端的路径变成了：$v \to r \to Z \dots$
	    *   整棵树的高度变成了$1+(1+h) = h+2$。
	- **结论：** 在这个单旋例子中，树的高度从$h+1$增加到了$h+2$。因此，题目中说“高度不一定降低”，甚至“可能增高”是完全正确的。
- 衍生  
	- 时间复杂度分析 
		- 单次操作的最坏时间复杂度是$O(n)$（例如树退化成链表，访问最底端节点）。
	    *   但是，一系列$m$次操作的**摊还时间复杂度（Amortized Time Complexity）**是$O(m\log n)$，即平均每次操作是$O(\log n)$。
	    *   考点：**Splay 树不保证单次最坏情况，但保证长期平均性能。**
	- 与其他平衡树的对比 [[平衡树对比]] 
		-  **AVL 树 / 红黑树：** 严格或松散地限制树高，单次查找最坏$O(\log n)$。需要存储平衡因子或颜色位。
	    *   **Splay 树：** 不限制树高，无需额外存储空间（不需要存平衡因子），代码更容易实现，且对“数据局部性”有天然优化（热点数据查得快）。
	- #伸展树的旋转操作   
		- **考点：** 在 Zig-Zig 情况下，必须**先旋转父节点，再旋转当前节点**。如果像普通 BST 那样只旋转当前节点两次，Splay 树的摊还复杂度证明就不成立了。
	  -  #势能分析法   
		  - 这是证明 Splay 复杂度的高阶考点。利用势能函数$\Phi(T) = \sum \log(\text{size}(x))$来证明摊还代价。
	- 应用场景 
		- 实现缓存（Cache）、频繁查询特定数据集的场景、或者实现主要用于合并和分裂操作的数据结构（如 Link-Cut Tree 的辅助树） 


![[Pasted image 20251119120829.png]]

答案推导基于二叉树的性质，特别是关于节点度数    [[二叉树结点度的性质]]  
1. **理解“度”（Degree）：** 在数据结构（二叉树）的考题中，节点的“度”通常指**出度**（即该节点拥有子节点的数量）。
    *   **偶数度**：意味着节点的度数只能是$0$或$2$。
    *   也就是说，树中不存在度为$1$的节点（即不存在只有一个孩子的节点）。这被称为**正则二叉树**（Regular Binary Tree）或**满二叉树**（Full/Strict Binary Tree，注意国内教材定义可能不同，这里指$n_1=0$的情况）。

2.  **理解“高度”与“边”：**
    *   题目指出“最深的叶节点需要经过$11$条边才能到达树根”。
    *   设树根在第$1$层，经过$11$条边意味着该叶节点在第$12$层。
    *   或者直接用高度$h$表示边的数量，即$h=11$。

3.  **构造最少节点数：**
    *   为了使节点数最少，我们需要让树尽可能“瘦长”，但在每一层为了延伸深度，必须至少有一个节点作为父节点去生出下一层的节点。
    *   由于限制了**所有节点都是偶数度**，这意味着任何一个非叶子节点必须同时拥有**左孩子**和**右孩子**（度为$2$）。你不能只生一个孩子来增加深度。
    *   **构造策略**：每一层我们只选一个节点让它拥有两个孩子（延伸出下一层），而让另一个孩子直接成为叶子节点不再生长。
    *   **计算**：
        *   第$0$层（根节点）：$1$个节点。
        *   第$1$层（经过$1$条边）：根节点必须生$2$个孩子。新增$2$个节点。
        *   第$2$层（经过$2$条边）：第$1$层的$2$个节点中，选$1$个生孩子（必须生$2$个），另$1$个停止生长。新增$2$个节点。
        *   ...
        *   第$11$层（经过$11$条边）：第$10$层的节点中选$1$个生$2$个孩子。新增$2$个节点。
    *   **数学规律**：对于高度为$h$（边数）的此类二叉树，最少节点数$N$满足公式：
        $N=2h+1$
    *   代入$h=11$：
        $N=2\times11+1=23$

- 衍生 
	- #二叉树节点的分类  
		*   $n_0$：度为$0$的节点（叶子节点）。
	    *   $n_1$：度为$1$的节点（只有一个孩子的节点）。
	    *   $n_2$：度为$2$的节点（有两个孩子的节点）。
	- 核心性质公式  [[二叉树的性质]]
		- **节点总数**：$N=n_0+n_1+n_2$
	    *   **边数关系**：$N=B+1$（节点数等于边数加1）。同时边数$B=n_1+2n_2$。
	    *   **重要性质**：对于任意非空二叉树，叶子节点数总是比度为2的节点数多一个，即：
	        $n_0=n_2+1$
	        *(本题中由于$n_1=0$，总节点数$N=n_0+n_2=(n_2+1)+n_2=2n_2+1$。因为要达到11条边的深度，路径上必须有11个父节点，即$n_2=11$，所以$N=2\times11+1=23$)*。
	- 特殊二叉树定义  
		-  #正则二叉树 ：$n_1=0$。本题描述的就是这种树。
	    *   **伸展树 (Splay Tree)**：一种自平衡二叉搜索树。虽然题目提到了它，但本题只考察了其静态结构性质（偶数度），与其动态操作（旋转）无关。这属于“红鲱鱼”（干扰信息）。 
	- 求最多节点数  
		- 如果条件不变（深度为$h$的 #正则二叉树 ），求**最多**有多少个节点？
		    *   这就变成了**完美二叉树**（Perfect Binary Tree）。
		    *   公式：$N=2^{h+1}-1$（若$h$为边数）。
		    *   例如本题$h=11$，最多节点为$2^{12}-1=4095$。
	- 一般二叉树的最值 
		- 如果去掉“所有节点都是偶数度”的限制，求深度为$h$的二叉树最少有多少个节点？
		    *   那就是单链表结构（每一层只有一个节点）。
		    *   公式：$N=h+1$。
		    *   答案就是$11+1=12$。
	- $n_0$与$n_2$的关系应用  
		- 题目可能给出总节点数$N=100$，且该树为正则二叉树（无度为1节点），求叶子节点数。
	    *   解法：$n_0+n_2=100$且$n_0=n_2+1$ $\implies$ $2n_2+1=100$ $\implies$ $n_2=49.5$（不为整数，说明不存在这样的正则二叉树）。

![[Pasted image 20251214145654.png]]
[[Pasted image 20251119120836.png]]

- 这道题考察的是 **Splay Tree（伸展树）** 的核心性质以及 **分摊复杂度（  
1. 对于任意一个包含$n$个节点的 Splay Tree，进行$m$次连续操作（查找、插入、删除），其总时间复杂度上界为$O(m\log n)$ 
	1. 因此，无论访问序列长什么样（由随机、有序还是没有任何规律），**分摊到每一次操作的时间复杂度始终是$O(\log n)$  
		*   **没有局部性时**：Splay Tree 的表现退化为普通平衡树的水平，分摊复杂度为$O(\log n)$。
		*   **有局部性时**：Splay Tree 的表现会优于$O(\log n)$，甚至接近$O(1)$（这就是图片解析中提到的情况）。
2. **结论**：局部性（Locality）是 Splay Tree 能够**超越**$O(\log n)$表现的加分项，而不是维持$O(\log n)$底线的必要条件。即使没有局部性，它依然能保证分摊$O(\log n)$。 

- 衍生 
	- 最坏情况 vs. 分摊情况  
		- **问题**：Splay Tree 单次操作的最坏时间复杂度是多少？
		*   **答案**：$O(n)$。
		    *   *解释*：如果树退化成一条链，访问叶子节点需要遍历所有节点。注意与 AVL 树的单次最坏$O(\log n)$区分。
	- Splay Tree 与 AVL/红黑树的对比  
		- **问题**：相比于红黑树，Splay Tree 有什么优势和劣势？
		*   **答案**：
		    *   **优势**：
		        1.  无需额外存储空间（如颜色位或高度）。
		        2.  对具有**局部性**的访问序列表现更优（缓存热点数据）。
		        3.  实现相对简单（核心只有旋转）。
		    *   **劣势**：
		        1.  单次操作性能不稳定（最坏$O(n)$）。
		        2.  **查询操作也会改变树结构**（即使是读操作也需要旋转），这意味着它在多线程环境下难以做到无锁并发，且对于只读存储介质不友好。
	- 特定的定理（工作集定理/静态最优性定理）  
		- **问题**：图片解析中的$O(m\log k)$体现了什么定理？
		*   **答案**：**工作集定理（Working Set Theorem）**。
		    *   它指出在$m$次访问中，如果某个元素$x$是第$t_j$个不同被访问的元素，那么访问它的分摊成本是$O(\log t_j)$。简单来说，访问最近频繁使用的$k$个元素的代价是$O(\log k)$。
	- #伸展树的旋转操作   
		- **问题**：在将节点$x$旋转到根的过程中，如果$x$是父节点$p$的左孩子，$p$是祖父节点$g$的左孩子（一字型排列），应该采用什么旋转方式？
		*   **答案**：**Zig-Zig（双旋/一字旋）**。
		    *   *注意*：必须先旋转父节点$p$，再旋转$x$。这是 Splay Tree 能减半路径深度的关键，不能只做两次单旋（那是简单的把$x$转上去，不能有效压缩路径）。



![[Pasted image 20251214145647.png]]
[[Pasted image 20251119120842.png]]

- 关于伸展树及其摊还分析中势能法概念的典型判断题  
1. **定义：** 
    *   对于树中的任意节点$x$，定义其大小$s(x)$为以$x$为根的子树中的节点总数。
    *   定义节点$x$的秩为$r(x)=\log_2(s(x))$。
    *   整棵树的势能$\Phi$定义为所有节点秩的总和，即$\Phi=\sum r(x)$。
2.   **对比两种状态：**[[摊还分析与势能法]]  
    1.  **单链状态（Chain）：**
        当树退化成一条单链时，对于节点数$n$的树，根节点的子树大小为$n$，其孩子的子树大小为$n-1$，以此类推。
        此时所有节点的$s(x)$值分别为$n,n-1,n-2,\dots,1$。
        势能$\Phi_{chain}=\sum_{i=1}^n \log_2 i=\log_2(n!)$。
        这是一个非常大的值，说明树处于**极其不平衡**的状态，势能**最大**。
    2.  **平衡状态（Balanced）：**
        当树是完全平衡二叉树时，树的高度最低，大部分节点的子树大小$s(x)$都会变得相对较小（因为节点分散在更宽的底层）。
        此时$\sum \log_2(s(x))$的值会达到**最小**。
3. **结论：**
	伸展树为单链时，意味着树极其不平衡，此时势能**最大**，而不是最小。只有当树最平衡时，势能才最小。因此题目说法错误。 

- 衍生
	- #伸展树的旋转操作对势能的影响     
		- 考题可能会问具体的旋转方式及其对势能的影响：
			1.  **Zig (单旋):** 当父节点是根节点时使用。
			2.  **Zig-Zig (一字型旋转):** 当节点和父节点都是左孩子或都是右孩子时。**注意：** Splay树不仅是简单的单旋叠加，Zig-Zig操作是先旋转父节点，再旋转当前节点（这一步是Splay保持$O(\log n)$的关键）。
			3.  **Zig-Zag (之字型旋转):** 当节点是左孩子且父节点是右孩子（或反之）时，类似于AVL的双旋。
	- #伸展树时间复杂度    
		- **最坏情况：** 单次操作最坏为$O(n)$（这就解释了为什么单链时势能很高，因为最坏情况就发生在这里）。
		*   **摊还复杂度：** 也就是均摊到多次操作上，是$O(\log n)$。
		*   **对比：**
		    *   AVL树/红黑树：单次最坏$O(\log n)$。
		    *   Splay树：摊还$O(\log n)$。
	* #局部性原理  
		* 考点：为什么用Splay树？
		*   答案：Splay树利用了**局部性原理**。如果是“最近访问过的节点往往很快会被再次访问”的场景（例如缓存Cache），Splay树表现极佳，因为它会将访问过的节点移到根部，下次访问就是$O(1)$。这通常被称为**静态最优性（Static Optimality）**和**工作集性质（Working Set Property）**。
	 - 势能变化的计算
			题目可能给出一个简单的3个节点的树，让你计算从“单链”变成“完全二叉树”后，势能$\Phi$减少了多少。
		*   **计算公式：** $\Delta\Phi=\Phi_{after}-\Phi_{before}$。
- 核心公式总结 
	在解答大题时，可能用到的 #势能分析引理 （Access Lemma）：
	对于一次伸展操作，摊还代价$A$满足：
	$A(x)\le3(r'(x)-r(x))+1=O(\log n)$
	其中$r(x)$是操作前的秩，$r'(x)$是操作后的秩（此时$x$通常已到达根部，秩最大）


![[Pasted image 20251214145632.png]]
[[Pasted image 20251119120847.png]]

- 这道题的答案推导逻辑非常侧重于**数据结构在实际系统（特别是并发系统）中的工程实现代价**，而不仅仅是理论上的时间复杂度  

1. **核心逻辑链条：**
	`平衡性强弱` $\rightarrow$ `维护平衡的代价（旋转次数）` $\rightarrow$ `拓扑结构变化的范围` $\rightarrow$ `并发环境下的锁竞争`  
2.  **对比平衡性：**
    *   **AVL 树**是**严格平衡**的二叉搜索树，要求任意节点的左右子树高度差不超过$1$。
    *   **红黑树（RB Tree）**是**弱平衡**的，它只要求从根到叶子的最长路径不超过最短路径的$2$倍。
3. 对比维护代价（关键点）： 
    *   由于 AVL 树追求严格平衡，在**删除（Delete）**节点时，为了恢复平衡，可能需要从删除点一直向上回溯到根节点进行旋转调整。这意味着在最坏情况下，AVL 树需要进行$O(\log n)$次旋转操作。
    *   红黑树由于平衡条件宽松，在插入或删除节点后，虽然可能需要$O(\log n)$次变色（Color Change），但**旋转（Rotation）操作**的次数是常数级的。具体来说，插入最多需$2$次旋转，删除最多需$3$次旋转，即$O(1)$。
4. 联系到并发与锁
	- 在多线程并发环境中（如数据库索引），为了保证数据一致性，修改树结构时通常需要**加锁**（Lock）。
	*   **旋转操作**涉及改变节点之间的指针引用（父子关系），属于**拓扑结构变化**。这种变化通常需要锁住涉及的所有节点及其周边区域（写锁）。
	*   **变色操作**仅修改节点内部的一个标志位，通常只需要极小范围的原子操作或轻量级锁，甚至不影响树的整体拓扑结构。
	*   **推论：** 因为 AVL 树删除时可能导致大范围的结构旋转（从底向上波及全树），锁的持有时间长、范围大，并发性能差。而红黑树的结构变化被限制在局部（$O(1)$次旋转），锁竞争小，因此在并发场景（如题目图示中的"Concurrent access to a database"）更具优势。

| 特性       | AVL 树          | 红黑树                          |
| :------- | :------------- | :--------------------------- |
| **平衡标准** | 严格（高度差$\le 1$） | 宽松（最长路径$\le 2\times$最短路径）    |
| **查找性能** | 更快（树更矮）        | 较快                           |
| **插入旋转** | 最多$1$次（单旋或双旋）  | 最多$2$次                       |
| **删除旋转** | 最差$O(\log n)$  | 最多$3$次（$O(1)$）               |
| **适用场景** | 读多写少（如字典）      | 写多读多、并发高（如 map, Linux epoll） |


- 衍生 
	- 具体的应用实例（填空/选择）  
		-   **C++ STL：** `std::map`, `std::set`, `std::multimap` 的底层实现通常是**红黑树**。
		*   **Java 集合：** `TreeMap`, `TreeSet` 以及 JDK 8 之后的 `HashMap`（链表长度超过阈值转红黑树）使用的是**红黑树**。
		*   **Linux 内核：** 进程调度（CFS, Completely Fair Scheduler）中使用**红黑树**来管理进程的 `vruntime`；虚拟内存管理（VMA）也用了红黑树。
		*   **IO 多路复用：** Linux 的 `epoll` 系统调用，在内核中维护监听的 socket 集合时，使用的是**红黑树**。
	- #红黑树时间复杂度分析 
		*   问：红黑树中查找、插入、删除的时间复杂度是多少？
		    *   答：均为$O(\log n)$。虽然旋转是$O(1)$，但查找插入位置和变色回溯仍然需要遍历高度。
		*   问：为什么不用二叉搜索树（BST）？
			*   答：BST 在最坏情况下（插入有序序列）会退化成链表，时间复杂度变为$O(n)$。
	- #红黑树的性质判定 （判断题）    
		- 给出一个染色后的树，问是否符合红黑树规则？（通常考察“不能有连续红节点”和“黑高必须相等”这两条）。
	- B+树与红黑树的对比（高频面试/大题）    #红黑树与B➕树的对比  [[B+树与红黑树的对比]]
		-  问：既然红黑树并发好，为什么数据库（如 MySQL）的索引主要用 B+ 树而不是红黑树？
	    *   答：**磁盘 I/O 因素**。红黑树是二叉的，树的高度较高（$O(\log_2 n)$），每一次跳转都可能涉及一次磁盘 I/O。B+ 树是多叉树，树非常“矮胖”（高度通常$3-4$层），极大减少了磁盘 I/O 次数。且 B+ 树叶子节点通过链表连接，更适合范围查询（Range Scan），而红黑树做范围查询需要中序遍历，在磁盘上是随机读，效率低
	* #红黑树最大高度问题  
		* 设红黑树的黑高度为$bh$，则节点总数$n \ge 2^{bh} - 1$。
		*   红黑树的最大高度$h$与节点数$n$的关系为$h \le 2\log_2(n+1)$。这是证明其操作由于$O(\log n)$的基础。



![[Pasted image 20251214145626.png]]
[[Pasted image 20251119120855.png]]
[[红黑树]] 
红黑树中节点的“黑深度”与“黑高度”之和的性质
答案：正确
- #红黑树的五大性质 
	1.  每个节点是红色或黑色。
	2.  根节点是黑色。
	3.  每个叶子节点（NIL节点，空节点）是黑色的。
	4.  如果一个节点是红色的，则它的两个子节点都是黑色的（即不能有连续的红色节点）。
	5.  **（本题考点）** 对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。
1. 对于树中的任意一个节点$x$：
    *   **黑深度（Black Depth, $bd(x)$）：** 指从根节点到该节点$x$的路径上黑色节点的数量（通常包含$x$自身）。
    *   **黑高度（Black Height, $bh(x)$）：** 指从该节点$x$出发（通常不包含$x$自身）到达其子树中任意叶子节点的路径上黑色节点的数量。
2. **求和分析：**
    对于任意节点$x$，任何一条穿过$x$从根到达叶子的路径，其黑色节点总数可以表示为两部分之和：
    $TotalBlackNodes=bd(x)+bh(x)$
    *   第一部分是“根到$x$”的黑色节点数。
    *   第二部分是“$x$到叶子”的黑色节点数。
    
    根据**性质5**，树中所有从根到叶子的路径上的黑色节点总数$H_{total}$是一个**固定值**（常数）。
    
    因此，对于树中的**所有**节点$x$，都有：
    $bd(x)+bh(x)=H_{total}$
    
    既然$H_{total}$是定值，那么所有节点的黑深度与黑高度之和自然也就相等。

- 衍生 
	- #红黑树的最大高度 
		- **问题：** 一棵有$n$个内部节点的红黑树，其最大高度是多少？
		*   **解析：** 根据性质4和性质5，红黑树中最长路径（红黑交替）的长度至多是最短路径（全黑）的两倍。
		*   **公式：** 红黑树的高度$h$满足$h\le2\log_2(n+1)$。这保证了红黑树的操作（查找、插入、删除）时间复杂度始终为$O(\log n)$。
	- 根节点到叶子的最少/最多黑色节点数  
		-  **问题：** 如果一棵红黑树的高度为$h$，那么从根到叶子的黑色节点数至少是多少？
		*   **解析：** 
		    *   最少情况：路径上红黑交替（根黑、红、黑、红...）。此时黑高约为$h/2$。
		    *   最多情况：路径全为黑色。此时黑高为$h$。
	* #红黑树时间复杂度分析  
		* **查找、插入、删除：** 均为$O(\log n)$。
		*   **变色与旋转：** 插入和删除操作后需要通过“变色”和“旋转”来恢复红黑树性质。插入操作最多需要2次旋转，删除操作最多需要3次旋转（虽然变色可能递归向上，但旋转次数是常数级的）。
	- 红黑树与AVL树的对比
		- **平衡性：** AVL树是严格平衡二叉树（高度差不超过1），红黑树是“弱平衡”二叉树。
		*   **性能差异：** 
		    *   **查找：** AVL树由于更平衡，查找效率略高于红黑树。
			*   **插入/删除：** 红黑树的旋转次数更少，维护成本更低，因此在频繁插入删除的场景下（如C++ STL中的`std::map`，Java中的`TreeMap`），红黑树性能优于AVL树。


![[Pasted image 20251214145620.png]]
[[Pasted image 20251119120901.png]]

- 这道题目的答案之所以是 **错误 ($\times$)**，核心在于红黑树删除操作中存在一种特殊情况（双黑修正），该情况只会引起颜色的改变（重染色）并将双黑状态向上传递，而**不需要任何旋转**。如果这种情况一直持续到根节点，就会出现 $\Omega(\log n)$ 次重染色，但旋转次数为 0      [[双黑修正]] 
1. 题目中提到的 **“双黑”
	1.  **情况1：`x` 是根节点。**
	    直接将双黑属性移除，`x` 变为单黑。修复过程结束。
	
	2.  **情况2：`s` 是红色。**
	    这种情况下，需要进行一次旋转，并交换 `s` 和其父节点的颜色。这会将问题转化为 `x` 有一个黑色的兄弟节点的情况（即下面的情况3、4、5）。这个操作本身包含一次旋转，但它会**立即**将问题转化，不会导致问题向上传递。
	
	3.  **情况3：`s` 是黑色，且 `s` 的两个子节点都是黑色。**
	    这是唯一一个**不需要旋转**且**问题会向上传递**的情况。
	    *   **操作**：将 `s` 节点重染色为红色。
	    *   **结果**：`x` 和 `s` 所在的子树黑色高度都减少了1，为了补偿，我们将 `x` 的父节点标记为新的双黑节点，然后从父节点开始，重复整个修复过程。
	    *   **关键点**：这个过程只涉及重染色，然后问题“向上移动”了一层。
	
	4.  **情况4：`s` 是黑色，`s` 的“内部”子节点是红色，“外部”子节点是黑色。**
	    需要一次旋转将这种情况转化为情况5。
	
	5.  **情况5：`s` 是黑色，`s` 的“外部”子节点是红色。**
	    需要一次旋转和几次重染色。这个操作会彻底解决双黑问题，**修复过程结束**。
**推导逻辑：**
1.  题目假设发生了 $\Omega(\log n)$ 次重染色。这意味着双黑修正没有立即停止，而是沿着树向上递归传递了。
2.  观察表格可知，唯一能导致双黑状态**向上传递**（"再次双黑，但将上升一层"）且**不终止**的情况，只有 **情况(2B)**（BB-2B）。
3.  在 **情况(2B)** 中，兄弟节点 $S$ 变红，父节点 $P$ 承接双黑状态，整个过程**旋转次数为 0**。
4.  **极端情况：** 如果从叶子节点开始，一直遇到 **情况(2B)**，双黑状态会一层层向上传递，直到到达**根节点 (Root)**。
5.  当双黑到达根节点时，根据红黑树性质，我们只需要将根节点的“双黑”变成“单黑”（相当于整棵树的黑高减 1），此时调整结束。
6.  **结论：** 在这个极端过程中，我们进行了 $\Omega(\log n)$ 次重染色（每一层一次），但从头到尾**一次旋转都没有发生**。

因此，题目描述“至少旋转一次”是错误的

- 衍生
	- 红黑树与 AVL 树删除操作的区别
		- **问题：** 在最坏情况下，红黑树和 AVL 树删除节点后的调整代价有何不同？
		*   **答案：** AVL 树删除节点后，为了恢复平衡，可能需要从删除点一直旋转到根节点，旋转次数为 $O(\log n)$。而红黑树通过着色调整，最坏情况下只需要 $O(1)$ 次（最多 3 次）旋转，重染色次数为 $O(\log n)$。
	- 红黑树删除操作的终止条件  
		- **问题：** 双黑修正过程在什么情况下会立即终止？
		*   **答案：**
		    1.  遇到 **情况(1)**（兄弟有红子）：旋转并重染色后，黑高恢复，直接结束。
		    2.  遇到 **情况(2R)**（兄弟黑无红子，父红）：交换兄弟和父亲颜色，双黑消除，直接结束。
		    3.  双黑状态传递到了 **根节点**：直接移除多余的黑色，全树黑高减 $1$，结束。
	- 最坏情况的具体构造  
		- **问题：** 请描述一种场景，使得红黑树删除操作完全不发生旋转。
		*   **答案：** 删除一个全黑路径上的叶子节点，且该路径上所有祖先节点的兄弟节点及其子代全为黑色，祖先节点本身也为黑色。这样会触发连锁的 **BB-2B** 修正，直到根节点。    
	* 双黑修正中的“ #假旋转 ” 
		* **问题：** **情况(3)**（红兄弟）发生了旋转，为什么不直接解决双黑？
		*   **答案：** **情况(3)** 的旋转本质上是为了转换结构。兄弟 $S$ 是红色说明父节点 $P$ 必为黑。对 $P$ 进行旋转并改变颜色后，原来的红色兄弟 $S$ 变成了双黑节点的祖父，而双黑节点会有了一个新的、黑色的兄弟。这样就将问题转化为了 **情况(1)** 或 **情况(2)**，从而继续处理。





![[Pasted image 20251214145600.png]]
[[Pasted image 20251119120907.png]]
[[Pasted image 20251119120912.png]]

- 答案 $125$ 是通过构造一棵“最偏”或“最稀疏”的红黑树计算得出的。以下是详细的推导过程、知识点解析及衍生考点。
1. 确定树的黑高  
	1. 红黑树有两个关键性质：
		*   **性质1**：根节点是黑色的。
		*   **性质2**：不能有两个连续的红节点（即红节点的父节点和子节点必须是黑色的）。
		*   **性质3**：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（即黑高相同）。
	2. 已知一条路径上有 $5$ 个红节点。为了使节点总数最少，我们应当让这条路径尽可能“拉长”树的高度，同时让其他分支尽可能短（即全是黑节点）。
		根据性质1和性质2，这条包含 $5$ 个红节点的路径上的颜色排列必然是红黑相间的。
		路径序列（从根往下）：**黑(根) $\to$ 红 $\to$ 黑 $\to$ 红 $\to$ 黑 $\to$ 红 $\to$ 黑 $\to$ 红 $\to$ 黑 $\to$ 红 $\to$ 黑**。
		在这条“主干”路径上，除了 $5$ 个红节点外，为了隔离红节点并满足根是黑色、叶子（NIL）是黑色的要求，至少需要 $6$ 个黑节点（包括根节点和最底部的那个内部黑节点）。
		这意味着该树的 #黑高 （从根节点到叶子的黑色节点数，不含根）至少为 $5$ 
2. 构造最少节点的结构  
	1. 为了使总节点数最少：
		*   **主干路径**：采用上述分析的 $B-R-B-R-B-R-B-R-B-R-B$ 结构。主干上共有 $6$ 个黑节点 + $5$ 个红节点 = $11$ 个节点。
		*   **其他分支**：对于主干上的每一个节点，其“旁支”子树必须满足红黑树的黑高要求，但为了节点最少，这些旁支子树应当是**全黑的满二叉树**（满二叉树节点最少）。
3. 计算节点总数  
	1. 自底向上或按层级计算“挂”在主干上的旁支节点数。
		设 $bh$ 为当前的黑高。对于主干上的每一对（黑节点，红节点），我们需要挂载两棵黑高为 $k$ 的最小子树。
		一棵黑高为 $k$ 的纯黑最小树（满二叉树）的节点数为 $2^k - 1$。
		
		*   **黑高 $h=5$ 的层级**（根节点及其红孩子）：旁支需要黑高为 $5$ 的最小树。节点数为 $2^5 - 1 = 31$。主干上有根和红孩子各挂一个，共 $2 \times 31$。
		*   **黑高 $h=4$ 的层级**：旁支需要黑高为 $4$ 的最小树。节点数为 $2^4 - 1 = 15$。共 $2 \times 15$。
		*   **黑高 $h=3$ 的层级**：旁支节点数 $2^3 - 1 = 7$。共 $2 \times 7$。
		*   **黑高 $h=2$ 的层级**：旁支节点数 $2^2 - 1 = 3$。共 $2 \times 3$。
		*   **黑高 $h=1$ 的层级**：旁支节点数 $2^1 - 1 = 1$。共 $2 \times 1$。
4. **总计算：**
	$Total = \text{主干节点} + \text{旁支节点}$
	$Total = 11 + 2 \times (31 + 15 + 7 + 3 + 1)$
	$Total = 11 + 2 \times 57 = 11 + 114 = 125$

5. 通项公式（图片中的解法）
	设 $n$ 为路径上的红节点数量，则最少节点数 $S(n)$ 的公式为：
	$S(n) = 2^{n+2} - 3$
	代入 $n=5$：
	$S(5) = 2^{5+2} - 3 = 2^7 - 3 = 128 - 3 = 125$

- 衍生 
	- #已知黑高求节点数
	    *   **最少节点数**（全黑）：$n_{min} = 2^{bh} - 1$
	    *   **最多节点数**（红黑相间）：$n_{max} = 2^{2bh} - 1$ （此时树的高度 $h = 2bh$）
	- 已知节点数求最大深度（层高）
		- 红黑树的高度 $h$ 与节点数 $N$ 的关系：$h \le 2\log_2(N+1)$。这保证了红黑树的查找效率为 $O(\log N)$。
	- 红节点数量限制  
		- 如果一棵红黑树有 $N$ 个内部节点，则红节点的比例并没有严格的常数，但根是黑的，且红不相邻。
	    *   **考点**：一棵全黑的树是合法的红黑树吗？**是**。
	    *   **考点**：如果根节点到叶子的路径上黑节点数为 $k$，则树的最短路径长度为 $k$，最长路径长度为 $2k$（红黑交替）。
	- 通用递归递推式  
		- 如果题目稍微变化，比如问“黑高为 $h$ 的红黑树最少有多少个节点”，设 $f(h)$ 为黑高为 $h$ 的最少节点数：
		    *   根节点（黑）的左右子树黑高都必须是 $h-1$。
		    *   为了最少，其中一颗子树可以是黑高 $h-1$ 的红根子树（允许更深），另一颗是黑高 $h-1$ 的黑根子树。
		    *   递推公式：$f(h) = f(h-1) + f(h-1) + 1$ 这种思路通常对应纯黑树。
		    *   但在允许红节点存在以“稀释”节点密度的情况下（如本题），使用的是非平衡的极值构造。
	- 本题关键公式  
		- 若一条路径上有 $n$ 个红节点，红黑树最少节点数 $N$ 为：$N = 2^{n+2} - 3$  
	





![[Pasted image 20251214145611.png]]
[[Pasted image 20251119141134.png]]

- 题目的核心逻辑是计算当节点数$N=2023$时，两种树所能达到的最大高度$h$。树越高，最坏情况下的搜索路径就越长。  
1.  第一步：计算 AVL 树的最大高度
	AVL 树是严格平衡的，其高度增长最慢。要让 AVL 树达到特定高度$h$，所需的**最少**节点数$N_h$遵循斐波那契（Fibonacci）规律。
	根据图中给出的公式$S(h)=fib(h+3)-1$（这里$S(h)$指高度为$h$时的最少节点数）：
	*   我们查找斐波那契数列：$fib(17)=1597$，$fib(18)=2584$。
	*   当高度$h=14$时，最少节点数$S(14)=fib(17)-1=1596$。
	*   当高度$h=15$时，最少节点数$S(15)=fib(18)-1=2583$。
	*   因为题目给定的规模$N=2023$，满足$1596\le2023<2583$。
	*   这意味着 2023 个节点足以构建出高度为 14 的 AVL 树，但不足以构建出高度为 15 的 AVL 树（最少需要 2583 个）。
	*   **结论：** AVL 树的最大高度为**14**。
2. 第二步：计算红黑树的最大高度
	红黑树是“弱平衡”的，允许最长路径是最短路径的 2 倍。
	图中使用了红黑树最大高度的精确计算公式（基于$2\log_2$的变体）：
	$h_{max}=\max\{2(\lfloor\log_2(N+2)\rfloor-1),2\lfloor\log_2\frac{N+2}{3}\rfloor+1\}$
	代入$N=2023$（近似计算）：
	*   $\log_2(2023+2)\approx11$（因为$2^{11}=2048$）。
	*   第一项约为$2(11-1)=20$（图中精算取整后得出 18）。
	*   第二项约为$2\lfloor\log_2(675)\rfloor+1$，因为$2^9=512$，故$\lfloor\log_2(675)\rfloor=9$，结果为$2\times9+1=19$。
	*   取最大值，红黑树高度约为 19。
	*   图中解析最后指出搜索长度为$19-1=18$。
	*   **结论：** 红黑树的最坏搜索长度约为**18**。
3. 第三步：比较
	*   红黑树搜索长度（18） > AVL 树搜索长度（14）。
	*   因此，题干描述“最坏情况下后者的搜索长度比前者更长”是**正确**的。

- 衍生  
	- 插入与删除的代价对比
		*   **AVL：** 由于追求极致平衡，插入或删除节点后，可能需要进行多次旋转（Rotation）来恢复平衡。**维护成本高**，适合**读多写少**的场景。
		*   **红黑树：** 插入最多只需 2 次旋转，删除最多只需 3 次旋转（虽然颜色调整可能回溯到根）。**维护成本相对较低**，适合**频繁插入删除**的场景
	- AVL 树的最少/最多节点数计算  
		- **问题：** 给定高度$h=5$，求 AVL 树最少有多少个节点？
		*   **解法：** 利用递推式$N_h=N_{h-1}+N_{h-2}+1$，从$N_0=0,N_1=1$开始推导。
	- 红黑树的性质判断   
		-  **问题：** 给定一棵涂色的树，判断它是否符合红黑树规则。
		*   **关键点：** 重点检查**“红节点的孩子必须是黑色”**以及**“任意节点到其所有后代叶子的路径上黑色节点数相同”**。  
	* B 树与 B+ 树（大规模数据）
		*    如果规模$N$极其巨大（如数据库索引），AVL 和红黑树的高度都太高（导致磁盘 I/O 次数多），此时会考察**B 树**或**B+ 树**。它们是多路平衡查找树，高度极低，通常为$O(\log_mN)$。
- 总结公式
	在做此类对比题时，可以记住以下经验公式（近似）：
	*   AVL 树高度（最坏）：$h\approx1.44\log_2(N+2)$
	*   红黑树高度（最坏）：$h\approx2\log_2(N+1)$
	显然后者系数更大，也就是树更高。
	



![[Pasted image 20251119141143.png]]