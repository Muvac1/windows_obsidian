好的，这是对您提供的关于2011年计算机考研试卷笔记的全面总结。内容涵盖了数据结构、计算机组成原理、操作系统和计算机网络四大核心领域。

### **第一部分：数据结构**

#### **1. 时间复杂度分析**
*   **问题**: 分析一个循环 `while (x < n/2) { x = 2*x; }`（初始`x=2`）的时间复杂度。
*   **分析**:
    1.  变量 `x` 的值在每次循环后呈指数增长。第 $k$ 次循环后，$x$ 的值为 $2^{k+1}$。
    2.  循环终止条件为 $x \ge n/2$，即 $2^{k+1} \ge n/2$。
    3.  为了解出循环次数 $k$，我们对不等式两边取对数：
        $k+1 \ge \log_2(n/2)$
        $k+1 \ge \log_2 n - 1$
        $k \ge \log_2 n - 2$
    4.  循环执行的次数 $k$ 与 $\log_2 n$ 成正比。因此，时间复杂度为 $O(\log n)$。
*   **答案**: A

#### **2. 栈的操作**
*   **问题**: 给定入栈序列 `a, b, c`，分析出栈序列 `b, c, a` 的操作过程。
*   **分析**:
    1.  `push(a)` -> 栈: `a`
    2.  `push(b)` -> 栈: `a, b`
    3.  `pop()` -> `b`出栈，栈: `a`
    4.  `push(c)` -> 栈: `a, c`
    5.  `pop()` -> `c`出栈，栈: `a`
    6.  `pop()` -> `a`出栈，栈: 空
    *   出栈序列为 `b, c, a`，是可能的。
*   **答案**: B

#### **3. 循环队列**
*   **问题**: 在用数组实现的循环队列中，如何判别队列的“满”状态。
*   **分析**: 为了区分队列为空（`front == rear`）和为满，通常有两种方法：
    1.  **牺牲一个存储单元**: 约定当 `(rear + 1) % MaxSize == front` 时队列为满。
    2.  **设置标志位（或计数器）**: 引入一个标志位`tag`或一个计数器`count`来记录队列状态。例如，`tag=1`表示上次操作是入队，`tag=0`是出队，通过`front == rear`和`tag`的组合来判断空或满。
    *   选项B提到的“另设一个标志位以区别队列是空还是满”是有效且常见的方法。
*   **答案**: B

#### **4. 完全二叉树**
*   **问题**: 一个有999个结点的完全二叉树，其度为1的结点个数是多少？
*   **分析**:
    *   **性质**: 对于一个非空的完全二叉树，如果其总结点数为 $N$，那么其度为1的结点个数 $n_1$ 只有两种可能：0或1。
    *   **规则**: 当 $N$ 为奇数时，$n_1=0$；当 $N$ 为偶数时，$n_1=1$。
    *   **推导**: 度为1的结点只可能是最后一个非叶子结点，且它只有左孩子。这种情况仅当总结点数 $N$ 为偶数时才会发生。因为当 $N$ 为奇数时，最后一个结点（编号为 $N$）是其父结点（编号为 $\lfloor N/2 \rfloor$）的右孩子，这意味着其父结点度为2。
    *   本题中 $N=999$（奇数），因此度为1的结点个数为0。
*   **答案**: A

#### **5. 二叉树遍历**
*   **问题**: 已知一棵二叉树的前序遍历和中序遍历序列，求其后序遍历序列。
*   **分析**: 这是根据两个遍历序列还原二叉树并求第三个序列的经典问题。
    *   **前序遍历**: 根 -> 左 -> 右
    *   **中序遍历**: 左 -> 根 -> 右
    *   **后序遍历**: 左 -> 右 -> 根
    *   通过前序遍历找到根结点，再利用该根结点在中序遍历中划分出左右子树，递归此过程可构建出唯一的二叉树，最后进行后序遍历即可得到答案。
*   **答案**: C

#### **6. 树转换为二叉树**
*   **问题**: 一棵有2011个结点、116个叶子的树，在转换成二叉树后，没有右孩子的结点有多少个？
*   **分析**:
    1.  **转换规则**: 树转换为二叉树时，一个结点 $A$ 的左孩子是它在原树中的第一个孩子，右孩子是它在原树中的下一个兄弟。
    2.  **无右孩子的条件**: 在转换后的二叉树中，一个结点没有右孩子，当且仅当它在原树中**没有下一个兄弟结点**。
    3.  **哪些结点没有下一个兄弟**:
        *   树的根结点。
        *   每个分支中“最右边”的那个孩子结点。
    4.  **计算**:
        *   根结点有1个。
        *   “最右孩子”结点的数量等于有孩子的结点（即分支结点）的数量。
        *   分支结点数 = 总结点数 - 叶子结点数 = $2011 - 116 = 1895$ 个。
        *   总数 = 根结点数 + 分支结点数 = $1 + 1895 = 1896$。
*   **答案**: D

#### **7. 二叉排序树**
*   **问题**: 在二叉排序树中查找一个不存在的关键字，其查找路径与哪个操作的路径相同？
*   **分析**: 二叉排序树的查找过程是从根结点开始，根据关键字与当前结点值的比较结果（大、小、等）决定向左或向右子树继续查找。如果最终到达一个`NULL`链接（即查找失败），则表明该关键字不存在。这个查找失败的路径，恰好就是将该关键字作为新结点**插入**到这棵树中所要经过的路径。
*   **答案**: A

#### **8. 图论**
*   **问题**: 判断关于有向无环图（DAG）的三个命题的正误。
*   **分析**:
    *   **I. 拓扑排序序列唯一**: 错误。如果一个DAG中存在多个入度为0的顶点，那么拓扑排序的起始顶点就有多种选择，导致最终序列不唯一。
    *   **II. 描述稀疏图，邻接表优于邻接矩阵**: 正确。对于稀疏图（边的数量 $e$ 远小于顶点数量 $n$ 的平方），邻接表的空间复杂度为 $O(n+e)$，而邻接矩阵为 $O(n^2)$。邻接表更节省空间。
    *   **III. 若一个图有回路，则它不存在拓扑排序序列**: 正确。拓扑排序的前提就是图必须是有向无环图。存在回路的图无法进行拓扑排序。
*   **答案**: C

#### **9. 哈希表**
*   **问题**: 关于哈希表的说法中，哪个是错误的？
*   **分析**:
    *   哈希函数的设计应使其尽可能将关键字均匀地分布到表中，以减少冲突。
    *   处理冲突的方法（如线性探测）可能会导致“聚集”现象，即冲突的元素聚集在一起，降低查找效率。
    *   装填因子 $\alpha$（表中元素个数/表长）直接影响冲突的概率和平均查找长度，$\alpha$ 越大，性能越差。
    *   **D. 在哈希表中删除一个元素，不能简单地将其所在位置置为空**: 这是正确的说法。因为简单置空会中断查找路径。例如，在线性探测法中，删除元素通常是做一个“删除标记”，而不是真正物理删除，以保证后续元素的查找能够继续进行。题干要求选择错误的说法，但此题选项似乎都是正确的概念描述，可能题目本身存在歧义或考察对“简单置空”的理解。通常认为D是哈希表的一个重要特性，因此不是错误说法。仔细审题发现题目问的是哪个说法**不正确**，而A,B,C都是正确的，D描述了一个正确的操作约束，这表明这个约束是必须的，不是一个错误的说法。重新审视，此题可能是选项设置问题，但标准答案选D可能是认为“不能简单”这一说法不够绝对，但在常规实现中确实如此。
*   **答案**: D

#### **10. 快速排序**
*   **问题**: 快速排序在什么情况下最不利于发挥其优势？
*   **分析**: 快速排序的优势在于其划分操作（Partition）能大致将问题规模减半。当每次划分都极不均衡时，其性能最差。
    *   **最坏情况**: 当输入序列已经有序（或逆序）时，每次选择第一个或最后一个元素作为枢轴（pivot），都会导致划分出的一个子序列为空，另一个子序列仅比原序列少一个元素。这使得递归深度达到 $n$，时间复杂度退化为 $O(n^2)$。
*   **答案**: A

#### **11. 堆排序**
*   **问题**: 对一个序列进行大根堆的初始化（建堆），结果是什么？
*   **分析**: 建堆过程是从最后一个非叶子结点开始，向前逐个进行“下沉”（sift-down）调整。对于序列 `(10, 30, 20, 80, 70, 50, 60, 40, 90)`，最后一个非叶子结点是 `40`（索引4），然后是`60`(3), `50`(2)...直到根`10`(0)。依次对它们进行调整，直到整个序列满足大根堆的定义（父结点的值大于等于其子结点的值）。
*   **答案**: B

### **第二部分：计算机组成原理**

#### **12. 性能评测**
*   **问题**: 哪个指标最适合综合评价计算机系统性能？
*   **分析**:
    *   **MIPS**: 每秒百万条指令，依赖于指令集，无法公平比较不同架构的机器。
    *   **时钟频率 (主频)**: 仅表示CPU的运行速度，不代表实际处理能力，因为不同指令需要不同时钟周期。
    *   **CPI**: 每条指令所需的平均时钟周期数，是衡量指令执行效率的指标，但不是综合性能指标。
    *   **吞吐率/基准程序**: 吞吐率表示单位时间内完成的任务量，而运行基准测试程序（Benchmark）可以直接衡量系统在特定负载下的实际表现，是目前最被广泛接受和使用的综合性能评测方法。
*   **答案**: D

#### **13. IEEE 754 浮点数**
*   **问题**: 将十进制数 -8.25 表示为IEEE 754单精度浮点数。
*   **分析**:
    1.  **符号位(S)**: 负数，S=1。
    2.  **转二进制**: $8.25_{10} = 1000.01_2$。
    3.  **规格化**: $1.00001 \times 2^3$。
    4.  **阶码(E)**: 实际指数 $e=3$。偏置阶码 $E = e + 127 = 3 + 127 = 130$。$130_{10} = 10000010_2$。
    5.  **尾数(M)**: 小数点后的部分 `00001`，补足23位为 `00001000000000000000000`。
    6.  **组合**: `1 10000010 00001000000000000000000`
    7.  **转十六进制**: `C1040000H`
*   **答案**: A

#### **14. 存储器**
*   **问题**: 关于存储器的说法哪个是正确的？
*   **分析**:
    *   A: DRAM（动态RAM）需要定期刷新以维持数据，SRAM（静态RAM）只要供电就无需刷新。
    *   B: 存储器按存取方式主要分为随机存取(RAM)、顺序存取(磁带)、直接存取(磁盘)。
    *   C: Cache通常由速度更快的SRAM构成，主存由DRAM构成。
    *   D: Cache和主存之间的数据交换由硬件自动完成，对程序员是透明的。
*   **答案**: B

#### **15. MAR 位数**
*   **问题**: 主存地址空间64MB，MAR（地址寄存器）至少需要多少位？
*   **分析**: MAR的位数取决于**地址空间**的大小，而不是当前物理内存的容量。
    *   按字节编址，64MB的地址空间需要 $64 \times 2^{20} = 2^6 \times 2^{20} = 2^{26}$ 个不同的地址。
    *   为了能表示 $2^{26}$ 个地址，MAR至少需要26位。
*   **答案**: D

#### **16. 寻址方式**
*   **问题**: 哪个寻址方式需要两次访存来获取操作数？
*   **分析**:
    *   **基址/相对/变址**: 都是将寄存器内容与指令中的地址相加形成有效地址，然后访问一次内存获取操作数。
    *   **间接寻址**: 指令中的地址是存放操作数有效地址的**内存单元的地址**。因此，需要第一次访存根据指令地址取出有效地址，第二次访存再根据这个有效地址取出真正的操作数。
*   **答案**: A

#### **17. 条件转移指令**
*   **问题**: 无符号数比较大于的转移指令`bgt`的跳转条件是什么？
*   **分析**:
    1.  比较`A > B`通常通过计算`A - B`并检查标志位来实现。
    2.  对于无符号数，`A > B`意味着`A - B`的结果不为0且不产生借位。
    3.  不为0，意味着零标志位`ZF=0`。
    4.  不产生借位，意味着进位/借位标志位`CF=0`。
    5.  跳转条件是 `ZF=0` 且 `CF=0`。用逻辑表达式表示为 $\overline{ZF} \cdot \overline{CF}$，根据德摩根定律，等价于 $\overline{ZF+CF}$。
*   **答案**: C

#### **18. 指令流水线**
*   **问题**: 以下哪些设计特点有利于实现指令流水线？
*   **分析**:
    *   **I. 指令格式规整、长度一致**: 简化了取指和译码阶段，使各阶段耗时更均衡。
    *   **II. 指令/数据按边界对齐**: 确保一次内存访问就能取回完整的指令或数据，避免因跨边界而造成的多次访存和流水线停顿。
    *   **III. 只有Load/Store指令访存**: 将计算操作和访存操作分离，使得流水线各阶段功能单一化（如EX阶段只负责计算，MEM阶段只负责访存），极大地简化了流水线控制。
    *   这三条都是典型的RISC（精简指令集计算机）设计思想，非常有利于流水线。
*   **答案**: D

#### **19. CPU 指令周期**
*   **问题**: 在特定条件下，哪个关于CPU的叙述是错误的？
*   **分析**:
    *   A. (正确) 每个指令周期至少访存一次，因为取指令本身就需要访存（题目排除了Cache和预取）。
    *   B. (正确) 指令周期由多个机器周期/时钟周期构成，必然大于等于一个时钟周期。
    *   C. (错误) 空操作指令（NOP）在执行阶段不做任何事，但其取指阶段会使**程序计数器PC**的内容自动增加，以指向下一条指令。PC也是寄存器，所以“任何寄存器内容都不变”是错误的。
    *   D. (正确) “开中断”状态下，CPU在每条指令执行结束后、取下一条指令前会检查中断请求，此时程序可能被中断。
*   **答案**: C

#### **20. 系统总线**
*   **问题**: 哪个信息不通过数据总线传输？
*   **分析**:
    *   **数据总线**: 用于在CPU、内存和I/O设备之间双向传输数据信息，包括指令、操作数、中断类型号等。
    *   **地址总线**: 单向，由CPU发出，用于指定要访问的内存单元或I/O端口的地址。
    *   **控制总线**: 传输控制信号、时序信号和状态信息。**握手信号**（如“请求”、“确认”）是用于协调通信双方时序的控制信号，在控制总线上传输。
*   **答案**: C

#### **21. 中断屏蔽**
*   **问题**: 根据中断优先级设置中断屏蔽字。
*   **分析**:
    1.  **优先级**: $L_4 > L_0 > L_2 > L_1 > L_3$。
    2.  **屏蔽规则**: 当CPU响应某个中断（如$L_1$）时，会自动屏蔽所有**优先级不高于**它的中断源，以防止干扰。
    3.  CPU正在处理$L_1$服务程序，需要屏蔽$L_1$自身以及比它优先级低的$L_3$。
    4.  需要允许比$L_1$优先级高的$L_4, L_0, L_2$中断嵌套。
    5.  屏蔽字中，$M_i=1$表示屏蔽，$M_i=0$表示允许。
    6.  所以应设置$M_1=1, M_3=1$，而$M_4=0, M_0=0, M_2=0$。
    7.  屏蔽字为 $M_4M_3M_2M_1M_0 = 01010$。
*   **答案**: D

#### **22. I/O 占用率**
*   **问题**: 计算定时查询I/O方式下CPU时间的占用百分比。
*   **分析**:
    1.  **CPU总能力**: 每秒时钟周期数 = $50 \text{ MHz} = 50 \times 10^6$ 周期/秒。
    2.  **I/O消耗**:
        *   查询频率 = 200 次/秒。
        *   单次查询耗时 = 500 周期/次。
        *   每秒用于I/O的总周期数 = $200 \times 500 = 100,000$ 周期/秒。
    3.  **占用率**:
        *   百分比 = (I/O消耗周期数 / CPU总周期数) $\times 100\%$
        *   百分比 = ($100,000 / (50 \times 10^6)) \times 100\% = 0.002 \times 100\% = 0.2\%$。
*   **答案**: C

### **第三部分：操作系统**

#### **23. 进程调度算法**
*   **问题**: 哪种调度算法可能导致长作业“饥饿”？
*   **分析**:
    *   **饥饿**: 指一个进程长时间得不到CPU资源。
    *   **短作业优先 (SJF)**: 该算法总是选择执行时间最短的作业。如果系统中不断有新的短作业到来，那么长作业可能永远也得不到执行机会，从而导致饥饿。
    *   FCFS（先来先服务）和时间片轮转对所有作业公平，高响应比优先则会动态提升等待时间长的作业的优先级，都能有效避免饥饿。
*   **答案**: B

#### **24. 用户态与核心态**
*   **问题**: 以下哪个程序在用户态下执行？
*   **分析**:  
    *   **核心态**: 运行操作系统内核程序，具有访问所有硬件和执行所有指令的最高权限。缺页处理、进程调度、时钟中断处理都属于内核功能。
    *   **用户态**: 运行用户应用程序，权限受限，不能直接访问硬件。
    *   **命令解释程序** (如`shell`) 本身是一个应用程序，它在用户态运行，接收用户命令。当需要执行特权操作时，它通过系统调用陷入核心态，请求操作系统服务。
*   **答案**: A

#### **25. 进程与线程**
*   **问题**: 进程内的多个线程，哪个资源不是共享的？
*   **分析**:
    *   **共享资源**: 同一进程内的线程共享进程的代码段、数据段（全局变量）、堆空间、打开的文件、信号等资源。
    *   **私有资源**: 每个线程有自己独立的**栈**和**程序计数器PC**。栈用于存放局部变量、函数参数和返回地址，保证线程的独立执行流。栈指针(SP)是用于管理栈的寄存器，自然也是线程私有的。
*   **答案**: D

#### **26. I/O 请求处理流程**
*   **问题**: 用户程序请求磁盘I/O的正确执行顺序。
*   **分析**:
    1.  **用户程序**: 发出I/O请求（如调用read函数）。
    2.  **系统调用处理程序**: 用户程序通过系统调用陷入内核态，内核的通用I/O处理模块接收请求。
    3.  **设备驱动程序**: 内核调用与特定硬件（磁盘）对应的驱动程序，将逻辑请求转换为硬件指令。
    4.  **中断处理程序**: 磁盘完成操作后，向CPU发送中断信号。CPU响应中断，执行中断处理程序，唤醒等待的进程。
*   **答案**: B

#### **27. 银行家算法**
*   **问题**: 判断给定系统状态是否安全。
*   **分析**:
    1.  **安全性算法**: 模拟系统能否找到一个安全序列，使得所有进程都能顺利完成。
    2.  **初始状态**: `Available = (0, 2, 1)`。
    3.  **第1步**: 只有进程 P₁ 的需求 `Need=(0,0,1)` 小于等于 `Available`。模拟P₁执行完并释放资源，`Work`变为`(0,2,1)+(2,0,0)=(2,2,1)`。安全序列 `<P₁>`。
    4.  **第2步**: 只有进程 P₄ 的需求 `Need=(2,0,0)` 小于等于 `Work`。模拟P₄执行完，`Work`变为`(2,2,1)+(0,0,1)=(2,2,2)`。安全序列 `<P₁, P₄>`。
    5.  **第3步**: 剩下 P₂ 和 P₃，它们的需求 `Need₂=(1,3,2)` 和 `Need₃=(1,3,1)` 都大于 `Work=(2,2,2)`（因为第二种资源不够）。
    6.  **结论**: 无法找到下一个可完成的进程，系统无法找到一个完整的安全序列，因此处于**不安全状态**。
*   **答案**: D

#### **28. 缺页中断**
*   **问题**: 缺页中断处理过程的正确顺序。
*   **分析**:
    1.  **III. 分配页框**: 首先，操作系统必须在物理内存中找到一个空闲的页框来存放即将调入的页面。如果无空闲页框，则需执行页面置换算法。
    2.  **II. 磁盘 I/O**: 启动磁盘，将所需的页面从外存读入到刚刚分配的页框中。
    3.  **I. 修改页表**: 页面调入内存后，更新该页对应的页表项，将有效位置1，并填入物理页框号。
*   **答案**: D

#### **29. 抖动（颠簸）**
*   **问题**: 哪种措施可以消除系统的“抖动”现象？
*   **分析**:
    *   **抖动**的根本原因是内存不足，导致进程频繁地进行页面换入换出，大部分时间都花在I/O上而不是计算。
    *   **I. 撤销部分进程**: 这是最直接有效的办法。撤销进程可以释放其占用的内存页框，增加可用内存，从而降低其他进程的缺页率，缓解抖动。
    *   II. 增加磁盘交换区容量: 治标不治本，不能减少换页频率。
    *   III. 提高进程优先级: 会加剧抖动，因为高优先级进程会更频繁地抢占CPU，然后更快地发生缺页。
*   **答案**: A

#### **30. 地址转换**
*   **问题**: 逻辑地址是在哪个阶段形成的？
*   **分析**:
    *   **编译**: 生成目标模块，地址是相对于模块起始位置的。
    *   **链接**: 链接器将多个目标模块和库组合成一个完整的可执行文件，此时会形成一个统一的、从0开始的逻辑（虚拟）地址空间。
    *   **装载/运行**: 程序被加载到内存，在运行时由MMU将逻辑地址转换为物理地址。
    *   因此，最终的逻辑地址是在链接阶段形成的。
*   **答案**: C

#### **31. I/O 缓冲计算**
*   **问题**: 比较单缓冲和双缓冲处理10个磁盘块的总时间。
*   **分析**:
    *   $T_{io}=100\mu s$ (磁盘读), $T_m=50\mu s$ (内存传送), $T_c=50\mu s$ (CPU分析)。
    *   **双缓冲**: 可以实现I/O操作与CPU操作的并行。处理一个块的时间瓶颈在于 $\max(T_{io}, T_m+T_c) = \max(100, 50+50) = 100\mu s$。
    *   总时间 ≈ (首次I/O) + (后续块的流水线处理) + (最后一块的CPU处理)
        $T_{双} = T_{io} + (N-1) \times \max(T_{io}, T_m+T_c) + (T_m+T_c)$
        因为 $T_{io} = T_m+T_c$，公式可简化为：
        $T_{双} = N \times T_{io} + (T_m+T_c) = 10 \times 100 + (50+50) = 1100\mu s$。
*   **答案**: B

#### **32. 并发进程**
*   **问题**: 两个并发进程分别对共享变量`x`（初值为1）执行+1和-1操作，最终`x`的可能值。
*   **分析**:
    *   `x=x+1`和`x=x-1`都不是原子操作，可分解为“读-改-写”三步。
    *   **串行执行**: 无论谁先谁后，结果都是 `1`。($1+1-1=1$ 或 $1-1+1=1$)
    *   **交错执行 (丢失更新)**:
        *   P1读(x=1), P2读(x=1), P1写(x=2), P2写(x=0)。最终结果为 `0`。
        *   P1读(x=1), P2读(x=1), P2写(x=0), P1写(x=2)。最终结果为 `2`。
    *   因此，所有可能的结果是 `0, 1, 2`。
*   **答案**: C

### **第四部分：计算机网络**

#### **33. 网络层服务**
*   **问题**: Internet网络层提供的服务类型是什么？
*   **分析**: Internet的网络层核心协议是IP协议。IP协议提供的是**无连接、不可靠**的数据报服务。
    *   **无连接**: 每个数据包（IP数据报）独立路由，不事先建立连接。
    *   **不可靠**: 不保证数据包的按序到达、不丢失、不重复，可靠性由上层（如TCP）来保证。
*   **答案**: A

#### **34. 波特率与比特率**
*   **问题**: 数据传输速率2400bps，采用四相位调制，求波特率。
*   **分析**:
    1.  四相位调制意味着一个码元有4种状态 ($N=4$)。
    2.  每个码元能携带的比特数 $k = \log_2 N = \log_2 4 = 2$ bits。
    3.  关系式: 比特率 = 波特率 $\times k$。
    4.  波特率 = 比特率 / $k = 2400 \text{ bps} / 2 = 1200$ 波特 (Baud)。
*   **答案**: B

#### **35. 选择重传协议 (SR)**
*   **问题**: SR协议下，发送0,1,2,3帧，收到1的确认，0和2超时，需要重传多少帧？
*   **分析**: SR协议采用**非累积确认**和**单个计时器**机制。
    *   收到1的确认，表示1号帧成功，其计时器取消。
    *   0号帧计时器超时，意味着0号帧或其ACK丢失，需要重传0号帧。
    *   2号帧计时器超时，意味着2号帧或其ACK丢失，需要重传2号帧。
    *   3号帧计时器未超时，不重传。
    *   因此，需要重传0号和2号共2个帧。
*   **答案**: B

#### **36. 介质访问控制协议**
*   **问题**: 哪个协议在MAC层设计了确认机制？
*   **分析**:
    *   **CSMA/CA (载波侦听多路访问/冲突避免)**: 主要用于无线局域网（WLAN）。由于无线信道存在“隐藏站”问题，无法有效检测冲突，因此它引入了确认（ACK）机制。发送方发送数据帧后，会等待接收方返回一个ACK帧，若未收到则认为发生冲突并重传。
    *   CSMA/CD用于以太网，通过冲突检测而非确认来处理碰撞。
*   **答案**: D

#### **37. 路由聚合**
*   **问题**: 为R1添加一条静态路由，使其能访问R2后的两个子网 `192.168.2.0/25` 和 `192.168.2.128/25`。
*   **分析**:
    1.  **二进制表示**:
        *   `192.168.2.0`   -> ...`00000010.00000000`
        *   `192.168.2.128` -> ...`00000010.10000000`
    2.  **找共同前缀**: 两个地址的前24位相同。
    3.  **聚合路由**:
        *   网络地址: 取共同前缀，主机位置0，即 `192.168.2.0`。
        *   子网掩码: 共同前缀长度为24，即 `/24` 或 `255.255.255.0`。
    4.  **下一跳**: 从R1看，要去往R2后面的网络，必须将数据包发给R2。R2的接口地址是 `192.168.1.2`。
    5.  **组合**: `目的网络 192.168.2.0`, `掩码 255.255.255.0`, `下一跳 192.168.1.2`。
*   **答案**: D

#### **38. IP广播地址**
*   **问题**: 对于网络`192.168.4.0/30`，能接收目的地址为`192.168.4.3`的IP分组的最大主机数是多少？
*   **分析**:
    1.  **/30** 掩码意味着主机位有 $32-30=2$ 位。
    2.  该子网总地址数为 $2^2 = 4$ 个，范围是 `192.168.4.0` 到 `192.168.4.3`。
    3.  **特殊地址**:
        *   网络地址: `192.168.4.0` (主机位全0)
        *   广播地址: `192.168.4.3` (主机位全1)
    4.  目的地址为广播地址的分组，会被该子网内**所有**主机接收。
    5.  该子网可用的主机地址为 `192.168.4.1` 和 `192.168.4.2`，共2台主机。
    6.  因此，最大有2台主机会接收该广播分组。
*   **答案**: C

#### **39. TCP 三次握手**
*   **问题**: TCP三次握手过程中，服务器对客户端的响应报文段内容。
*   **分析**:
    1.  **客户端请求 (第一次)**: `SYN=1, seq=11220`。
    2.  **服务器响应 (第二次)**:
        *   同意连接，所以 `ACK=1`。
        *   确认收到了客户端的SYN，确认号 `ack = 客户端seq + 1 = 11220 + 1 = 11221`。
        *   服务器自己也要发起连接，所以 `SYN=1`。
        *   服务器选择自己的初始序号 `seq`（一个随机数，与客户端无关）。
    3.  **匹配选项**: `SYN=1, ACK=1, ack=11221`。
*   **答案**: C

#### **40. TCP 确认号**
*   **问题**: 主机乙收到第1段和第3段，丢失第2段，应返回的确认号是多少？
*   **分析**:
    1.  **反推序号**:
        *   第3段: `seq=900`, len=500
        *   第2段: `seq = 900 - 400 = 500`, len=400
        *   第1段: `seq = 500 - 300 = 200`, len=300
    2.  **确认机制**: TCP使用**累积确认**。确认号表示期望收到的下一个字节的序号。
    3.  主机乙收到了第1段（字节200-499），是按序的。
    4.  主机乙未收到第2段（字节500-899）。
    5.  主机乙收到了第3段（字节900-1399），是失序的。
    6.  根据累积确认原则，主机乙只能确认到它已收到的**连续**字节流的末尾。它已经连续收到了字节499，因此它期望的下一个字节是500。
    7.  所以，返回的确认号 `ack=500`。
*   **答案**: B